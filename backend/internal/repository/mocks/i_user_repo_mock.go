package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IUserRepo -o ./i_user_repo_mock_test.go -n IUserRepoMock

import (
	"DoramaSet/internal/logic/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IUserRepoMock implements IUserRepo
type IUserRepoMock struct {
	t minimock.Tester

	funcCreateUser          func(ctx context.Context, record *model.User) (err error)
	inspectFuncCreateUser   func(ctx context.Context, record *model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mIUserRepoMockCreateUser

	funcDeleteUser          func(ctx context.Context, username string) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, username string)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mIUserRepoMockDeleteUser

	funcGetPublicInfo          func(ctx context.Context, username string) (up1 *model.User, err error)
	inspectFuncGetPublicInfo   func(ctx context.Context, username string)
	afterGetPublicInfoCounter  uint64
	beforeGetPublicInfoCounter uint64
	GetPublicInfoMock          mIUserRepoMockGetPublicInfo

	funcGetUser          func(ctx context.Context, username string) (up1 *model.User, err error)
	inspectFuncGetUser   func(ctx context.Context, username string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mIUserRepoMockGetUser

	funcUpdateUser          func(ctx context.Context, record model.User) (err error)
	inspectFuncUpdateUser   func(ctx context.Context, record model.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mIUserRepoMockUpdateUser
}

// NewIUserRepoMock returns a mock for IUserRepo
func NewIUserRepoMock(t minimock.Tester) *IUserRepoMock {
	m := &IUserRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mIUserRepoMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*IUserRepoMockCreateUserParams{}

	m.DeleteUserMock = mIUserRepoMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*IUserRepoMockDeleteUserParams{}

	m.GetPublicInfoMock = mIUserRepoMockGetPublicInfo{mock: m}
	m.GetPublicInfoMock.callArgs = []*IUserRepoMockGetPublicInfoParams{}

	m.GetUserMock = mIUserRepoMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*IUserRepoMockGetUserParams{}

	m.UpdateUserMock = mIUserRepoMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*IUserRepoMockUpdateUserParams{}

	return m
}

type mIUserRepoMockCreateUser struct {
	mock               *IUserRepoMock
	defaultExpectation *IUserRepoMockCreateUserExpectation
	expectations       []*IUserRepoMockCreateUserExpectation

	callArgs []*IUserRepoMockCreateUserParams
	mutex    sync.RWMutex
}

// IUserRepoMockCreateUserExpectation specifies expectation struct of the IUserRepo.CreateUser
type IUserRepoMockCreateUserExpectation struct {
	mock    *IUserRepoMock
	params  *IUserRepoMockCreateUserParams
	results *IUserRepoMockCreateUserResults
	Counter uint64
}

// IUserRepoMockCreateUserParams contains parameters of the IUserRepo.CreateUser
type IUserRepoMockCreateUserParams struct {
	ctx    context.Context
	record *model.User
}

// IUserRepoMockCreateUserResults contains results of the IUserRepo.CreateUser
type IUserRepoMockCreateUserResults struct {
	err error
}

// Expect sets up expected params for IUserRepo.CreateUser
func (mmCreateUser *mIUserRepoMockCreateUser) Expect(ctx context.Context, record *model.User) *mIUserRepoMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("IUserRepoMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &IUserRepoMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &IUserRepoMockCreateUserParams{ctx, record}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the IUserRepo.CreateUser
func (mmCreateUser *mIUserRepoMockCreateUser) Inspect(f func(ctx context.Context, record *model.User)) *mIUserRepoMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for IUserRepoMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by IUserRepo.CreateUser
func (mmCreateUser *mIUserRepoMockCreateUser) Return(err error) *IUserRepoMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("IUserRepoMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &IUserRepoMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &IUserRepoMockCreateUserResults{err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the IUserRepo.CreateUser method
func (mmCreateUser *mIUserRepoMockCreateUser) Set(f func(ctx context.Context, record *model.User) (err error)) *IUserRepoMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the IUserRepo.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the IUserRepo.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the IUserRepo.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mIUserRepoMockCreateUser) When(ctx context.Context, record *model.User) *IUserRepoMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("IUserRepoMock.CreateUser mock is already set by Set")
	}

	expectation := &IUserRepoMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &IUserRepoMockCreateUserParams{ctx, record},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up IUserRepo.CreateUser return parameters for the expectation previously defined by the When method
func (e *IUserRepoMockCreateUserExpectation) Then(err error) *IUserRepoMock {
	e.results = &IUserRepoMockCreateUserResults{err}
	return e.mock
}

// CreateUser implements IUserRepo
func (mmCreateUser *IUserRepoMock) CreateUser(ctx context.Context, record *model.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, record)
	}

	mm_params := &IUserRepoMockCreateUserParams{ctx, record}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := IUserRepoMockCreateUserParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("IUserRepoMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the IUserRepoMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, record)
	}
	mmCreateUser.t.Fatalf("Unexpected call to IUserRepoMock.CreateUser. %v %v", ctx, record)
	return
}

// CreateUserAfterCounter returns a count of finished IUserRepoMock.CreateUser invocations
func (mmCreateUser *IUserRepoMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of IUserRepoMock.CreateUser invocations
func (mmCreateUser *IUserRepoMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to IUserRepoMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mIUserRepoMockCreateUser) Calls() []*IUserRepoMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*IUserRepoMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *IUserRepoMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *IUserRepoMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepoMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepoMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to IUserRepoMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to IUserRepoMock.CreateUser")
	}
}

type mIUserRepoMockDeleteUser struct {
	mock               *IUserRepoMock
	defaultExpectation *IUserRepoMockDeleteUserExpectation
	expectations       []*IUserRepoMockDeleteUserExpectation

	callArgs []*IUserRepoMockDeleteUserParams
	mutex    sync.RWMutex
}

// IUserRepoMockDeleteUserExpectation specifies expectation struct of the IUserRepo.DeleteUser
type IUserRepoMockDeleteUserExpectation struct {
	mock    *IUserRepoMock
	params  *IUserRepoMockDeleteUserParams
	results *IUserRepoMockDeleteUserResults
	Counter uint64
}

// IUserRepoMockDeleteUserParams contains parameters of the IUserRepo.DeleteUser
type IUserRepoMockDeleteUserParams struct {
	ctx      context.Context
	username string
}

// IUserRepoMockDeleteUserResults contains results of the IUserRepo.DeleteUser
type IUserRepoMockDeleteUserResults struct {
	err error
}

// Expect sets up expected params for IUserRepo.DeleteUser
func (mmDeleteUser *mIUserRepoMockDeleteUser) Expect(ctx context.Context, username string) *mIUserRepoMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("IUserRepoMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &IUserRepoMockDeleteUserExpectation{}
	}

	mmDeleteUser.defaultExpectation.params = &IUserRepoMockDeleteUserParams{ctx, username}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the IUserRepo.DeleteUser
func (mmDeleteUser *mIUserRepoMockDeleteUser) Inspect(f func(ctx context.Context, username string)) *mIUserRepoMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for IUserRepoMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by IUserRepo.DeleteUser
func (mmDeleteUser *mIUserRepoMockDeleteUser) Return(err error) *IUserRepoMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("IUserRepoMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &IUserRepoMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &IUserRepoMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the IUserRepo.DeleteUser method
func (mmDeleteUser *mIUserRepoMockDeleteUser) Set(f func(ctx context.Context, username string) (err error)) *IUserRepoMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the IUserRepo.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the IUserRepo.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the IUserRepo.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mIUserRepoMockDeleteUser) When(ctx context.Context, username string) *IUserRepoMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("IUserRepoMock.DeleteUser mock is already set by Set")
	}

	expectation := &IUserRepoMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &IUserRepoMockDeleteUserParams{ctx, username},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up IUserRepo.DeleteUser return parameters for the expectation previously defined by the When method
func (e *IUserRepoMockDeleteUserExpectation) Then(err error) *IUserRepoMock {
	e.results = &IUserRepoMockDeleteUserResults{err}
	return e.mock
}

// DeleteUser implements IUserRepo
func (mmDeleteUser *IUserRepoMock) DeleteUser(ctx context.Context, username string) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, username)
	}

	mm_params := &IUserRepoMockDeleteUserParams{ctx, username}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_got := IUserRepoMockDeleteUserParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("IUserRepoMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the IUserRepoMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, username)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to IUserRepoMock.DeleteUser. %v %v", ctx, username)
	return
}

// DeleteUserAfterCounter returns a count of finished IUserRepoMock.DeleteUser invocations
func (mmDeleteUser *IUserRepoMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of IUserRepoMock.DeleteUser invocations
func (mmDeleteUser *IUserRepoMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to IUserRepoMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mIUserRepoMockDeleteUser) Calls() []*IUserRepoMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*IUserRepoMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *IUserRepoMock) MinimockDeleteUserDone() bool {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *IUserRepoMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepoMock.DeleteUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepoMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to IUserRepoMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		m.t.Error("Expected call to IUserRepoMock.DeleteUser")
	}
}

type mIUserRepoMockGetPublicInfo struct {
	mock               *IUserRepoMock
	defaultExpectation *IUserRepoMockGetPublicInfoExpectation
	expectations       []*IUserRepoMockGetPublicInfoExpectation

	callArgs []*IUserRepoMockGetPublicInfoParams
	mutex    sync.RWMutex
}

// IUserRepoMockGetPublicInfoExpectation specifies expectation struct of the IUserRepo.GetPublicInfo
type IUserRepoMockGetPublicInfoExpectation struct {
	mock    *IUserRepoMock
	params  *IUserRepoMockGetPublicInfoParams
	results *IUserRepoMockGetPublicInfoResults
	Counter uint64
}

// IUserRepoMockGetPublicInfoParams contains parameters of the IUserRepo.GetPublicInfo
type IUserRepoMockGetPublicInfoParams struct {
	ctx      context.Context
	username string
}

// IUserRepoMockGetPublicInfoResults contains results of the IUserRepo.GetPublicInfo
type IUserRepoMockGetPublicInfoResults struct {
	up1 *model.User
	err error
}

// Expect sets up expected params for IUserRepo.GetPublicInfo
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) Expect(ctx context.Context, username string) *mIUserRepoMockGetPublicInfo {
	if mmGetPublicInfo.mock.funcGetPublicInfo != nil {
		mmGetPublicInfo.mock.t.Fatalf("IUserRepoMock.GetPublicInfo mock is already set by Set")
	}

	if mmGetPublicInfo.defaultExpectation == nil {
		mmGetPublicInfo.defaultExpectation = &IUserRepoMockGetPublicInfoExpectation{}
	}

	mmGetPublicInfo.defaultExpectation.params = &IUserRepoMockGetPublicInfoParams{ctx, username}
	for _, e := range mmGetPublicInfo.expectations {
		if minimock.Equal(e.params, mmGetPublicInfo.defaultExpectation.params) {
			mmGetPublicInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublicInfo.defaultExpectation.params)
		}
	}

	return mmGetPublicInfo
}

// Inspect accepts an inspector function that has same arguments as the IUserRepo.GetPublicInfo
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) Inspect(f func(ctx context.Context, username string)) *mIUserRepoMockGetPublicInfo {
	if mmGetPublicInfo.mock.inspectFuncGetPublicInfo != nil {
		mmGetPublicInfo.mock.t.Fatalf("Inspect function is already set for IUserRepoMock.GetPublicInfo")
	}

	mmGetPublicInfo.mock.inspectFuncGetPublicInfo = f

	return mmGetPublicInfo
}

// Return sets up results that will be returned by IUserRepo.GetPublicInfo
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) Return(up1 *model.User, err error) *IUserRepoMock {
	if mmGetPublicInfo.mock.funcGetPublicInfo != nil {
		mmGetPublicInfo.mock.t.Fatalf("IUserRepoMock.GetPublicInfo mock is already set by Set")
	}

	if mmGetPublicInfo.defaultExpectation == nil {
		mmGetPublicInfo.defaultExpectation = &IUserRepoMockGetPublicInfoExpectation{mock: mmGetPublicInfo.mock}
	}
	mmGetPublicInfo.defaultExpectation.results = &IUserRepoMockGetPublicInfoResults{up1, err}
	return mmGetPublicInfo.mock
}

// Set uses given function f to mock the IUserRepo.GetPublicInfo method
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) Set(f func(ctx context.Context, username string) (up1 *model.User, err error)) *IUserRepoMock {
	if mmGetPublicInfo.defaultExpectation != nil {
		mmGetPublicInfo.mock.t.Fatalf("Default expectation is already set for the IUserRepo.GetPublicInfo method")
	}

	if len(mmGetPublicInfo.expectations) > 0 {
		mmGetPublicInfo.mock.t.Fatalf("Some expectations are already set for the IUserRepo.GetPublicInfo method")
	}

	mmGetPublicInfo.mock.funcGetPublicInfo = f
	return mmGetPublicInfo.mock
}

// When sets expectation for the IUserRepo.GetPublicInfo which will trigger the result defined by the following
// Then helper
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) When(ctx context.Context, username string) *IUserRepoMockGetPublicInfoExpectation {
	if mmGetPublicInfo.mock.funcGetPublicInfo != nil {
		mmGetPublicInfo.mock.t.Fatalf("IUserRepoMock.GetPublicInfo mock is already set by Set")
	}

	expectation := &IUserRepoMockGetPublicInfoExpectation{
		mock:   mmGetPublicInfo.mock,
		params: &IUserRepoMockGetPublicInfoParams{ctx, username},
	}
	mmGetPublicInfo.expectations = append(mmGetPublicInfo.expectations, expectation)
	return expectation
}

// Then sets up IUserRepo.GetPublicInfo return parameters for the expectation previously defined by the When method
func (e *IUserRepoMockGetPublicInfoExpectation) Then(up1 *model.User, err error) *IUserRepoMock {
	e.results = &IUserRepoMockGetPublicInfoResults{up1, err}
	return e.mock
}

// GetPublicInfo implements IUserRepo
func (mmGetPublicInfo *IUserRepoMock) GetPublicInfo(ctx context.Context, username string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetPublicInfo.beforeGetPublicInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublicInfo.afterGetPublicInfoCounter, 1)

	if mmGetPublicInfo.inspectFuncGetPublicInfo != nil {
		mmGetPublicInfo.inspectFuncGetPublicInfo(ctx, username)
	}

	mm_params := &IUserRepoMockGetPublicInfoParams{ctx, username}

	// Record call args
	mmGetPublicInfo.GetPublicInfoMock.mutex.Lock()
	mmGetPublicInfo.GetPublicInfoMock.callArgs = append(mmGetPublicInfo.GetPublicInfoMock.callArgs, mm_params)
	mmGetPublicInfo.GetPublicInfoMock.mutex.Unlock()

	for _, e := range mmGetPublicInfo.GetPublicInfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPublicInfo.GetPublicInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublicInfo.GetPublicInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublicInfo.GetPublicInfoMock.defaultExpectation.params
		mm_got := IUserRepoMockGetPublicInfoParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublicInfo.t.Errorf("IUserRepoMock.GetPublicInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublicInfo.GetPublicInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublicInfo.t.Fatal("No results are set for the IUserRepoMock.GetPublicInfo")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPublicInfo.funcGetPublicInfo != nil {
		return mmGetPublicInfo.funcGetPublicInfo(ctx, username)
	}
	mmGetPublicInfo.t.Fatalf("Unexpected call to IUserRepoMock.GetPublicInfo. %v %v", ctx, username)
	return
}

// GetPublicInfoAfterCounter returns a count of finished IUserRepoMock.GetPublicInfo invocations
func (mmGetPublicInfo *IUserRepoMock) GetPublicInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicInfo.afterGetPublicInfoCounter)
}

// GetPublicInfoBeforeCounter returns a count of IUserRepoMock.GetPublicInfo invocations
func (mmGetPublicInfo *IUserRepoMock) GetPublicInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicInfo.beforeGetPublicInfoCounter)
}

// Calls returns a list of arguments used in each call to IUserRepoMock.GetPublicInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublicInfo *mIUserRepoMockGetPublicInfo) Calls() []*IUserRepoMockGetPublicInfoParams {
	mmGetPublicInfo.mutex.RLock()

	argCopy := make([]*IUserRepoMockGetPublicInfoParams, len(mmGetPublicInfo.callArgs))
	copy(argCopy, mmGetPublicInfo.callArgs)

	mmGetPublicInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublicInfoDone returns true if the count of the GetPublicInfo invocations corresponds
// the number of defined expectations
func (m *IUserRepoMock) MinimockGetPublicInfoDone() bool {
	for _, e := range m.GetPublicInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicInfo != nil && mm_atomic.LoadUint64(&m.afterGetPublicInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublicInfoInspect logs each unmet expectation
func (m *IUserRepoMock) MinimockGetPublicInfoInspect() {
	for _, e := range m.GetPublicInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepoMock.GetPublicInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicInfoCounter) < 1 {
		if m.GetPublicInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepoMock.GetPublicInfo")
		} else {
			m.t.Errorf("Expected call to IUserRepoMock.GetPublicInfo with params: %#v", *m.GetPublicInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicInfo != nil && mm_atomic.LoadUint64(&m.afterGetPublicInfoCounter) < 1 {
		m.t.Error("Expected call to IUserRepoMock.GetPublicInfo")
	}
}

type mIUserRepoMockGetUser struct {
	mock               *IUserRepoMock
	defaultExpectation *IUserRepoMockGetUserExpectation
	expectations       []*IUserRepoMockGetUserExpectation

	callArgs []*IUserRepoMockGetUserParams
	mutex    sync.RWMutex
}

// IUserRepoMockGetUserExpectation specifies expectation struct of the IUserRepo.GetUser
type IUserRepoMockGetUserExpectation struct {
	mock    *IUserRepoMock
	params  *IUserRepoMockGetUserParams
	results *IUserRepoMockGetUserResults
	Counter uint64
}

// IUserRepoMockGetUserParams contains parameters of the IUserRepo.GetUser
type IUserRepoMockGetUserParams struct {
	ctx      context.Context
	username string
}

// IUserRepoMockGetUserResults contains results of the IUserRepo.GetUser
type IUserRepoMockGetUserResults struct {
	up1 *model.User
	err error
}

// Expect sets up expected params for IUserRepo.GetUser
func (mmGetUser *mIUserRepoMockGetUser) Expect(ctx context.Context, username string) *mIUserRepoMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("IUserRepoMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &IUserRepoMockGetUserExpectation{}
	}

	mmGetUser.defaultExpectation.params = &IUserRepoMockGetUserParams{ctx, username}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the IUserRepo.GetUser
func (mmGetUser *mIUserRepoMockGetUser) Inspect(f func(ctx context.Context, username string)) *mIUserRepoMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for IUserRepoMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by IUserRepo.GetUser
func (mmGetUser *mIUserRepoMockGetUser) Return(up1 *model.User, err error) *IUserRepoMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("IUserRepoMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &IUserRepoMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &IUserRepoMockGetUserResults{up1, err}
	return mmGetUser.mock
}

// Set uses given function f to mock the IUserRepo.GetUser method
func (mmGetUser *mIUserRepoMockGetUser) Set(f func(ctx context.Context, username string) (up1 *model.User, err error)) *IUserRepoMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the IUserRepo.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the IUserRepo.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the IUserRepo.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mIUserRepoMockGetUser) When(ctx context.Context, username string) *IUserRepoMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("IUserRepoMock.GetUser mock is already set by Set")
	}

	expectation := &IUserRepoMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &IUserRepoMockGetUserParams{ctx, username},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up IUserRepo.GetUser return parameters for the expectation previously defined by the When method
func (e *IUserRepoMockGetUserExpectation) Then(up1 *model.User, err error) *IUserRepoMock {
	e.results = &IUserRepoMockGetUserResults{up1, err}
	return e.mock
}

// GetUser implements IUserRepo
func (mmGetUser *IUserRepoMock) GetUser(ctx context.Context, username string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, username)
	}

	mm_params := &IUserRepoMockGetUserParams{ctx, username}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_got := IUserRepoMockGetUserParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("IUserRepoMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the IUserRepoMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, username)
	}
	mmGetUser.t.Fatalf("Unexpected call to IUserRepoMock.GetUser. %v %v", ctx, username)
	return
}

// GetUserAfterCounter returns a count of finished IUserRepoMock.GetUser invocations
func (mmGetUser *IUserRepoMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of IUserRepoMock.GetUser invocations
func (mmGetUser *IUserRepoMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to IUserRepoMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mIUserRepoMockGetUser) Calls() []*IUserRepoMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*IUserRepoMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *IUserRepoMock) MinimockGetUserDone() bool {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserInspect logs each unmet expectation
func (m *IUserRepoMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepoMock.GetUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepoMock.GetUser")
		} else {
			m.t.Errorf("Expected call to IUserRepoMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to IUserRepoMock.GetUser")
	}
}

type mIUserRepoMockUpdateUser struct {
	mock               *IUserRepoMock
	defaultExpectation *IUserRepoMockUpdateUserExpectation
	expectations       []*IUserRepoMockUpdateUserExpectation

	callArgs []*IUserRepoMockUpdateUserParams
	mutex    sync.RWMutex
}

// IUserRepoMockUpdateUserExpectation specifies expectation struct of the IUserRepo.UpdateUser
type IUserRepoMockUpdateUserExpectation struct {
	mock    *IUserRepoMock
	params  *IUserRepoMockUpdateUserParams
	results *IUserRepoMockUpdateUserResults
	Counter uint64
}

// IUserRepoMockUpdateUserParams contains parameters of the IUserRepo.UpdateUser
type IUserRepoMockUpdateUserParams struct {
	ctx    context.Context
	record model.User
}

// IUserRepoMockUpdateUserResults contains results of the IUserRepo.UpdateUser
type IUserRepoMockUpdateUserResults struct {
	err error
}

// Expect sets up expected params for IUserRepo.UpdateUser
func (mmUpdateUser *mIUserRepoMockUpdateUser) Expect(ctx context.Context, record model.User) *mIUserRepoMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("IUserRepoMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &IUserRepoMockUpdateUserExpectation{}
	}

	mmUpdateUser.defaultExpectation.params = &IUserRepoMockUpdateUserParams{ctx, record}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the IUserRepo.UpdateUser
func (mmUpdateUser *mIUserRepoMockUpdateUser) Inspect(f func(ctx context.Context, record model.User)) *mIUserRepoMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for IUserRepoMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by IUserRepo.UpdateUser
func (mmUpdateUser *mIUserRepoMockUpdateUser) Return(err error) *IUserRepoMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("IUserRepoMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &IUserRepoMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &IUserRepoMockUpdateUserResults{err}
	return mmUpdateUser.mock
}

// Set uses given function f to mock the IUserRepo.UpdateUser method
func (mmUpdateUser *mIUserRepoMockUpdateUser) Set(f func(ctx context.Context, record model.User) (err error)) *IUserRepoMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the IUserRepo.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the IUserRepo.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the IUserRepo.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mIUserRepoMockUpdateUser) When(ctx context.Context, record model.User) *IUserRepoMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("IUserRepoMock.UpdateUser mock is already set by Set")
	}

	expectation := &IUserRepoMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &IUserRepoMockUpdateUserParams{ctx, record},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up IUserRepo.UpdateUser return parameters for the expectation previously defined by the When method
func (e *IUserRepoMockUpdateUserExpectation) Then(err error) *IUserRepoMock {
	e.results = &IUserRepoMockUpdateUserResults{err}
	return e.mock
}

// UpdateUser implements IUserRepo
func (mmUpdateUser *IUserRepoMock) UpdateUser(ctx context.Context, record model.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, record)
	}

	mm_params := &IUserRepoMockUpdateUserParams{ctx, record}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_got := IUserRepoMockUpdateUserParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("IUserRepoMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the IUserRepoMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, record)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to IUserRepoMock.UpdateUser. %v %v", ctx, record)
	return
}

// UpdateUserAfterCounter returns a count of finished IUserRepoMock.UpdateUser invocations
func (mmUpdateUser *IUserRepoMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of IUserRepoMock.UpdateUser invocations
func (mmUpdateUser *IUserRepoMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to IUserRepoMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mIUserRepoMockUpdateUser) Calls() []*IUserRepoMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*IUserRepoMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *IUserRepoMock) MinimockUpdateUserDone() bool {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *IUserRepoMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepoMock.UpdateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepoMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to IUserRepoMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		m.t.Error("Expected call to IUserRepoMock.UpdateUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IUserRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateUserInspect()

		m.MinimockDeleteUserInspect()

		m.MinimockGetPublicInfoInspect()

		m.MinimockGetUserInspect()

		m.MinimockUpdateUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IUserRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IUserRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetPublicInfoDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone()
}
