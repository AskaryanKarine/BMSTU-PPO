package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IListRepo -o ./i_list_repo_mock_test.go -n IListRepoMock

import (
	"DoramaSet/internal/logic/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IListRepoMock implements IListRepo
type IListRepoMock struct {
	t minimock.Tester

	funcAddToFav          func(ctx context.Context, idL int, username string) (err error)
	inspectFuncAddToFav   func(ctx context.Context, idL int, username string)
	afterAddToFavCounter  uint64
	beforeAddToFavCounter uint64
	AddToFavMock          mIListRepoMockAddToFav

	funcAddToList          func(ctx context.Context, idL int, idD int) (err error)
	inspectFuncAddToList   func(ctx context.Context, idL int, idD int)
	afterAddToListCounter  uint64
	beforeAddToListCounter uint64
	AddToListMock          mIListRepoMockAddToList

	funcCreateList          func(ctx context.Context, list model.List) (i1 int, err error)
	inspectFuncCreateList   func(ctx context.Context, list model.List)
	afterCreateListCounter  uint64
	beforeCreateListCounter uint64
	CreateListMock          mIListRepoMockCreateList

	funcDelFromList          func(ctx context.Context, idL int, idD int) (err error)
	inspectFuncDelFromList   func(ctx context.Context, idL int, idD int)
	afterDelFromListCounter  uint64
	beforeDelFromListCounter uint64
	DelFromListMock          mIListRepoMockDelFromList

	funcDelList          func(ctx context.Context, id int) (err error)
	inspectFuncDelList   func(ctx context.Context, id int)
	afterDelListCounter  uint64
	beforeDelListCounter uint64
	DelListMock          mIListRepoMockDelList

	funcGetFavList          func(ctx context.Context, username string) (la1 []model.List, err error)
	inspectFuncGetFavList   func(ctx context.Context, username string)
	afterGetFavListCounter  uint64
	beforeGetFavListCounter uint64
	GetFavListMock          mIListRepoMockGetFavList

	funcGetListId          func(ctx context.Context, id int) (lp1 *model.List, err error)
	inspectFuncGetListId   func(ctx context.Context, id int)
	afterGetListIdCounter  uint64
	beforeGetListIdCounter uint64
	GetListIdMock          mIListRepoMockGetListId

	funcGetPublicLists          func(ctx context.Context) (la1 []model.List, err error)
	inspectFuncGetPublicLists   func(ctx context.Context)
	afterGetPublicListsCounter  uint64
	beforeGetPublicListsCounter uint64
	GetPublicListsMock          mIListRepoMockGetPublicLists

	funcGetUserLists          func(ctx context.Context, username string) (la1 []model.List, err error)
	inspectFuncGetUserLists   func(ctx context.Context, username string)
	afterGetUserListsCounter  uint64
	beforeGetUserListsCounter uint64
	GetUserListsMock          mIListRepoMockGetUserLists
}

// NewIListRepoMock returns a mock for IListRepo
func NewIListRepoMock(t minimock.Tester) *IListRepoMock {
	m := &IListRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToFavMock = mIListRepoMockAddToFav{mock: m}
	m.AddToFavMock.callArgs = []*IListRepoMockAddToFavParams{}

	m.AddToListMock = mIListRepoMockAddToList{mock: m}
	m.AddToListMock.callArgs = []*IListRepoMockAddToListParams{}

	m.CreateListMock = mIListRepoMockCreateList{mock: m}
	m.CreateListMock.callArgs = []*IListRepoMockCreateListParams{}

	m.DelFromListMock = mIListRepoMockDelFromList{mock: m}
	m.DelFromListMock.callArgs = []*IListRepoMockDelFromListParams{}

	m.DelListMock = mIListRepoMockDelList{mock: m}
	m.DelListMock.callArgs = []*IListRepoMockDelListParams{}

	m.GetFavListMock = mIListRepoMockGetFavList{mock: m}
	m.GetFavListMock.callArgs = []*IListRepoMockGetFavListParams{}

	m.GetListIdMock = mIListRepoMockGetListId{mock: m}
	m.GetListIdMock.callArgs = []*IListRepoMockGetListIdParams{}

	m.GetPublicListsMock = mIListRepoMockGetPublicLists{mock: m}
	m.GetPublicListsMock.callArgs = []*IListRepoMockGetPublicListsParams{}

	m.GetUserListsMock = mIListRepoMockGetUserLists{mock: m}
	m.GetUserListsMock.callArgs = []*IListRepoMockGetUserListsParams{}

	return m
}

type mIListRepoMockAddToFav struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockAddToFavExpectation
	expectations       []*IListRepoMockAddToFavExpectation

	callArgs []*IListRepoMockAddToFavParams
	mutex    sync.RWMutex
}

// IListRepoMockAddToFavExpectation specifies expectation struct of the IListRepo.AddToFav
type IListRepoMockAddToFavExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockAddToFavParams
	results *IListRepoMockAddToFavResults
	Counter uint64
}

// IListRepoMockAddToFavParams contains parameters of the IListRepo.AddToFav
type IListRepoMockAddToFavParams struct {
	ctx      context.Context
	idL      int
	username string
}

// IListRepoMockAddToFavResults contains results of the IListRepo.AddToFav
type IListRepoMockAddToFavResults struct {
	err error
}

// Expect sets up expected params for IListRepo.AddToFav
func (mmAddToFav *mIListRepoMockAddToFav) Expect(ctx context.Context, idL int, username string) *mIListRepoMockAddToFav {
	if mmAddToFav.mock.funcAddToFav != nil {
		mmAddToFav.mock.t.Fatalf("IListRepoMock.AddToFav mock is already set by Set")
	}

	if mmAddToFav.defaultExpectation == nil {
		mmAddToFav.defaultExpectation = &IListRepoMockAddToFavExpectation{}
	}

	mmAddToFav.defaultExpectation.params = &IListRepoMockAddToFavParams{ctx, idL, username}
	for _, e := range mmAddToFav.expectations {
		if minimock.Equal(e.params, mmAddToFav.defaultExpectation.params) {
			mmAddToFav.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToFav.defaultExpectation.params)
		}
	}

	return mmAddToFav
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.AddToFav
func (mmAddToFav *mIListRepoMockAddToFav) Inspect(f func(ctx context.Context, idL int, username string)) *mIListRepoMockAddToFav {
	if mmAddToFav.mock.inspectFuncAddToFav != nil {
		mmAddToFav.mock.t.Fatalf("Inspect function is already set for IListRepoMock.AddToFav")
	}

	mmAddToFav.mock.inspectFuncAddToFav = f

	return mmAddToFav
}

// Return sets up results that will be returned by IListRepo.AddToFav
func (mmAddToFav *mIListRepoMockAddToFav) Return(err error) *IListRepoMock {
	if mmAddToFav.mock.funcAddToFav != nil {
		mmAddToFav.mock.t.Fatalf("IListRepoMock.AddToFav mock is already set by Set")
	}

	if mmAddToFav.defaultExpectation == nil {
		mmAddToFav.defaultExpectation = &IListRepoMockAddToFavExpectation{mock: mmAddToFav.mock}
	}
	mmAddToFav.defaultExpectation.results = &IListRepoMockAddToFavResults{err}
	return mmAddToFav.mock
}

// Set uses given function f to mock the IListRepo.AddToFav method
func (mmAddToFav *mIListRepoMockAddToFav) Set(f func(ctx context.Context, idL int, username string) (err error)) *IListRepoMock {
	if mmAddToFav.defaultExpectation != nil {
		mmAddToFav.mock.t.Fatalf("Default expectation is already set for the IListRepo.AddToFav method")
	}

	if len(mmAddToFav.expectations) > 0 {
		mmAddToFav.mock.t.Fatalf("Some expectations are already set for the IListRepo.AddToFav method")
	}

	mmAddToFav.mock.funcAddToFav = f
	return mmAddToFav.mock
}

// When sets expectation for the IListRepo.AddToFav which will trigger the result defined by the following
// Then helper
func (mmAddToFav *mIListRepoMockAddToFav) When(ctx context.Context, idL int, username string) *IListRepoMockAddToFavExpectation {
	if mmAddToFav.mock.funcAddToFav != nil {
		mmAddToFav.mock.t.Fatalf("IListRepoMock.AddToFav mock is already set by Set")
	}

	expectation := &IListRepoMockAddToFavExpectation{
		mock:   mmAddToFav.mock,
		params: &IListRepoMockAddToFavParams{ctx, idL, username},
	}
	mmAddToFav.expectations = append(mmAddToFav.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.AddToFav return parameters for the expectation previously defined by the When method
func (e *IListRepoMockAddToFavExpectation) Then(err error) *IListRepoMock {
	e.results = &IListRepoMockAddToFavResults{err}
	return e.mock
}

// AddToFav implements IListRepo
func (mmAddToFav *IListRepoMock) AddToFav(ctx context.Context, idL int, username string) (err error) {
	mm_atomic.AddUint64(&mmAddToFav.beforeAddToFavCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToFav.afterAddToFavCounter, 1)

	if mmAddToFav.inspectFuncAddToFav != nil {
		mmAddToFav.inspectFuncAddToFav(ctx, idL, username)
	}

	mm_params := &IListRepoMockAddToFavParams{ctx, idL, username}

	// Record call args
	mmAddToFav.AddToFavMock.mutex.Lock()
	mmAddToFav.AddToFavMock.callArgs = append(mmAddToFav.AddToFavMock.callArgs, mm_params)
	mmAddToFav.AddToFavMock.mutex.Unlock()

	for _, e := range mmAddToFav.AddToFavMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToFav.AddToFavMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToFav.AddToFavMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToFav.AddToFavMock.defaultExpectation.params
		mm_got := IListRepoMockAddToFavParams{ctx, idL, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToFav.t.Errorf("IListRepoMock.AddToFav got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToFav.AddToFavMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToFav.t.Fatal("No results are set for the IListRepoMock.AddToFav")
		}
		return (*mm_results).err
	}
	if mmAddToFav.funcAddToFav != nil {
		return mmAddToFav.funcAddToFav(ctx, idL, username)
	}
	mmAddToFav.t.Fatalf("Unexpected call to IListRepoMock.AddToFav. %v %v %v", ctx, idL, username)
	return
}

// AddToFavAfterCounter returns a count of finished IListRepoMock.AddToFav invocations
func (mmAddToFav *IListRepoMock) AddToFavAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToFav.afterAddToFavCounter)
}

// AddToFavBeforeCounter returns a count of IListRepoMock.AddToFav invocations
func (mmAddToFav *IListRepoMock) AddToFavBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToFav.beforeAddToFavCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.AddToFav.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToFav *mIListRepoMockAddToFav) Calls() []*IListRepoMockAddToFavParams {
	mmAddToFav.mutex.RLock()

	argCopy := make([]*IListRepoMockAddToFavParams, len(mmAddToFav.callArgs))
	copy(argCopy, mmAddToFav.callArgs)

	mmAddToFav.mutex.RUnlock()

	return argCopy
}

// MinimockAddToFavDone returns true if the count of the AddToFav invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockAddToFavDone() bool {
	for _, e := range m.AddToFavMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToFavMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToFavCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToFav != nil && mm_atomic.LoadUint64(&m.afterAddToFavCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToFavInspect logs each unmet expectation
func (m *IListRepoMock) MinimockAddToFavInspect() {
	for _, e := range m.AddToFavMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.AddToFav with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToFavMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToFavCounter) < 1 {
		if m.AddToFavMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.AddToFav")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.AddToFav with params: %#v", *m.AddToFavMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToFav != nil && mm_atomic.LoadUint64(&m.afterAddToFavCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.AddToFav")
	}
}

type mIListRepoMockAddToList struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockAddToListExpectation
	expectations       []*IListRepoMockAddToListExpectation

	callArgs []*IListRepoMockAddToListParams
	mutex    sync.RWMutex
}

// IListRepoMockAddToListExpectation specifies expectation struct of the IListRepo.AddToList
type IListRepoMockAddToListExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockAddToListParams
	results *IListRepoMockAddToListResults
	Counter uint64
}

// IListRepoMockAddToListParams contains parameters of the IListRepo.AddToList
type IListRepoMockAddToListParams struct {
	ctx context.Context
	idL int
	idD int
}

// IListRepoMockAddToListResults contains results of the IListRepo.AddToList
type IListRepoMockAddToListResults struct {
	err error
}

// Expect sets up expected params for IListRepo.AddToList
func (mmAddToList *mIListRepoMockAddToList) Expect(ctx context.Context, idL int, idD int) *mIListRepoMockAddToList {
	if mmAddToList.mock.funcAddToList != nil {
		mmAddToList.mock.t.Fatalf("IListRepoMock.AddToList mock is already set by Set")
	}

	if mmAddToList.defaultExpectation == nil {
		mmAddToList.defaultExpectation = &IListRepoMockAddToListExpectation{}
	}

	mmAddToList.defaultExpectation.params = &IListRepoMockAddToListParams{ctx, idL, idD}
	for _, e := range mmAddToList.expectations {
		if minimock.Equal(e.params, mmAddToList.defaultExpectation.params) {
			mmAddToList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToList.defaultExpectation.params)
		}
	}

	return mmAddToList
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.AddToList
func (mmAddToList *mIListRepoMockAddToList) Inspect(f func(ctx context.Context, idL int, idD int)) *mIListRepoMockAddToList {
	if mmAddToList.mock.inspectFuncAddToList != nil {
		mmAddToList.mock.t.Fatalf("Inspect function is already set for IListRepoMock.AddToList")
	}

	mmAddToList.mock.inspectFuncAddToList = f

	return mmAddToList
}

// Return sets up results that will be returned by IListRepo.AddToList
func (mmAddToList *mIListRepoMockAddToList) Return(err error) *IListRepoMock {
	if mmAddToList.mock.funcAddToList != nil {
		mmAddToList.mock.t.Fatalf("IListRepoMock.AddToList mock is already set by Set")
	}

	if mmAddToList.defaultExpectation == nil {
		mmAddToList.defaultExpectation = &IListRepoMockAddToListExpectation{mock: mmAddToList.mock}
	}
	mmAddToList.defaultExpectation.results = &IListRepoMockAddToListResults{err}
	return mmAddToList.mock
}

// Set uses given function f to mock the IListRepo.AddToList method
func (mmAddToList *mIListRepoMockAddToList) Set(f func(ctx context.Context, idL int, idD int) (err error)) *IListRepoMock {
	if mmAddToList.defaultExpectation != nil {
		mmAddToList.mock.t.Fatalf("Default expectation is already set for the IListRepo.AddToList method")
	}

	if len(mmAddToList.expectations) > 0 {
		mmAddToList.mock.t.Fatalf("Some expectations are already set for the IListRepo.AddToList method")
	}

	mmAddToList.mock.funcAddToList = f
	return mmAddToList.mock
}

// When sets expectation for the IListRepo.AddToList which will trigger the result defined by the following
// Then helper
func (mmAddToList *mIListRepoMockAddToList) When(ctx context.Context, idL int, idD int) *IListRepoMockAddToListExpectation {
	if mmAddToList.mock.funcAddToList != nil {
		mmAddToList.mock.t.Fatalf("IListRepoMock.AddToList mock is already set by Set")
	}

	expectation := &IListRepoMockAddToListExpectation{
		mock:   mmAddToList.mock,
		params: &IListRepoMockAddToListParams{ctx, idL, idD},
	}
	mmAddToList.expectations = append(mmAddToList.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.AddToList return parameters for the expectation previously defined by the When method
func (e *IListRepoMockAddToListExpectation) Then(err error) *IListRepoMock {
	e.results = &IListRepoMockAddToListResults{err}
	return e.mock
}

// AddToList implements IListRepo
func (mmAddToList *IListRepoMock) AddToList(ctx context.Context, idL int, idD int) (err error) {
	mm_atomic.AddUint64(&mmAddToList.beforeAddToListCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToList.afterAddToListCounter, 1)

	if mmAddToList.inspectFuncAddToList != nil {
		mmAddToList.inspectFuncAddToList(ctx, idL, idD)
	}

	mm_params := &IListRepoMockAddToListParams{ctx, idL, idD}

	// Record call args
	mmAddToList.AddToListMock.mutex.Lock()
	mmAddToList.AddToListMock.callArgs = append(mmAddToList.AddToListMock.callArgs, mm_params)
	mmAddToList.AddToListMock.mutex.Unlock()

	for _, e := range mmAddToList.AddToListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToList.AddToListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToList.AddToListMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToList.AddToListMock.defaultExpectation.params
		mm_got := IListRepoMockAddToListParams{ctx, idL, idD}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToList.t.Errorf("IListRepoMock.AddToList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToList.AddToListMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToList.t.Fatal("No results are set for the IListRepoMock.AddToList")
		}
		return (*mm_results).err
	}
	if mmAddToList.funcAddToList != nil {
		return mmAddToList.funcAddToList(ctx, idL, idD)
	}
	mmAddToList.t.Fatalf("Unexpected call to IListRepoMock.AddToList. %v %v %v", ctx, idL, idD)
	return
}

// AddToListAfterCounter returns a count of finished IListRepoMock.AddToList invocations
func (mmAddToList *IListRepoMock) AddToListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToList.afterAddToListCounter)
}

// AddToListBeforeCounter returns a count of IListRepoMock.AddToList invocations
func (mmAddToList *IListRepoMock) AddToListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToList.beforeAddToListCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.AddToList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToList *mIListRepoMockAddToList) Calls() []*IListRepoMockAddToListParams {
	mmAddToList.mutex.RLock()

	argCopy := make([]*IListRepoMockAddToListParams, len(mmAddToList.callArgs))
	copy(argCopy, mmAddToList.callArgs)

	mmAddToList.mutex.RUnlock()

	return argCopy
}

// MinimockAddToListDone returns true if the count of the AddToList invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockAddToListDone() bool {
	for _, e := range m.AddToListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToList != nil && mm_atomic.LoadUint64(&m.afterAddToListCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToListInspect logs each unmet expectation
func (m *IListRepoMock) MinimockAddToListInspect() {
	for _, e := range m.AddToListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.AddToList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToListCounter) < 1 {
		if m.AddToListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.AddToList")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.AddToList with params: %#v", *m.AddToListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToList != nil && mm_atomic.LoadUint64(&m.afterAddToListCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.AddToList")
	}
}

type mIListRepoMockCreateList struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockCreateListExpectation
	expectations       []*IListRepoMockCreateListExpectation

	callArgs []*IListRepoMockCreateListParams
	mutex    sync.RWMutex
}

// IListRepoMockCreateListExpectation specifies expectation struct of the IListRepo.CreateList
type IListRepoMockCreateListExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockCreateListParams
	results *IListRepoMockCreateListResults
	Counter uint64
}

// IListRepoMockCreateListParams contains parameters of the IListRepo.CreateList
type IListRepoMockCreateListParams struct {
	ctx  context.Context
	list model.List
}

// IListRepoMockCreateListResults contains results of the IListRepo.CreateList
type IListRepoMockCreateListResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IListRepo.CreateList
func (mmCreateList *mIListRepoMockCreateList) Expect(ctx context.Context, list model.List) *mIListRepoMockCreateList {
	if mmCreateList.mock.funcCreateList != nil {
		mmCreateList.mock.t.Fatalf("IListRepoMock.CreateList mock is already set by Set")
	}

	if mmCreateList.defaultExpectation == nil {
		mmCreateList.defaultExpectation = &IListRepoMockCreateListExpectation{}
	}

	mmCreateList.defaultExpectation.params = &IListRepoMockCreateListParams{ctx, list}
	for _, e := range mmCreateList.expectations {
		if minimock.Equal(e.params, mmCreateList.defaultExpectation.params) {
			mmCreateList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateList.defaultExpectation.params)
		}
	}

	return mmCreateList
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.CreateList
func (mmCreateList *mIListRepoMockCreateList) Inspect(f func(ctx context.Context, list model.List)) *mIListRepoMockCreateList {
	if mmCreateList.mock.inspectFuncCreateList != nil {
		mmCreateList.mock.t.Fatalf("Inspect function is already set for IListRepoMock.CreateList")
	}

	mmCreateList.mock.inspectFuncCreateList = f

	return mmCreateList
}

// Return sets up results that will be returned by IListRepo.CreateList
func (mmCreateList *mIListRepoMockCreateList) Return(i1 int, err error) *IListRepoMock {
	if mmCreateList.mock.funcCreateList != nil {
		mmCreateList.mock.t.Fatalf("IListRepoMock.CreateList mock is already set by Set")
	}

	if mmCreateList.defaultExpectation == nil {
		mmCreateList.defaultExpectation = &IListRepoMockCreateListExpectation{mock: mmCreateList.mock}
	}
	mmCreateList.defaultExpectation.results = &IListRepoMockCreateListResults{i1, err}
	return mmCreateList.mock
}

// Set uses given function f to mock the IListRepo.CreateList method
func (mmCreateList *mIListRepoMockCreateList) Set(f func(ctx context.Context, list model.List) (i1 int, err error)) *IListRepoMock {
	if mmCreateList.defaultExpectation != nil {
		mmCreateList.mock.t.Fatalf("Default expectation is already set for the IListRepo.CreateList method")
	}

	if len(mmCreateList.expectations) > 0 {
		mmCreateList.mock.t.Fatalf("Some expectations are already set for the IListRepo.CreateList method")
	}

	mmCreateList.mock.funcCreateList = f
	return mmCreateList.mock
}

// When sets expectation for the IListRepo.CreateList which will trigger the result defined by the following
// Then helper
func (mmCreateList *mIListRepoMockCreateList) When(ctx context.Context, list model.List) *IListRepoMockCreateListExpectation {
	if mmCreateList.mock.funcCreateList != nil {
		mmCreateList.mock.t.Fatalf("IListRepoMock.CreateList mock is already set by Set")
	}

	expectation := &IListRepoMockCreateListExpectation{
		mock:   mmCreateList.mock,
		params: &IListRepoMockCreateListParams{ctx, list},
	}
	mmCreateList.expectations = append(mmCreateList.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.CreateList return parameters for the expectation previously defined by the When method
func (e *IListRepoMockCreateListExpectation) Then(i1 int, err error) *IListRepoMock {
	e.results = &IListRepoMockCreateListResults{i1, err}
	return e.mock
}

// CreateList implements IListRepo
func (mmCreateList *IListRepoMock) CreateList(ctx context.Context, list model.List) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateList.beforeCreateListCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateList.afterCreateListCounter, 1)

	if mmCreateList.inspectFuncCreateList != nil {
		mmCreateList.inspectFuncCreateList(ctx, list)
	}

	mm_params := &IListRepoMockCreateListParams{ctx, list}

	// Record call args
	mmCreateList.CreateListMock.mutex.Lock()
	mmCreateList.CreateListMock.callArgs = append(mmCreateList.CreateListMock.callArgs, mm_params)
	mmCreateList.CreateListMock.mutex.Unlock()

	for _, e := range mmCreateList.CreateListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateList.CreateListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateList.CreateListMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateList.CreateListMock.defaultExpectation.params
		mm_got := IListRepoMockCreateListParams{ctx, list}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateList.t.Errorf("IListRepoMock.CreateList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateList.CreateListMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateList.t.Fatal("No results are set for the IListRepoMock.CreateList")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateList.funcCreateList != nil {
		return mmCreateList.funcCreateList(ctx, list)
	}
	mmCreateList.t.Fatalf("Unexpected call to IListRepoMock.CreateList. %v %v", ctx, list)
	return
}

// CreateListAfterCounter returns a count of finished IListRepoMock.CreateList invocations
func (mmCreateList *IListRepoMock) CreateListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateList.afterCreateListCounter)
}

// CreateListBeforeCounter returns a count of IListRepoMock.CreateList invocations
func (mmCreateList *IListRepoMock) CreateListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateList.beforeCreateListCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.CreateList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateList *mIListRepoMockCreateList) Calls() []*IListRepoMockCreateListParams {
	mmCreateList.mutex.RLock()

	argCopy := make([]*IListRepoMockCreateListParams, len(mmCreateList.callArgs))
	copy(argCopy, mmCreateList.callArgs)

	mmCreateList.mutex.RUnlock()

	return argCopy
}

// MinimockCreateListDone returns true if the count of the CreateList invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockCreateListDone() bool {
	for _, e := range m.CreateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateList != nil && mm_atomic.LoadUint64(&m.afterCreateListCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateListInspect logs each unmet expectation
func (m *IListRepoMock) MinimockCreateListInspect() {
	for _, e := range m.CreateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.CreateList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateListCounter) < 1 {
		if m.CreateListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.CreateList")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.CreateList with params: %#v", *m.CreateListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateList != nil && mm_atomic.LoadUint64(&m.afterCreateListCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.CreateList")
	}
}

type mIListRepoMockDelFromList struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockDelFromListExpectation
	expectations       []*IListRepoMockDelFromListExpectation

	callArgs []*IListRepoMockDelFromListParams
	mutex    sync.RWMutex
}

// IListRepoMockDelFromListExpectation specifies expectation struct of the IListRepo.DelFromList
type IListRepoMockDelFromListExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockDelFromListParams
	results *IListRepoMockDelFromListResults
	Counter uint64
}

// IListRepoMockDelFromListParams contains parameters of the IListRepo.DelFromList
type IListRepoMockDelFromListParams struct {
	ctx context.Context
	idL int
	idD int
}

// IListRepoMockDelFromListResults contains results of the IListRepo.DelFromList
type IListRepoMockDelFromListResults struct {
	err error
}

// Expect sets up expected params for IListRepo.DelFromList
func (mmDelFromList *mIListRepoMockDelFromList) Expect(ctx context.Context, idL int, idD int) *mIListRepoMockDelFromList {
	if mmDelFromList.mock.funcDelFromList != nil {
		mmDelFromList.mock.t.Fatalf("IListRepoMock.DelFromList mock is already set by Set")
	}

	if mmDelFromList.defaultExpectation == nil {
		mmDelFromList.defaultExpectation = &IListRepoMockDelFromListExpectation{}
	}

	mmDelFromList.defaultExpectation.params = &IListRepoMockDelFromListParams{ctx, idL, idD}
	for _, e := range mmDelFromList.expectations {
		if minimock.Equal(e.params, mmDelFromList.defaultExpectation.params) {
			mmDelFromList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelFromList.defaultExpectation.params)
		}
	}

	return mmDelFromList
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.DelFromList
func (mmDelFromList *mIListRepoMockDelFromList) Inspect(f func(ctx context.Context, idL int, idD int)) *mIListRepoMockDelFromList {
	if mmDelFromList.mock.inspectFuncDelFromList != nil {
		mmDelFromList.mock.t.Fatalf("Inspect function is already set for IListRepoMock.DelFromList")
	}

	mmDelFromList.mock.inspectFuncDelFromList = f

	return mmDelFromList
}

// Return sets up results that will be returned by IListRepo.DelFromList
func (mmDelFromList *mIListRepoMockDelFromList) Return(err error) *IListRepoMock {
	if mmDelFromList.mock.funcDelFromList != nil {
		mmDelFromList.mock.t.Fatalf("IListRepoMock.DelFromList mock is already set by Set")
	}

	if mmDelFromList.defaultExpectation == nil {
		mmDelFromList.defaultExpectation = &IListRepoMockDelFromListExpectation{mock: mmDelFromList.mock}
	}
	mmDelFromList.defaultExpectation.results = &IListRepoMockDelFromListResults{err}
	return mmDelFromList.mock
}

// Set uses given function f to mock the IListRepo.DelFromList method
func (mmDelFromList *mIListRepoMockDelFromList) Set(f func(ctx context.Context, idL int, idD int) (err error)) *IListRepoMock {
	if mmDelFromList.defaultExpectation != nil {
		mmDelFromList.mock.t.Fatalf("Default expectation is already set for the IListRepo.DelFromList method")
	}

	if len(mmDelFromList.expectations) > 0 {
		mmDelFromList.mock.t.Fatalf("Some expectations are already set for the IListRepo.DelFromList method")
	}

	mmDelFromList.mock.funcDelFromList = f
	return mmDelFromList.mock
}

// When sets expectation for the IListRepo.DelFromList which will trigger the result defined by the following
// Then helper
func (mmDelFromList *mIListRepoMockDelFromList) When(ctx context.Context, idL int, idD int) *IListRepoMockDelFromListExpectation {
	if mmDelFromList.mock.funcDelFromList != nil {
		mmDelFromList.mock.t.Fatalf("IListRepoMock.DelFromList mock is already set by Set")
	}

	expectation := &IListRepoMockDelFromListExpectation{
		mock:   mmDelFromList.mock,
		params: &IListRepoMockDelFromListParams{ctx, idL, idD},
	}
	mmDelFromList.expectations = append(mmDelFromList.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.DelFromList return parameters for the expectation previously defined by the When method
func (e *IListRepoMockDelFromListExpectation) Then(err error) *IListRepoMock {
	e.results = &IListRepoMockDelFromListResults{err}
	return e.mock
}

// DelFromList implements IListRepo
func (mmDelFromList *IListRepoMock) DelFromList(ctx context.Context, idL int, idD int) (err error) {
	mm_atomic.AddUint64(&mmDelFromList.beforeDelFromListCounter, 1)
	defer mm_atomic.AddUint64(&mmDelFromList.afterDelFromListCounter, 1)

	if mmDelFromList.inspectFuncDelFromList != nil {
		mmDelFromList.inspectFuncDelFromList(ctx, idL, idD)
	}

	mm_params := &IListRepoMockDelFromListParams{ctx, idL, idD}

	// Record call args
	mmDelFromList.DelFromListMock.mutex.Lock()
	mmDelFromList.DelFromListMock.callArgs = append(mmDelFromList.DelFromListMock.callArgs, mm_params)
	mmDelFromList.DelFromListMock.mutex.Unlock()

	for _, e := range mmDelFromList.DelFromListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelFromList.DelFromListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelFromList.DelFromListMock.defaultExpectation.Counter, 1)
		mm_want := mmDelFromList.DelFromListMock.defaultExpectation.params
		mm_got := IListRepoMockDelFromListParams{ctx, idL, idD}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelFromList.t.Errorf("IListRepoMock.DelFromList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelFromList.DelFromListMock.defaultExpectation.results
		if mm_results == nil {
			mmDelFromList.t.Fatal("No results are set for the IListRepoMock.DelFromList")
		}
		return (*mm_results).err
	}
	if mmDelFromList.funcDelFromList != nil {
		return mmDelFromList.funcDelFromList(ctx, idL, idD)
	}
	mmDelFromList.t.Fatalf("Unexpected call to IListRepoMock.DelFromList. %v %v %v", ctx, idL, idD)
	return
}

// DelFromListAfterCounter returns a count of finished IListRepoMock.DelFromList invocations
func (mmDelFromList *IListRepoMock) DelFromListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelFromList.afterDelFromListCounter)
}

// DelFromListBeforeCounter returns a count of IListRepoMock.DelFromList invocations
func (mmDelFromList *IListRepoMock) DelFromListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelFromList.beforeDelFromListCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.DelFromList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelFromList *mIListRepoMockDelFromList) Calls() []*IListRepoMockDelFromListParams {
	mmDelFromList.mutex.RLock()

	argCopy := make([]*IListRepoMockDelFromListParams, len(mmDelFromList.callArgs))
	copy(argCopy, mmDelFromList.callArgs)

	mmDelFromList.mutex.RUnlock()

	return argCopy
}

// MinimockDelFromListDone returns true if the count of the DelFromList invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockDelFromListDone() bool {
	for _, e := range m.DelFromListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelFromListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelFromListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelFromList != nil && mm_atomic.LoadUint64(&m.afterDelFromListCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelFromListInspect logs each unmet expectation
func (m *IListRepoMock) MinimockDelFromListInspect() {
	for _, e := range m.DelFromListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.DelFromList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelFromListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelFromListCounter) < 1 {
		if m.DelFromListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.DelFromList")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.DelFromList with params: %#v", *m.DelFromListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelFromList != nil && mm_atomic.LoadUint64(&m.afterDelFromListCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.DelFromList")
	}
}

type mIListRepoMockDelList struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockDelListExpectation
	expectations       []*IListRepoMockDelListExpectation

	callArgs []*IListRepoMockDelListParams
	mutex    sync.RWMutex
}

// IListRepoMockDelListExpectation specifies expectation struct of the IListRepo.DelList
type IListRepoMockDelListExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockDelListParams
	results *IListRepoMockDelListResults
	Counter uint64
}

// IListRepoMockDelListParams contains parameters of the IListRepo.DelList
type IListRepoMockDelListParams struct {
	ctx context.Context
	id  int
}

// IListRepoMockDelListResults contains results of the IListRepo.DelList
type IListRepoMockDelListResults struct {
	err error
}

// Expect sets up expected params for IListRepo.DelList
func (mmDelList *mIListRepoMockDelList) Expect(ctx context.Context, id int) *mIListRepoMockDelList {
	if mmDelList.mock.funcDelList != nil {
		mmDelList.mock.t.Fatalf("IListRepoMock.DelList mock is already set by Set")
	}

	if mmDelList.defaultExpectation == nil {
		mmDelList.defaultExpectation = &IListRepoMockDelListExpectation{}
	}

	mmDelList.defaultExpectation.params = &IListRepoMockDelListParams{ctx, id}
	for _, e := range mmDelList.expectations {
		if minimock.Equal(e.params, mmDelList.defaultExpectation.params) {
			mmDelList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelList.defaultExpectation.params)
		}
	}

	return mmDelList
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.DelList
func (mmDelList *mIListRepoMockDelList) Inspect(f func(ctx context.Context, id int)) *mIListRepoMockDelList {
	if mmDelList.mock.inspectFuncDelList != nil {
		mmDelList.mock.t.Fatalf("Inspect function is already set for IListRepoMock.DelList")
	}

	mmDelList.mock.inspectFuncDelList = f

	return mmDelList
}

// Return sets up results that will be returned by IListRepo.DelList
func (mmDelList *mIListRepoMockDelList) Return(err error) *IListRepoMock {
	if mmDelList.mock.funcDelList != nil {
		mmDelList.mock.t.Fatalf("IListRepoMock.DelList mock is already set by Set")
	}

	if mmDelList.defaultExpectation == nil {
		mmDelList.defaultExpectation = &IListRepoMockDelListExpectation{mock: mmDelList.mock}
	}
	mmDelList.defaultExpectation.results = &IListRepoMockDelListResults{err}
	return mmDelList.mock
}

// Set uses given function f to mock the IListRepo.DelList method
func (mmDelList *mIListRepoMockDelList) Set(f func(ctx context.Context, id int) (err error)) *IListRepoMock {
	if mmDelList.defaultExpectation != nil {
		mmDelList.mock.t.Fatalf("Default expectation is already set for the IListRepo.DelList method")
	}

	if len(mmDelList.expectations) > 0 {
		mmDelList.mock.t.Fatalf("Some expectations are already set for the IListRepo.DelList method")
	}

	mmDelList.mock.funcDelList = f
	return mmDelList.mock
}

// When sets expectation for the IListRepo.DelList which will trigger the result defined by the following
// Then helper
func (mmDelList *mIListRepoMockDelList) When(ctx context.Context, id int) *IListRepoMockDelListExpectation {
	if mmDelList.mock.funcDelList != nil {
		mmDelList.mock.t.Fatalf("IListRepoMock.DelList mock is already set by Set")
	}

	expectation := &IListRepoMockDelListExpectation{
		mock:   mmDelList.mock,
		params: &IListRepoMockDelListParams{ctx, id},
	}
	mmDelList.expectations = append(mmDelList.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.DelList return parameters for the expectation previously defined by the When method
func (e *IListRepoMockDelListExpectation) Then(err error) *IListRepoMock {
	e.results = &IListRepoMockDelListResults{err}
	return e.mock
}

// DelList implements IListRepo
func (mmDelList *IListRepoMock) DelList(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDelList.beforeDelListCounter, 1)
	defer mm_atomic.AddUint64(&mmDelList.afterDelListCounter, 1)

	if mmDelList.inspectFuncDelList != nil {
		mmDelList.inspectFuncDelList(ctx, id)
	}

	mm_params := &IListRepoMockDelListParams{ctx, id}

	// Record call args
	mmDelList.DelListMock.mutex.Lock()
	mmDelList.DelListMock.callArgs = append(mmDelList.DelListMock.callArgs, mm_params)
	mmDelList.DelListMock.mutex.Unlock()

	for _, e := range mmDelList.DelListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelList.DelListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelList.DelListMock.defaultExpectation.Counter, 1)
		mm_want := mmDelList.DelListMock.defaultExpectation.params
		mm_got := IListRepoMockDelListParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelList.t.Errorf("IListRepoMock.DelList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelList.DelListMock.defaultExpectation.results
		if mm_results == nil {
			mmDelList.t.Fatal("No results are set for the IListRepoMock.DelList")
		}
		return (*mm_results).err
	}
	if mmDelList.funcDelList != nil {
		return mmDelList.funcDelList(ctx, id)
	}
	mmDelList.t.Fatalf("Unexpected call to IListRepoMock.DelList. %v %v", ctx, id)
	return
}

// DelListAfterCounter returns a count of finished IListRepoMock.DelList invocations
func (mmDelList *IListRepoMock) DelListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelList.afterDelListCounter)
}

// DelListBeforeCounter returns a count of IListRepoMock.DelList invocations
func (mmDelList *IListRepoMock) DelListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelList.beforeDelListCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.DelList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelList *mIListRepoMockDelList) Calls() []*IListRepoMockDelListParams {
	mmDelList.mutex.RLock()

	argCopy := make([]*IListRepoMockDelListParams, len(mmDelList.callArgs))
	copy(argCopy, mmDelList.callArgs)

	mmDelList.mutex.RUnlock()

	return argCopy
}

// MinimockDelListDone returns true if the count of the DelList invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockDelListDone() bool {
	for _, e := range m.DelListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelList != nil && mm_atomic.LoadUint64(&m.afterDelListCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelListInspect logs each unmet expectation
func (m *IListRepoMock) MinimockDelListInspect() {
	for _, e := range m.DelListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.DelList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelListCounter) < 1 {
		if m.DelListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.DelList")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.DelList with params: %#v", *m.DelListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelList != nil && mm_atomic.LoadUint64(&m.afterDelListCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.DelList")
	}
}

type mIListRepoMockGetFavList struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockGetFavListExpectation
	expectations       []*IListRepoMockGetFavListExpectation

	callArgs []*IListRepoMockGetFavListParams
	mutex    sync.RWMutex
}

// IListRepoMockGetFavListExpectation specifies expectation struct of the IListRepo.GetFavList
type IListRepoMockGetFavListExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockGetFavListParams
	results *IListRepoMockGetFavListResults
	Counter uint64
}

// IListRepoMockGetFavListParams contains parameters of the IListRepo.GetFavList
type IListRepoMockGetFavListParams struct {
	ctx      context.Context
	username string
}

// IListRepoMockGetFavListResults contains results of the IListRepo.GetFavList
type IListRepoMockGetFavListResults struct {
	la1 []model.List
	err error
}

// Expect sets up expected params for IListRepo.GetFavList
func (mmGetFavList *mIListRepoMockGetFavList) Expect(ctx context.Context, username string) *mIListRepoMockGetFavList {
	if mmGetFavList.mock.funcGetFavList != nil {
		mmGetFavList.mock.t.Fatalf("IListRepoMock.GetFavList mock is already set by Set")
	}

	if mmGetFavList.defaultExpectation == nil {
		mmGetFavList.defaultExpectation = &IListRepoMockGetFavListExpectation{}
	}

	mmGetFavList.defaultExpectation.params = &IListRepoMockGetFavListParams{ctx, username}
	for _, e := range mmGetFavList.expectations {
		if minimock.Equal(e.params, mmGetFavList.defaultExpectation.params) {
			mmGetFavList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFavList.defaultExpectation.params)
		}
	}

	return mmGetFavList
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.GetFavList
func (mmGetFavList *mIListRepoMockGetFavList) Inspect(f func(ctx context.Context, username string)) *mIListRepoMockGetFavList {
	if mmGetFavList.mock.inspectFuncGetFavList != nil {
		mmGetFavList.mock.t.Fatalf("Inspect function is already set for IListRepoMock.GetFavList")
	}

	mmGetFavList.mock.inspectFuncGetFavList = f

	return mmGetFavList
}

// Return sets up results that will be returned by IListRepo.GetFavList
func (mmGetFavList *mIListRepoMockGetFavList) Return(la1 []model.List, err error) *IListRepoMock {
	if mmGetFavList.mock.funcGetFavList != nil {
		mmGetFavList.mock.t.Fatalf("IListRepoMock.GetFavList mock is already set by Set")
	}

	if mmGetFavList.defaultExpectation == nil {
		mmGetFavList.defaultExpectation = &IListRepoMockGetFavListExpectation{mock: mmGetFavList.mock}
	}
	mmGetFavList.defaultExpectation.results = &IListRepoMockGetFavListResults{la1, err}
	return mmGetFavList.mock
}

// Set uses given function f to mock the IListRepo.GetFavList method
func (mmGetFavList *mIListRepoMockGetFavList) Set(f func(ctx context.Context, username string) (la1 []model.List, err error)) *IListRepoMock {
	if mmGetFavList.defaultExpectation != nil {
		mmGetFavList.mock.t.Fatalf("Default expectation is already set for the IListRepo.GetFavList method")
	}

	if len(mmGetFavList.expectations) > 0 {
		mmGetFavList.mock.t.Fatalf("Some expectations are already set for the IListRepo.GetFavList method")
	}

	mmGetFavList.mock.funcGetFavList = f
	return mmGetFavList.mock
}

// When sets expectation for the IListRepo.GetFavList which will trigger the result defined by the following
// Then helper
func (mmGetFavList *mIListRepoMockGetFavList) When(ctx context.Context, username string) *IListRepoMockGetFavListExpectation {
	if mmGetFavList.mock.funcGetFavList != nil {
		mmGetFavList.mock.t.Fatalf("IListRepoMock.GetFavList mock is already set by Set")
	}

	expectation := &IListRepoMockGetFavListExpectation{
		mock:   mmGetFavList.mock,
		params: &IListRepoMockGetFavListParams{ctx, username},
	}
	mmGetFavList.expectations = append(mmGetFavList.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.GetFavList return parameters for the expectation previously defined by the When method
func (e *IListRepoMockGetFavListExpectation) Then(la1 []model.List, err error) *IListRepoMock {
	e.results = &IListRepoMockGetFavListResults{la1, err}
	return e.mock
}

// GetFavList implements IListRepo
func (mmGetFavList *IListRepoMock) GetFavList(ctx context.Context, username string) (la1 []model.List, err error) {
	mm_atomic.AddUint64(&mmGetFavList.beforeGetFavListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFavList.afterGetFavListCounter, 1)

	if mmGetFavList.inspectFuncGetFavList != nil {
		mmGetFavList.inspectFuncGetFavList(ctx, username)
	}

	mm_params := &IListRepoMockGetFavListParams{ctx, username}

	// Record call args
	mmGetFavList.GetFavListMock.mutex.Lock()
	mmGetFavList.GetFavListMock.callArgs = append(mmGetFavList.GetFavListMock.callArgs, mm_params)
	mmGetFavList.GetFavListMock.mutex.Unlock()

	for _, e := range mmGetFavList.GetFavListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetFavList.GetFavListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFavList.GetFavListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFavList.GetFavListMock.defaultExpectation.params
		mm_got := IListRepoMockGetFavListParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFavList.t.Errorf("IListRepoMock.GetFavList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFavList.GetFavListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFavList.t.Fatal("No results are set for the IListRepoMock.GetFavList")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetFavList.funcGetFavList != nil {
		return mmGetFavList.funcGetFavList(ctx, username)
	}
	mmGetFavList.t.Fatalf("Unexpected call to IListRepoMock.GetFavList. %v %v", ctx, username)
	return
}

// GetFavListAfterCounter returns a count of finished IListRepoMock.GetFavList invocations
func (mmGetFavList *IListRepoMock) GetFavListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavList.afterGetFavListCounter)
}

// GetFavListBeforeCounter returns a count of IListRepoMock.GetFavList invocations
func (mmGetFavList *IListRepoMock) GetFavListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFavList.beforeGetFavListCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.GetFavList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFavList *mIListRepoMockGetFavList) Calls() []*IListRepoMockGetFavListParams {
	mmGetFavList.mutex.RLock()

	argCopy := make([]*IListRepoMockGetFavListParams, len(mmGetFavList.callArgs))
	copy(argCopy, mmGetFavList.callArgs)

	mmGetFavList.mutex.RUnlock()

	return argCopy
}

// MinimockGetFavListDone returns true if the count of the GetFavList invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockGetFavListDone() bool {
	for _, e := range m.GetFavListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavList != nil && mm_atomic.LoadUint64(&m.afterGetFavListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFavListInspect logs each unmet expectation
func (m *IListRepoMock) MinimockGetFavListInspect() {
	for _, e := range m.GetFavListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.GetFavList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFavListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFavListCounter) < 1 {
		if m.GetFavListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.GetFavList")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.GetFavList with params: %#v", *m.GetFavListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFavList != nil && mm_atomic.LoadUint64(&m.afterGetFavListCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.GetFavList")
	}
}

type mIListRepoMockGetListId struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockGetListIdExpectation
	expectations       []*IListRepoMockGetListIdExpectation

	callArgs []*IListRepoMockGetListIdParams
	mutex    sync.RWMutex
}

// IListRepoMockGetListIdExpectation specifies expectation struct of the IListRepo.GetListId
type IListRepoMockGetListIdExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockGetListIdParams
	results *IListRepoMockGetListIdResults
	Counter uint64
}

// IListRepoMockGetListIdParams contains parameters of the IListRepo.GetListId
type IListRepoMockGetListIdParams struct {
	ctx context.Context
	id  int
}

// IListRepoMockGetListIdResults contains results of the IListRepo.GetListId
type IListRepoMockGetListIdResults struct {
	lp1 *model.List
	err error
}

// Expect sets up expected params for IListRepo.GetListId
func (mmGetListId *mIListRepoMockGetListId) Expect(ctx context.Context, id int) *mIListRepoMockGetListId {
	if mmGetListId.mock.funcGetListId != nil {
		mmGetListId.mock.t.Fatalf("IListRepoMock.GetListId mock is already set by Set")
	}

	if mmGetListId.defaultExpectation == nil {
		mmGetListId.defaultExpectation = &IListRepoMockGetListIdExpectation{}
	}

	mmGetListId.defaultExpectation.params = &IListRepoMockGetListIdParams{ctx, id}
	for _, e := range mmGetListId.expectations {
		if minimock.Equal(e.params, mmGetListId.defaultExpectation.params) {
			mmGetListId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListId.defaultExpectation.params)
		}
	}

	return mmGetListId
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.GetListId
func (mmGetListId *mIListRepoMockGetListId) Inspect(f func(ctx context.Context, id int)) *mIListRepoMockGetListId {
	if mmGetListId.mock.inspectFuncGetListId != nil {
		mmGetListId.mock.t.Fatalf("Inspect function is already set for IListRepoMock.GetListId")
	}

	mmGetListId.mock.inspectFuncGetListId = f

	return mmGetListId
}

// Return sets up results that will be returned by IListRepo.GetListId
func (mmGetListId *mIListRepoMockGetListId) Return(lp1 *model.List, err error) *IListRepoMock {
	if mmGetListId.mock.funcGetListId != nil {
		mmGetListId.mock.t.Fatalf("IListRepoMock.GetListId mock is already set by Set")
	}

	if mmGetListId.defaultExpectation == nil {
		mmGetListId.defaultExpectation = &IListRepoMockGetListIdExpectation{mock: mmGetListId.mock}
	}
	mmGetListId.defaultExpectation.results = &IListRepoMockGetListIdResults{lp1, err}
	return mmGetListId.mock
}

// Set uses given function f to mock the IListRepo.GetListId method
func (mmGetListId *mIListRepoMockGetListId) Set(f func(ctx context.Context, id int) (lp1 *model.List, err error)) *IListRepoMock {
	if mmGetListId.defaultExpectation != nil {
		mmGetListId.mock.t.Fatalf("Default expectation is already set for the IListRepo.GetListId method")
	}

	if len(mmGetListId.expectations) > 0 {
		mmGetListId.mock.t.Fatalf("Some expectations are already set for the IListRepo.GetListId method")
	}

	mmGetListId.mock.funcGetListId = f
	return mmGetListId.mock
}

// When sets expectation for the IListRepo.GetListId which will trigger the result defined by the following
// Then helper
func (mmGetListId *mIListRepoMockGetListId) When(ctx context.Context, id int) *IListRepoMockGetListIdExpectation {
	if mmGetListId.mock.funcGetListId != nil {
		mmGetListId.mock.t.Fatalf("IListRepoMock.GetListId mock is already set by Set")
	}

	expectation := &IListRepoMockGetListIdExpectation{
		mock:   mmGetListId.mock,
		params: &IListRepoMockGetListIdParams{ctx, id},
	}
	mmGetListId.expectations = append(mmGetListId.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.GetListId return parameters for the expectation previously defined by the When method
func (e *IListRepoMockGetListIdExpectation) Then(lp1 *model.List, err error) *IListRepoMock {
	e.results = &IListRepoMockGetListIdResults{lp1, err}
	return e.mock
}

// GetListId implements IListRepo
func (mmGetListId *IListRepoMock) GetListId(ctx context.Context, id int) (lp1 *model.List, err error) {
	mm_atomic.AddUint64(&mmGetListId.beforeGetListIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListId.afterGetListIdCounter, 1)

	if mmGetListId.inspectFuncGetListId != nil {
		mmGetListId.inspectFuncGetListId(ctx, id)
	}

	mm_params := &IListRepoMockGetListIdParams{ctx, id}

	// Record call args
	mmGetListId.GetListIdMock.mutex.Lock()
	mmGetListId.GetListIdMock.callArgs = append(mmGetListId.GetListIdMock.callArgs, mm_params)
	mmGetListId.GetListIdMock.mutex.Unlock()

	for _, e := range mmGetListId.GetListIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetListId.GetListIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListId.GetListIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListId.GetListIdMock.defaultExpectation.params
		mm_got := IListRepoMockGetListIdParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListId.t.Errorf("IListRepoMock.GetListId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListId.GetListIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListId.t.Fatal("No results are set for the IListRepoMock.GetListId")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetListId.funcGetListId != nil {
		return mmGetListId.funcGetListId(ctx, id)
	}
	mmGetListId.t.Fatalf("Unexpected call to IListRepoMock.GetListId. %v %v", ctx, id)
	return
}

// GetListIdAfterCounter returns a count of finished IListRepoMock.GetListId invocations
func (mmGetListId *IListRepoMock) GetListIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListId.afterGetListIdCounter)
}

// GetListIdBeforeCounter returns a count of IListRepoMock.GetListId invocations
func (mmGetListId *IListRepoMock) GetListIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListId.beforeGetListIdCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.GetListId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListId *mIListRepoMockGetListId) Calls() []*IListRepoMockGetListIdParams {
	mmGetListId.mutex.RLock()

	argCopy := make([]*IListRepoMockGetListIdParams, len(mmGetListId.callArgs))
	copy(argCopy, mmGetListId.callArgs)

	mmGetListId.mutex.RUnlock()

	return argCopy
}

// MinimockGetListIdDone returns true if the count of the GetListId invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockGetListIdDone() bool {
	for _, e := range m.GetListIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListId != nil && mm_atomic.LoadUint64(&m.afterGetListIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListIdInspect logs each unmet expectation
func (m *IListRepoMock) MinimockGetListIdInspect() {
	for _, e := range m.GetListIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.GetListId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListIdCounter) < 1 {
		if m.GetListIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.GetListId")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.GetListId with params: %#v", *m.GetListIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListId != nil && mm_atomic.LoadUint64(&m.afterGetListIdCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.GetListId")
	}
}

type mIListRepoMockGetPublicLists struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockGetPublicListsExpectation
	expectations       []*IListRepoMockGetPublicListsExpectation

	callArgs []*IListRepoMockGetPublicListsParams
	mutex    sync.RWMutex
}

// IListRepoMockGetPublicListsExpectation specifies expectation struct of the IListRepo.GetPublicLists
type IListRepoMockGetPublicListsExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockGetPublicListsParams
	results *IListRepoMockGetPublicListsResults
	Counter uint64
}

// IListRepoMockGetPublicListsParams contains parameters of the IListRepo.GetPublicLists
type IListRepoMockGetPublicListsParams struct {
	ctx context.Context
}

// IListRepoMockGetPublicListsResults contains results of the IListRepo.GetPublicLists
type IListRepoMockGetPublicListsResults struct {
	la1 []model.List
	err error
}

// Expect sets up expected params for IListRepo.GetPublicLists
func (mmGetPublicLists *mIListRepoMockGetPublicLists) Expect(ctx context.Context) *mIListRepoMockGetPublicLists {
	if mmGetPublicLists.mock.funcGetPublicLists != nil {
		mmGetPublicLists.mock.t.Fatalf("IListRepoMock.GetPublicLists mock is already set by Set")
	}

	if mmGetPublicLists.defaultExpectation == nil {
		mmGetPublicLists.defaultExpectation = &IListRepoMockGetPublicListsExpectation{}
	}

	mmGetPublicLists.defaultExpectation.params = &IListRepoMockGetPublicListsParams{ctx}
	for _, e := range mmGetPublicLists.expectations {
		if minimock.Equal(e.params, mmGetPublicLists.defaultExpectation.params) {
			mmGetPublicLists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublicLists.defaultExpectation.params)
		}
	}

	return mmGetPublicLists
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.GetPublicLists
func (mmGetPublicLists *mIListRepoMockGetPublicLists) Inspect(f func(ctx context.Context)) *mIListRepoMockGetPublicLists {
	if mmGetPublicLists.mock.inspectFuncGetPublicLists != nil {
		mmGetPublicLists.mock.t.Fatalf("Inspect function is already set for IListRepoMock.GetPublicLists")
	}

	mmGetPublicLists.mock.inspectFuncGetPublicLists = f

	return mmGetPublicLists
}

// Return sets up results that will be returned by IListRepo.GetPublicLists
func (mmGetPublicLists *mIListRepoMockGetPublicLists) Return(la1 []model.List, err error) *IListRepoMock {
	if mmGetPublicLists.mock.funcGetPublicLists != nil {
		mmGetPublicLists.mock.t.Fatalf("IListRepoMock.GetPublicLists mock is already set by Set")
	}

	if mmGetPublicLists.defaultExpectation == nil {
		mmGetPublicLists.defaultExpectation = &IListRepoMockGetPublicListsExpectation{mock: mmGetPublicLists.mock}
	}
	mmGetPublicLists.defaultExpectation.results = &IListRepoMockGetPublicListsResults{la1, err}
	return mmGetPublicLists.mock
}

// Set uses given function f to mock the IListRepo.GetPublicLists method
func (mmGetPublicLists *mIListRepoMockGetPublicLists) Set(f func(ctx context.Context) (la1 []model.List, err error)) *IListRepoMock {
	if mmGetPublicLists.defaultExpectation != nil {
		mmGetPublicLists.mock.t.Fatalf("Default expectation is already set for the IListRepo.GetPublicLists method")
	}

	if len(mmGetPublicLists.expectations) > 0 {
		mmGetPublicLists.mock.t.Fatalf("Some expectations are already set for the IListRepo.GetPublicLists method")
	}

	mmGetPublicLists.mock.funcGetPublicLists = f
	return mmGetPublicLists.mock
}

// When sets expectation for the IListRepo.GetPublicLists which will trigger the result defined by the following
// Then helper
func (mmGetPublicLists *mIListRepoMockGetPublicLists) When(ctx context.Context) *IListRepoMockGetPublicListsExpectation {
	if mmGetPublicLists.mock.funcGetPublicLists != nil {
		mmGetPublicLists.mock.t.Fatalf("IListRepoMock.GetPublicLists mock is already set by Set")
	}

	expectation := &IListRepoMockGetPublicListsExpectation{
		mock:   mmGetPublicLists.mock,
		params: &IListRepoMockGetPublicListsParams{ctx},
	}
	mmGetPublicLists.expectations = append(mmGetPublicLists.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.GetPublicLists return parameters for the expectation previously defined by the When method
func (e *IListRepoMockGetPublicListsExpectation) Then(la1 []model.List, err error) *IListRepoMock {
	e.results = &IListRepoMockGetPublicListsResults{la1, err}
	return e.mock
}

// GetPublicLists implements IListRepo
func (mmGetPublicLists *IListRepoMock) GetPublicLists(ctx context.Context) (la1 []model.List, err error) {
	mm_atomic.AddUint64(&mmGetPublicLists.beforeGetPublicListsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublicLists.afterGetPublicListsCounter, 1)

	if mmGetPublicLists.inspectFuncGetPublicLists != nil {
		mmGetPublicLists.inspectFuncGetPublicLists(ctx)
	}

	mm_params := &IListRepoMockGetPublicListsParams{ctx}

	// Record call args
	mmGetPublicLists.GetPublicListsMock.mutex.Lock()
	mmGetPublicLists.GetPublicListsMock.callArgs = append(mmGetPublicLists.GetPublicListsMock.callArgs, mm_params)
	mmGetPublicLists.GetPublicListsMock.mutex.Unlock()

	for _, e := range mmGetPublicLists.GetPublicListsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetPublicLists.GetPublicListsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublicLists.GetPublicListsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublicLists.GetPublicListsMock.defaultExpectation.params
		mm_got := IListRepoMockGetPublicListsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublicLists.t.Errorf("IListRepoMock.GetPublicLists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublicLists.GetPublicListsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublicLists.t.Fatal("No results are set for the IListRepoMock.GetPublicLists")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetPublicLists.funcGetPublicLists != nil {
		return mmGetPublicLists.funcGetPublicLists(ctx)
	}
	mmGetPublicLists.t.Fatalf("Unexpected call to IListRepoMock.GetPublicLists. %v", ctx)
	return
}

// GetPublicListsAfterCounter returns a count of finished IListRepoMock.GetPublicLists invocations
func (mmGetPublicLists *IListRepoMock) GetPublicListsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicLists.afterGetPublicListsCounter)
}

// GetPublicListsBeforeCounter returns a count of IListRepoMock.GetPublicLists invocations
func (mmGetPublicLists *IListRepoMock) GetPublicListsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicLists.beforeGetPublicListsCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.GetPublicLists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublicLists *mIListRepoMockGetPublicLists) Calls() []*IListRepoMockGetPublicListsParams {
	mmGetPublicLists.mutex.RLock()

	argCopy := make([]*IListRepoMockGetPublicListsParams, len(mmGetPublicLists.callArgs))
	copy(argCopy, mmGetPublicLists.callArgs)

	mmGetPublicLists.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublicListsDone returns true if the count of the GetPublicLists invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockGetPublicListsDone() bool {
	for _, e := range m.GetPublicListsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicListsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicListsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicLists != nil && mm_atomic.LoadUint64(&m.afterGetPublicListsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublicListsInspect logs each unmet expectation
func (m *IListRepoMock) MinimockGetPublicListsInspect() {
	for _, e := range m.GetPublicListsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.GetPublicLists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicListsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicListsCounter) < 1 {
		if m.GetPublicListsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.GetPublicLists")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.GetPublicLists with params: %#v", *m.GetPublicListsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicLists != nil && mm_atomic.LoadUint64(&m.afterGetPublicListsCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.GetPublicLists")
	}
}

type mIListRepoMockGetUserLists struct {
	mock               *IListRepoMock
	defaultExpectation *IListRepoMockGetUserListsExpectation
	expectations       []*IListRepoMockGetUserListsExpectation

	callArgs []*IListRepoMockGetUserListsParams
	mutex    sync.RWMutex
}

// IListRepoMockGetUserListsExpectation specifies expectation struct of the IListRepo.GetUserLists
type IListRepoMockGetUserListsExpectation struct {
	mock    *IListRepoMock
	params  *IListRepoMockGetUserListsParams
	results *IListRepoMockGetUserListsResults
	Counter uint64
}

// IListRepoMockGetUserListsParams contains parameters of the IListRepo.GetUserLists
type IListRepoMockGetUserListsParams struct {
	ctx      context.Context
	username string
}

// IListRepoMockGetUserListsResults contains results of the IListRepo.GetUserLists
type IListRepoMockGetUserListsResults struct {
	la1 []model.List
	err error
}

// Expect sets up expected params for IListRepo.GetUserLists
func (mmGetUserLists *mIListRepoMockGetUserLists) Expect(ctx context.Context, username string) *mIListRepoMockGetUserLists {
	if mmGetUserLists.mock.funcGetUserLists != nil {
		mmGetUserLists.mock.t.Fatalf("IListRepoMock.GetUserLists mock is already set by Set")
	}

	if mmGetUserLists.defaultExpectation == nil {
		mmGetUserLists.defaultExpectation = &IListRepoMockGetUserListsExpectation{}
	}

	mmGetUserLists.defaultExpectation.params = &IListRepoMockGetUserListsParams{ctx, username}
	for _, e := range mmGetUserLists.expectations {
		if minimock.Equal(e.params, mmGetUserLists.defaultExpectation.params) {
			mmGetUserLists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserLists.defaultExpectation.params)
		}
	}

	return mmGetUserLists
}

// Inspect accepts an inspector function that has same arguments as the IListRepo.GetUserLists
func (mmGetUserLists *mIListRepoMockGetUserLists) Inspect(f func(ctx context.Context, username string)) *mIListRepoMockGetUserLists {
	if mmGetUserLists.mock.inspectFuncGetUserLists != nil {
		mmGetUserLists.mock.t.Fatalf("Inspect function is already set for IListRepoMock.GetUserLists")
	}

	mmGetUserLists.mock.inspectFuncGetUserLists = f

	return mmGetUserLists
}

// Return sets up results that will be returned by IListRepo.GetUserLists
func (mmGetUserLists *mIListRepoMockGetUserLists) Return(la1 []model.List, err error) *IListRepoMock {
	if mmGetUserLists.mock.funcGetUserLists != nil {
		mmGetUserLists.mock.t.Fatalf("IListRepoMock.GetUserLists mock is already set by Set")
	}

	if mmGetUserLists.defaultExpectation == nil {
		mmGetUserLists.defaultExpectation = &IListRepoMockGetUserListsExpectation{mock: mmGetUserLists.mock}
	}
	mmGetUserLists.defaultExpectation.results = &IListRepoMockGetUserListsResults{la1, err}
	return mmGetUserLists.mock
}

// Set uses given function f to mock the IListRepo.GetUserLists method
func (mmGetUserLists *mIListRepoMockGetUserLists) Set(f func(ctx context.Context, username string) (la1 []model.List, err error)) *IListRepoMock {
	if mmGetUserLists.defaultExpectation != nil {
		mmGetUserLists.mock.t.Fatalf("Default expectation is already set for the IListRepo.GetUserLists method")
	}

	if len(mmGetUserLists.expectations) > 0 {
		mmGetUserLists.mock.t.Fatalf("Some expectations are already set for the IListRepo.GetUserLists method")
	}

	mmGetUserLists.mock.funcGetUserLists = f
	return mmGetUserLists.mock
}

// When sets expectation for the IListRepo.GetUserLists which will trigger the result defined by the following
// Then helper
func (mmGetUserLists *mIListRepoMockGetUserLists) When(ctx context.Context, username string) *IListRepoMockGetUserListsExpectation {
	if mmGetUserLists.mock.funcGetUserLists != nil {
		mmGetUserLists.mock.t.Fatalf("IListRepoMock.GetUserLists mock is already set by Set")
	}

	expectation := &IListRepoMockGetUserListsExpectation{
		mock:   mmGetUserLists.mock,
		params: &IListRepoMockGetUserListsParams{ctx, username},
	}
	mmGetUserLists.expectations = append(mmGetUserLists.expectations, expectation)
	return expectation
}

// Then sets up IListRepo.GetUserLists return parameters for the expectation previously defined by the When method
func (e *IListRepoMockGetUserListsExpectation) Then(la1 []model.List, err error) *IListRepoMock {
	e.results = &IListRepoMockGetUserListsResults{la1, err}
	return e.mock
}

// GetUserLists implements IListRepo
func (mmGetUserLists *IListRepoMock) GetUserLists(ctx context.Context, username string) (la1 []model.List, err error) {
	mm_atomic.AddUint64(&mmGetUserLists.beforeGetUserListsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserLists.afterGetUserListsCounter, 1)

	if mmGetUserLists.inspectFuncGetUserLists != nil {
		mmGetUserLists.inspectFuncGetUserLists(ctx, username)
	}

	mm_params := &IListRepoMockGetUserListsParams{ctx, username}

	// Record call args
	mmGetUserLists.GetUserListsMock.mutex.Lock()
	mmGetUserLists.GetUserListsMock.callArgs = append(mmGetUserLists.GetUserListsMock.callArgs, mm_params)
	mmGetUserLists.GetUserListsMock.mutex.Unlock()

	for _, e := range mmGetUserLists.GetUserListsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetUserLists.GetUserListsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserLists.GetUserListsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserLists.GetUserListsMock.defaultExpectation.params
		mm_got := IListRepoMockGetUserListsParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserLists.t.Errorf("IListRepoMock.GetUserLists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserLists.GetUserListsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserLists.t.Fatal("No results are set for the IListRepoMock.GetUserLists")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetUserLists.funcGetUserLists != nil {
		return mmGetUserLists.funcGetUserLists(ctx, username)
	}
	mmGetUserLists.t.Fatalf("Unexpected call to IListRepoMock.GetUserLists. %v %v", ctx, username)
	return
}

// GetUserListsAfterCounter returns a count of finished IListRepoMock.GetUserLists invocations
func (mmGetUserLists *IListRepoMock) GetUserListsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLists.afterGetUserListsCounter)
}

// GetUserListsBeforeCounter returns a count of IListRepoMock.GetUserLists invocations
func (mmGetUserLists *IListRepoMock) GetUserListsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLists.beforeGetUserListsCounter)
}

// Calls returns a list of arguments used in each call to IListRepoMock.GetUserLists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserLists *mIListRepoMockGetUserLists) Calls() []*IListRepoMockGetUserListsParams {
	mmGetUserLists.mutex.RLock()

	argCopy := make([]*IListRepoMockGetUserListsParams, len(mmGetUserLists.callArgs))
	copy(argCopy, mmGetUserLists.callArgs)

	mmGetUserLists.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserListsDone returns true if the count of the GetUserLists invocations corresponds
// the number of defined expectations
func (m *IListRepoMock) MinimockGetUserListsDone() bool {
	for _, e := range m.GetUserListsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserListsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserListsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserLists != nil && mm_atomic.LoadUint64(&m.afterGetUserListsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserListsInspect logs each unmet expectation
func (m *IListRepoMock) MinimockGetUserListsInspect() {
	for _, e := range m.GetUserListsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IListRepoMock.GetUserLists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserListsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserListsCounter) < 1 {
		if m.GetUserListsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IListRepoMock.GetUserLists")
		} else {
			m.t.Errorf("Expected call to IListRepoMock.GetUserLists with params: %#v", *m.GetUserListsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserLists != nil && mm_atomic.LoadUint64(&m.afterGetUserListsCounter) < 1 {
		m.t.Error("Expected call to IListRepoMock.GetUserLists")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IListRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToFavInspect()

		m.MinimockAddToListInspect()

		m.MinimockCreateListInspect()

		m.MinimockDelFromListInspect()

		m.MinimockDelListInspect()

		m.MinimockGetFavListInspect()

		m.MinimockGetListIdInspect()

		m.MinimockGetPublicListsInspect()

		m.MinimockGetUserListsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IListRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IListRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToFavDone() &&
		m.MinimockAddToListDone() &&
		m.MinimockCreateListDone() &&
		m.MinimockDelFromListDone() &&
		m.MinimockDelListDone() &&
		m.MinimockGetFavListDone() &&
		m.MinimockGetListIdDone() &&
		m.MinimockGetPublicListsDone() &&
		m.MinimockGetUserListsDone()
}
