package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IStaffRepo -o ..\..\repository\mocks\i_staff_repo_mock.go -n IStaffRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IStaffRepoMock implements repository.IStaffRepo
type IStaffRepoMock struct {
	t minimock.Tester

	funcCreateStaff          func(record model.Staff) (i1 int, err error)
	inspectFuncCreateStaff   func(record model.Staff)
	afterCreateStaffCounter  uint64
	beforeCreateStaffCounter uint64
	CreateStaffMock          mIStaffRepoMockCreateStaff

	funcDeleteStaff          func(id int) (err error)
	inspectFuncDeleteStaff   func(id int)
	afterDeleteStaffCounter  uint64
	beforeDeleteStaffCounter uint64
	DeleteStaffMock          mIStaffRepoMockDeleteStaff

	funcGetList          func() (sa1 []model.Staff, err error)
	inspectFuncGetList   func()
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mIStaffRepoMockGetList

	funcGetListDorama          func(idDorama int) (sa1 []model.Staff, err error)
	inspectFuncGetListDorama   func(idDorama int)
	afterGetListDoramaCounter  uint64
	beforeGetListDoramaCounter uint64
	GetListDoramaMock          mIStaffRepoMockGetListDorama

	funcGetListName          func(name string) (sa1 []model.Staff, err error)
	inspectFuncGetListName   func(name string)
	afterGetListNameCounter  uint64
	beforeGetListNameCounter uint64
	GetListNameMock          mIStaffRepoMockGetListName

	funcGetStaffById          func(id int) (sp1 *model.Staff, err error)
	inspectFuncGetStaffById   func(id int)
	afterGetStaffByIdCounter  uint64
	beforeGetStaffByIdCounter uint64
	GetStaffByIdMock          mIStaffRepoMockGetStaffById

	funcUpdateStaff          func(record model.Staff) (err error)
	inspectFuncUpdateStaff   func(record model.Staff)
	afterUpdateStaffCounter  uint64
	beforeUpdateStaffCounter uint64
	UpdateStaffMock          mIStaffRepoMockUpdateStaff
}

// NewIStaffRepoMock returns a mock for repository.IStaffRepo
func NewIStaffRepoMock(t minimock.Tester) *IStaffRepoMock {
	m := &IStaffRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateStaffMock = mIStaffRepoMockCreateStaff{mock: m}
	m.CreateStaffMock.callArgs = []*IStaffRepoMockCreateStaffParams{}

	m.DeleteStaffMock = mIStaffRepoMockDeleteStaff{mock: m}
	m.DeleteStaffMock.callArgs = []*IStaffRepoMockDeleteStaffParams{}

	m.GetListMock = mIStaffRepoMockGetList{mock: m}

	m.GetListDoramaMock = mIStaffRepoMockGetListDorama{mock: m}
	m.GetListDoramaMock.callArgs = []*IStaffRepoMockGetListDoramaParams{}

	m.GetListNameMock = mIStaffRepoMockGetListName{mock: m}
	m.GetListNameMock.callArgs = []*IStaffRepoMockGetListNameParams{}

	m.GetStaffByIdMock = mIStaffRepoMockGetStaffById{mock: m}
	m.GetStaffByIdMock.callArgs = []*IStaffRepoMockGetStaffByIdParams{}

	m.UpdateStaffMock = mIStaffRepoMockUpdateStaff{mock: m}
	m.UpdateStaffMock.callArgs = []*IStaffRepoMockUpdateStaffParams{}

	return m
}

type mIStaffRepoMockCreateStaff struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockCreateStaffExpectation
	expectations       []*IStaffRepoMockCreateStaffExpectation

	callArgs []*IStaffRepoMockCreateStaffParams
	mutex    sync.RWMutex
}

// IStaffRepoMockCreateStaffExpectation specifies expectation struct of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockCreateStaffParams
	results *IStaffRepoMockCreateStaffResults
	Counter uint64
}

// IStaffRepoMockCreateStaffParams contains parameters of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffParams struct {
	record model.Staff
}

// IStaffRepoMockCreateStaffResults contains results of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Expect(record model.Staff) *mIStaffRepoMockCreateStaff {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	if mmCreateStaff.defaultExpectation == nil {
		mmCreateStaff.defaultExpectation = &IStaffRepoMockCreateStaffExpectation{}
	}

	mmCreateStaff.defaultExpectation.params = &IStaffRepoMockCreateStaffParams{record}
	for _, e := range mmCreateStaff.expectations {
		if minimock.Equal(e.params, mmCreateStaff.defaultExpectation.params) {
			mmCreateStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateStaff.defaultExpectation.params)
		}
	}

	return mmCreateStaff
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Inspect(f func(record model.Staff)) *mIStaffRepoMockCreateStaff {
	if mmCreateStaff.mock.inspectFuncCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.CreateStaff")
	}

	mmCreateStaff.mock.inspectFuncCreateStaff = f

	return mmCreateStaff
}

// Return sets up results that will be returned by IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Return(i1 int, err error) *IStaffRepoMock {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	if mmCreateStaff.defaultExpectation == nil {
		mmCreateStaff.defaultExpectation = &IStaffRepoMockCreateStaffExpectation{mock: mmCreateStaff.mock}
	}
	mmCreateStaff.defaultExpectation.results = &IStaffRepoMockCreateStaffResults{i1, err}
	return mmCreateStaff.mock
}

// Set uses given function f to mock the IStaffRepo.CreateStaff method
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Set(f func(record model.Staff) (i1 int, err error)) *IStaffRepoMock {
	if mmCreateStaff.defaultExpectation != nil {
		mmCreateStaff.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.CreateStaff method")
	}

	if len(mmCreateStaff.expectations) > 0 {
		mmCreateStaff.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.CreateStaff method")
	}

	mmCreateStaff.mock.funcCreateStaff = f
	return mmCreateStaff.mock
}

// When sets expectation for the IStaffRepo.CreateStaff which will trigger the result defined by the following
// Then helper
func (mmCreateStaff *mIStaffRepoMockCreateStaff) When(record model.Staff) *IStaffRepoMockCreateStaffExpectation {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	expectation := &IStaffRepoMockCreateStaffExpectation{
		mock:   mmCreateStaff.mock,
		params: &IStaffRepoMockCreateStaffParams{record},
	}
	mmCreateStaff.expectations = append(mmCreateStaff.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.CreateStaff return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockCreateStaffExpectation) Then(i1 int, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockCreateStaffResults{i1, err}
	return e.mock
}

// CreateStaff implements repository.IStaffRepo
func (mmCreateStaff *IStaffRepoMock) CreateStaff(record model.Staff) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateStaff.beforeCreateStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateStaff.afterCreateStaffCounter, 1)

	if mmCreateStaff.inspectFuncCreateStaff != nil {
		mmCreateStaff.inspectFuncCreateStaff(record)
	}

	mm_params := &IStaffRepoMockCreateStaffParams{record}

	// Record call args
	mmCreateStaff.CreateStaffMock.mutex.Lock()
	mmCreateStaff.CreateStaffMock.callArgs = append(mmCreateStaff.CreateStaffMock.callArgs, mm_params)
	mmCreateStaff.CreateStaffMock.mutex.Unlock()

	for _, e := range mmCreateStaff.CreateStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateStaff.CreateStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateStaff.CreateStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateStaff.CreateStaffMock.defaultExpectation.params
		mm_got := IStaffRepoMockCreateStaffParams{record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateStaff.t.Errorf("IStaffRepoMock.CreateStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateStaff.CreateStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateStaff.t.Fatal("No results are set for the IStaffRepoMock.CreateStaff")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateStaff.funcCreateStaff != nil {
		return mmCreateStaff.funcCreateStaff(record)
	}
	mmCreateStaff.t.Fatalf("Unexpected call to IStaffRepoMock.CreateStaff. %v", record)
	return
}

// CreateStaffAfterCounter returns a count of finished IStaffRepoMock.CreateStaff invocations
func (mmCreateStaff *IStaffRepoMock) CreateStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStaff.afterCreateStaffCounter)
}

// CreateStaffBeforeCounter returns a count of IStaffRepoMock.CreateStaff invocations
func (mmCreateStaff *IStaffRepoMock) CreateStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStaff.beforeCreateStaffCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.CreateStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Calls() []*IStaffRepoMockCreateStaffParams {
	mmCreateStaff.mutex.RLock()

	argCopy := make([]*IStaffRepoMockCreateStaffParams, len(mmCreateStaff.callArgs))
	copy(argCopy, mmCreateStaff.callArgs)

	mmCreateStaff.mutex.RUnlock()

	return argCopy
}

// MinimockCreateStaffDone returns true if the count of the CreateStaff invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockCreateStaffDone() bool {
	for _, e := range m.CreateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateStaff != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateStaffInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockCreateStaffInspect() {
	for _, e := range m.CreateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.CreateStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		if m.CreateStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.CreateStaff")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.CreateStaff with params: %#v", *m.CreateStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateStaff != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.CreateStaff")
	}
}

type mIStaffRepoMockDeleteStaff struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockDeleteStaffExpectation
	expectations       []*IStaffRepoMockDeleteStaffExpectation

	callArgs []*IStaffRepoMockDeleteStaffParams
	mutex    sync.RWMutex
}

// IStaffRepoMockDeleteStaffExpectation specifies expectation struct of the IStaffRepo.DeleteStaff
type IStaffRepoMockDeleteStaffExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockDeleteStaffParams
	results *IStaffRepoMockDeleteStaffResults
	Counter uint64
}

// IStaffRepoMockDeleteStaffParams contains parameters of the IStaffRepo.DeleteStaff
type IStaffRepoMockDeleteStaffParams struct {
	id int
}

// IStaffRepoMockDeleteStaffResults contains results of the IStaffRepo.DeleteStaff
type IStaffRepoMockDeleteStaffResults struct {
	err error
}

// Expect sets up expected params for IStaffRepo.DeleteStaff
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) Expect(id int) *mIStaffRepoMockDeleteStaff {
	if mmDeleteStaff.mock.funcDeleteStaff != nil {
		mmDeleteStaff.mock.t.Fatalf("IStaffRepoMock.DeleteStaff mock is already set by Set")
	}

	if mmDeleteStaff.defaultExpectation == nil {
		mmDeleteStaff.defaultExpectation = &IStaffRepoMockDeleteStaffExpectation{}
	}

	mmDeleteStaff.defaultExpectation.params = &IStaffRepoMockDeleteStaffParams{id}
	for _, e := range mmDeleteStaff.expectations {
		if minimock.Equal(e.params, mmDeleteStaff.defaultExpectation.params) {
			mmDeleteStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStaff.defaultExpectation.params)
		}
	}

	return mmDeleteStaff
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.DeleteStaff
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) Inspect(f func(id int)) *mIStaffRepoMockDeleteStaff {
	if mmDeleteStaff.mock.inspectFuncDeleteStaff != nil {
		mmDeleteStaff.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.DeleteStaff")
	}

	mmDeleteStaff.mock.inspectFuncDeleteStaff = f

	return mmDeleteStaff
}

// Return sets up results that will be returned by IStaffRepo.DeleteStaff
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) Return(err error) *IStaffRepoMock {
	if mmDeleteStaff.mock.funcDeleteStaff != nil {
		mmDeleteStaff.mock.t.Fatalf("IStaffRepoMock.DeleteStaff mock is already set by Set")
	}

	if mmDeleteStaff.defaultExpectation == nil {
		mmDeleteStaff.defaultExpectation = &IStaffRepoMockDeleteStaffExpectation{mock: mmDeleteStaff.mock}
	}
	mmDeleteStaff.defaultExpectation.results = &IStaffRepoMockDeleteStaffResults{err}
	return mmDeleteStaff.mock
}

// Set uses given function f to mock the IStaffRepo.DeleteStaff method
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) Set(f func(id int) (err error)) *IStaffRepoMock {
	if mmDeleteStaff.defaultExpectation != nil {
		mmDeleteStaff.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.DeleteStaff method")
	}

	if len(mmDeleteStaff.expectations) > 0 {
		mmDeleteStaff.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.DeleteStaff method")
	}

	mmDeleteStaff.mock.funcDeleteStaff = f
	return mmDeleteStaff.mock
}

// When sets expectation for the IStaffRepo.DeleteStaff which will trigger the result defined by the following
// Then helper
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) When(id int) *IStaffRepoMockDeleteStaffExpectation {
	if mmDeleteStaff.mock.funcDeleteStaff != nil {
		mmDeleteStaff.mock.t.Fatalf("IStaffRepoMock.DeleteStaff mock is already set by Set")
	}

	expectation := &IStaffRepoMockDeleteStaffExpectation{
		mock:   mmDeleteStaff.mock,
		params: &IStaffRepoMockDeleteStaffParams{id},
	}
	mmDeleteStaff.expectations = append(mmDeleteStaff.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.DeleteStaff return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockDeleteStaffExpectation) Then(err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockDeleteStaffResults{err}
	return e.mock
}

// DeleteStaff implements repository.IStaffRepo
func (mmDeleteStaff *IStaffRepoMock) DeleteStaff(id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteStaff.beforeDeleteStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStaff.afterDeleteStaffCounter, 1)

	if mmDeleteStaff.inspectFuncDeleteStaff != nil {
		mmDeleteStaff.inspectFuncDeleteStaff(id)
	}

	mm_params := &IStaffRepoMockDeleteStaffParams{id}

	// Record call args
	mmDeleteStaff.DeleteStaffMock.mutex.Lock()
	mmDeleteStaff.DeleteStaffMock.callArgs = append(mmDeleteStaff.DeleteStaffMock.callArgs, mm_params)
	mmDeleteStaff.DeleteStaffMock.mutex.Unlock()

	for _, e := range mmDeleteStaff.DeleteStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteStaff.DeleteStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStaff.DeleteStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStaff.DeleteStaffMock.defaultExpectation.params
		mm_got := IStaffRepoMockDeleteStaffParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStaff.t.Errorf("IStaffRepoMock.DeleteStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteStaff.DeleteStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteStaff.t.Fatal("No results are set for the IStaffRepoMock.DeleteStaff")
		}
		return (*mm_results).err
	}
	if mmDeleteStaff.funcDeleteStaff != nil {
		return mmDeleteStaff.funcDeleteStaff(id)
	}
	mmDeleteStaff.t.Fatalf("Unexpected call to IStaffRepoMock.DeleteStaff. %v", id)
	return
}

// DeleteStaffAfterCounter returns a count of finished IStaffRepoMock.DeleteStaff invocations
func (mmDeleteStaff *IStaffRepoMock) DeleteStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStaff.afterDeleteStaffCounter)
}

// DeleteStaffBeforeCounter returns a count of IStaffRepoMock.DeleteStaff invocations
func (mmDeleteStaff *IStaffRepoMock) DeleteStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStaff.beforeDeleteStaffCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.DeleteStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStaff *mIStaffRepoMockDeleteStaff) Calls() []*IStaffRepoMockDeleteStaffParams {
	mmDeleteStaff.mutex.RLock()

	argCopy := make([]*IStaffRepoMockDeleteStaffParams, len(mmDeleteStaff.callArgs))
	copy(argCopy, mmDeleteStaff.callArgs)

	mmDeleteStaff.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStaffDone returns true if the count of the DeleteStaff invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockDeleteStaffDone() bool {
	for _, e := range m.DeleteStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStaff != nil && mm_atomic.LoadUint64(&m.afterDeleteStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteStaffInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockDeleteStaffInspect() {
	for _, e := range m.DeleteStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.DeleteStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteStaffCounter) < 1 {
		if m.DeleteStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.DeleteStaff")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.DeleteStaff with params: %#v", *m.DeleteStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStaff != nil && mm_atomic.LoadUint64(&m.afterDeleteStaffCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.DeleteStaff")
	}
}

type mIStaffRepoMockGetList struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListExpectation
	expectations       []*IStaffRepoMockGetListExpectation
}

// IStaffRepoMockGetListExpectation specifies expectation struct of the IStaffRepo.GetStaffList
type IStaffRepoMockGetListExpectation struct {
	mock *IStaffRepoMock

	results *IStaffRepoMockGetListResults
	Counter uint64
}

// IStaffRepoMockGetListResults contains results of the IStaffRepo.GetStaffList
type IStaffRepoMockGetListResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetStaffList
func (mmGetList *mIStaffRepoMockGetList) Expect() *mIStaffRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IStaffRepoMock.GetStaffList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IStaffRepoMockGetListExpectation{}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetStaffList
func (mmGetList *mIStaffRepoMockGetList) Inspect(f func()) *mIStaffRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetStaffList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by IStaffRepo.GetStaffList
func (mmGetList *mIStaffRepoMockGetList) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IStaffRepoMock.GetStaffList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IStaffRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &IStaffRepoMockGetListResults{sa1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the IStaffRepo.GetStaffList method
func (mmGetList *mIStaffRepoMockGetList) Set(f func() (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetStaffList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetStaffList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// GetList implements repository.IStaffRepo
func (mmGetList *IStaffRepoMock) GetList() (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList()
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the IStaffRepoMock.GetStaffList")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList()
	}
	mmGetList.t.Fatalf("Unexpected call to IStaffRepoMock.GetStaffList.")
	return
}

// GetListAfterCounter returns a count of finished IStaffRepoMock.GetList invocations
func (mmGetList *IStaffRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of IStaffRepoMock.GetList invocations
func (mmGetList *IStaffRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IStaffRepoMock.GetStaffList")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetStaffList")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetStaffList")
	}
}

type mIStaffRepoMockGetListDorama struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListDoramaExpectation
	expectations       []*IStaffRepoMockGetListDoramaExpectation

	callArgs []*IStaffRepoMockGetListDoramaParams
	mutex    sync.RWMutex
}

// IStaffRepoMockGetListDoramaExpectation specifies expectation struct of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockGetListDoramaParams
	results *IStaffRepoMockGetListDoramaResults
	Counter uint64
}

// IStaffRepoMockGetListDoramaParams contains parameters of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaParams struct {
	idDorama int
}

// IStaffRepoMockGetListDoramaResults contains results of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Expect(idDorama int) *mIStaffRepoMockGetListDorama {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IStaffRepoMockGetListDoramaExpectation{}
	}

	mmGetListDorama.defaultExpectation.params = &IStaffRepoMockGetListDoramaParams{idDorama}
	for _, e := range mmGetListDorama.expectations {
		if minimock.Equal(e.params, mmGetListDorama.defaultExpectation.params) {
			mmGetListDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListDorama.defaultExpectation.params)
		}
	}

	return mmGetListDorama
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Inspect(f func(idDorama int)) *mIStaffRepoMockGetListDorama {
	if mmGetListDorama.mock.inspectFuncGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetListDorama")
	}

	mmGetListDorama.mock.inspectFuncGetListDorama = f

	return mmGetListDorama
}

// Return sets up results that will be returned by IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IStaffRepoMockGetListDoramaExpectation{mock: mmGetListDorama.mock}
	}
	mmGetListDorama.defaultExpectation.results = &IStaffRepoMockGetListDoramaResults{sa1, err}
	return mmGetListDorama.mock
}

// Set uses given function f to mock the IStaffRepo.GetListDorama method
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Set(f func(idDorama int) (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetListDorama.defaultExpectation != nil {
		mmGetListDorama.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetListDorama method")
	}

	if len(mmGetListDorama.expectations) > 0 {
		mmGetListDorama.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetListDorama method")
	}

	mmGetListDorama.mock.funcGetListDorama = f
	return mmGetListDorama.mock
}

// When sets expectation for the IStaffRepo.GetListDorama which will trigger the result defined by the following
// Then helper
func (mmGetListDorama *mIStaffRepoMockGetListDorama) When(idDorama int) *IStaffRepoMockGetListDoramaExpectation {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	expectation := &IStaffRepoMockGetListDoramaExpectation{
		mock:   mmGetListDorama.mock,
		params: &IStaffRepoMockGetListDoramaParams{idDorama},
	}
	mmGetListDorama.expectations = append(mmGetListDorama.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.GetListDorama return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockGetListDoramaExpectation) Then(sa1 []model.Staff, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockGetListDoramaResults{sa1, err}
	return e.mock
}

// GetListDorama implements repository.IStaffRepo
func (mmGetListDorama *IStaffRepoMock) GetListDorama(idDorama int) (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetListDorama.beforeGetListDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListDorama.afterGetListDoramaCounter, 1)

	if mmGetListDorama.inspectFuncGetListDorama != nil {
		mmGetListDorama.inspectFuncGetListDorama(idDorama)
	}

	mm_params := &IStaffRepoMockGetListDoramaParams{idDorama}

	// Record call args
	mmGetListDorama.GetListDoramaMock.mutex.Lock()
	mmGetListDorama.GetListDoramaMock.callArgs = append(mmGetListDorama.GetListDoramaMock.callArgs, mm_params)
	mmGetListDorama.GetListDoramaMock.mutex.Unlock()

	for _, e := range mmGetListDorama.GetListDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetListDorama.GetListDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListDorama.GetListDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListDorama.GetListDoramaMock.defaultExpectation.params
		mm_got := IStaffRepoMockGetListDoramaParams{idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListDorama.t.Errorf("IStaffRepoMock.GetListDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListDorama.GetListDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListDorama.t.Fatal("No results are set for the IStaffRepoMock.GetListDorama")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetListDorama.funcGetListDorama != nil {
		return mmGetListDorama.funcGetListDorama(idDorama)
	}
	mmGetListDorama.t.Fatalf("Unexpected call to IStaffRepoMock.GetListDorama. %v", idDorama)
	return
}

// GetListDoramaAfterCounter returns a count of finished IStaffRepoMock.GetListDorama invocations
func (mmGetListDorama *IStaffRepoMock) GetListDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.afterGetListDoramaCounter)
}

// GetListDoramaBeforeCounter returns a count of IStaffRepoMock.GetListDorama invocations
func (mmGetListDorama *IStaffRepoMock) GetListDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.beforeGetListDoramaCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.GetListDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Calls() []*IStaffRepoMockGetListDoramaParams {
	mmGetListDorama.mutex.RLock()

	argCopy := make([]*IStaffRepoMockGetListDoramaParams, len(mmGetListDorama.callArgs))
	copy(argCopy, mmGetListDorama.callArgs)

	mmGetListDorama.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDoramaDone returns true if the count of the GetListDorama invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListDoramaDone() bool {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListDoramaInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListDoramaInspect() {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		if m.GetListDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.GetListDorama")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListDorama with params: %#v", *m.GetListDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetListDorama")
	}
}

type mIStaffRepoMockGetListName struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListNameExpectation
	expectations       []*IStaffRepoMockGetListNameExpectation

	callArgs []*IStaffRepoMockGetListNameParams
	mutex    sync.RWMutex
}

// IStaffRepoMockGetListNameExpectation specifies expectation struct of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockGetListNameParams
	results *IStaffRepoMockGetListNameResults
	Counter uint64
}

// IStaffRepoMockGetListNameParams contains parameters of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameParams struct {
	name string
}

// IStaffRepoMockGetListNameResults contains results of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Expect(name string) *mIStaffRepoMockGetListName {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IStaffRepoMockGetListNameExpectation{}
	}

	mmGetListName.defaultExpectation.params = &IStaffRepoMockGetListNameParams{name}
	for _, e := range mmGetListName.expectations {
		if minimock.Equal(e.params, mmGetListName.defaultExpectation.params) {
			mmGetListName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListName.defaultExpectation.params)
		}
	}

	return mmGetListName
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Inspect(f func(name string)) *mIStaffRepoMockGetListName {
	if mmGetListName.mock.inspectFuncGetListName != nil {
		mmGetListName.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetListName")
	}

	mmGetListName.mock.inspectFuncGetListName = f

	return mmGetListName
}

// Return sets up results that will be returned by IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IStaffRepoMockGetListNameExpectation{mock: mmGetListName.mock}
	}
	mmGetListName.defaultExpectation.results = &IStaffRepoMockGetListNameResults{sa1, err}
	return mmGetListName.mock
}

// Set uses given function f to mock the IStaffRepo.GetListName method
func (mmGetListName *mIStaffRepoMockGetListName) Set(f func(name string) (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetListName.defaultExpectation != nil {
		mmGetListName.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetListName method")
	}

	if len(mmGetListName.expectations) > 0 {
		mmGetListName.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetListName method")
	}

	mmGetListName.mock.funcGetListName = f
	return mmGetListName.mock
}

// When sets expectation for the IStaffRepo.GetListName which will trigger the result defined by the following
// Then helper
func (mmGetListName *mIStaffRepoMockGetListName) When(name string) *IStaffRepoMockGetListNameExpectation {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	expectation := &IStaffRepoMockGetListNameExpectation{
		mock:   mmGetListName.mock,
		params: &IStaffRepoMockGetListNameParams{name},
	}
	mmGetListName.expectations = append(mmGetListName.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.GetListName return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockGetListNameExpectation) Then(sa1 []model.Staff, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockGetListNameResults{sa1, err}
	return e.mock
}

// GetListName implements repository.IStaffRepo
func (mmGetListName *IStaffRepoMock) GetListName(name string) (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetListName.beforeGetListNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListName.afterGetListNameCounter, 1)

	if mmGetListName.inspectFuncGetListName != nil {
		mmGetListName.inspectFuncGetListName(name)
	}

	mm_params := &IStaffRepoMockGetListNameParams{name}

	// Record call args
	mmGetListName.GetListNameMock.mutex.Lock()
	mmGetListName.GetListNameMock.callArgs = append(mmGetListName.GetListNameMock.callArgs, mm_params)
	mmGetListName.GetListNameMock.mutex.Unlock()

	for _, e := range mmGetListName.GetListNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetListName.GetListNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListName.GetListNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListName.GetListNameMock.defaultExpectation.params
		mm_got := IStaffRepoMockGetListNameParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListName.t.Errorf("IStaffRepoMock.GetListName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListName.GetListNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListName.t.Fatal("No results are set for the IStaffRepoMock.GetListName")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetListName.funcGetListName != nil {
		return mmGetListName.funcGetListName(name)
	}
	mmGetListName.t.Fatalf("Unexpected call to IStaffRepoMock.GetListName. %v", name)
	return
}

// GetListNameAfterCounter returns a count of finished IStaffRepoMock.GetListName invocations
func (mmGetListName *IStaffRepoMock) GetListNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.afterGetListNameCounter)
}

// GetListNameBeforeCounter returns a count of IStaffRepoMock.GetListName invocations
func (mmGetListName *IStaffRepoMock) GetListNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.beforeGetListNameCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.GetListName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListName *mIStaffRepoMockGetListName) Calls() []*IStaffRepoMockGetListNameParams {
	mmGetListName.mutex.RLock()

	argCopy := make([]*IStaffRepoMockGetListNameParams, len(mmGetListName.callArgs))
	copy(argCopy, mmGetListName.callArgs)

	mmGetListName.mutex.RUnlock()

	return argCopy
}

// MinimockGetListNameDone returns true if the count of the GetListName invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListNameDone() bool {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListNameInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListNameInspect() {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		if m.GetListNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.GetListName")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListName with params: %#v", *m.GetListNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetListName")
	}
}

type mIStaffRepoMockGetStaffById struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetStaffByIdExpectation
	expectations       []*IStaffRepoMockGetStaffByIdExpectation

	callArgs []*IStaffRepoMockGetStaffByIdParams
	mutex    sync.RWMutex
}

// IStaffRepoMockGetStaffByIdExpectation specifies expectation struct of the IStaffRepo.GetStaffById
type IStaffRepoMockGetStaffByIdExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockGetStaffByIdParams
	results *IStaffRepoMockGetStaffByIdResults
	Counter uint64
}

// IStaffRepoMockGetStaffByIdParams contains parameters of the IStaffRepo.GetStaffById
type IStaffRepoMockGetStaffByIdParams struct {
	id int
}

// IStaffRepoMockGetStaffByIdResults contains results of the IStaffRepo.GetStaffById
type IStaffRepoMockGetStaffByIdResults struct {
	sp1 *model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetStaffById
func (mmGetStaffById *mIStaffRepoMockGetStaffById) Expect(id int) *mIStaffRepoMockGetStaffById {
	if mmGetStaffById.mock.funcGetStaffById != nil {
		mmGetStaffById.mock.t.Fatalf("IStaffRepoMock.GetStaffById mock is already set by Set")
	}

	if mmGetStaffById.defaultExpectation == nil {
		mmGetStaffById.defaultExpectation = &IStaffRepoMockGetStaffByIdExpectation{}
	}

	mmGetStaffById.defaultExpectation.params = &IStaffRepoMockGetStaffByIdParams{id}
	for _, e := range mmGetStaffById.expectations {
		if minimock.Equal(e.params, mmGetStaffById.defaultExpectation.params) {
			mmGetStaffById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStaffById.defaultExpectation.params)
		}
	}

	return mmGetStaffById
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetStaffById
func (mmGetStaffById *mIStaffRepoMockGetStaffById) Inspect(f func(id int)) *mIStaffRepoMockGetStaffById {
	if mmGetStaffById.mock.inspectFuncGetStaffById != nil {
		mmGetStaffById.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetStaffById")
	}

	mmGetStaffById.mock.inspectFuncGetStaffById = f

	return mmGetStaffById
}

// Return sets up results that will be returned by IStaffRepo.GetStaffById
func (mmGetStaffById *mIStaffRepoMockGetStaffById) Return(sp1 *model.Staff, err error) *IStaffRepoMock {
	if mmGetStaffById.mock.funcGetStaffById != nil {
		mmGetStaffById.mock.t.Fatalf("IStaffRepoMock.GetStaffById mock is already set by Set")
	}

	if mmGetStaffById.defaultExpectation == nil {
		mmGetStaffById.defaultExpectation = &IStaffRepoMockGetStaffByIdExpectation{mock: mmGetStaffById.mock}
	}
	mmGetStaffById.defaultExpectation.results = &IStaffRepoMockGetStaffByIdResults{sp1, err}
	return mmGetStaffById.mock
}

// Set uses given function f to mock the IStaffRepo.GetStaffById method
func (mmGetStaffById *mIStaffRepoMockGetStaffById) Set(f func(id int) (sp1 *model.Staff, err error)) *IStaffRepoMock {
	if mmGetStaffById.defaultExpectation != nil {
		mmGetStaffById.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetStaffById method")
	}

	if len(mmGetStaffById.expectations) > 0 {
		mmGetStaffById.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetStaffById method")
	}

	mmGetStaffById.mock.funcGetStaffById = f
	return mmGetStaffById.mock
}

// When sets expectation for the IStaffRepo.GetStaffById which will trigger the result defined by the following
// Then helper
func (mmGetStaffById *mIStaffRepoMockGetStaffById) When(id int) *IStaffRepoMockGetStaffByIdExpectation {
	if mmGetStaffById.mock.funcGetStaffById != nil {
		mmGetStaffById.mock.t.Fatalf("IStaffRepoMock.GetStaffById mock is already set by Set")
	}

	expectation := &IStaffRepoMockGetStaffByIdExpectation{
		mock:   mmGetStaffById.mock,
		params: &IStaffRepoMockGetStaffByIdParams{id},
	}
	mmGetStaffById.expectations = append(mmGetStaffById.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.GetStaffById return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockGetStaffByIdExpectation) Then(sp1 *model.Staff, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockGetStaffByIdResults{sp1, err}
	return e.mock
}

// GetStaffById implements repository.IStaffRepo
func (mmGetStaffById *IStaffRepoMock) GetStaffById(id int) (sp1 *model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetStaffById.beforeGetStaffByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStaffById.afterGetStaffByIdCounter, 1)

	if mmGetStaffById.inspectFuncGetStaffById != nil {
		mmGetStaffById.inspectFuncGetStaffById(id)
	}

	mm_params := &IStaffRepoMockGetStaffByIdParams{id}

	// Record call args
	mmGetStaffById.GetStaffByIdMock.mutex.Lock()
	mmGetStaffById.GetStaffByIdMock.callArgs = append(mmGetStaffById.GetStaffByIdMock.callArgs, mm_params)
	mmGetStaffById.GetStaffByIdMock.mutex.Unlock()

	for _, e := range mmGetStaffById.GetStaffByIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetStaffById.GetStaffByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStaffById.GetStaffByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStaffById.GetStaffByIdMock.defaultExpectation.params
		mm_got := IStaffRepoMockGetStaffByIdParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStaffById.t.Errorf("IStaffRepoMock.GetStaffById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStaffById.GetStaffByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStaffById.t.Fatal("No results are set for the IStaffRepoMock.GetStaffById")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetStaffById.funcGetStaffById != nil {
		return mmGetStaffById.funcGetStaffById(id)
	}
	mmGetStaffById.t.Fatalf("Unexpected call to IStaffRepoMock.GetStaffById. %v", id)
	return
}

// GetStaffByIdAfterCounter returns a count of finished IStaffRepoMock.GetStaffById invocations
func (mmGetStaffById *IStaffRepoMock) GetStaffByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStaffById.afterGetStaffByIdCounter)
}

// GetStaffByIdBeforeCounter returns a count of IStaffRepoMock.GetStaffById invocations
func (mmGetStaffById *IStaffRepoMock) GetStaffByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStaffById.beforeGetStaffByIdCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.GetStaffById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStaffById *mIStaffRepoMockGetStaffById) Calls() []*IStaffRepoMockGetStaffByIdParams {
	mmGetStaffById.mutex.RLock()

	argCopy := make([]*IStaffRepoMockGetStaffByIdParams, len(mmGetStaffById.callArgs))
	copy(argCopy, mmGetStaffById.callArgs)

	mmGetStaffById.mutex.RUnlock()

	return argCopy
}

// MinimockGetStaffByIdDone returns true if the count of the GetStaffById invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetStaffByIdDone() bool {
	for _, e := range m.GetStaffByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaffByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaffByIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStaffById != nil && mm_atomic.LoadUint64(&m.afterGetStaffByIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaffByIdInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetStaffByIdInspect() {
	for _, e := range m.GetStaffByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.GetStaffById with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaffByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaffByIdCounter) < 1 {
		if m.GetStaffByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.GetStaffById")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.GetStaffById with params: %#v", *m.GetStaffByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStaffById != nil && mm_atomic.LoadUint64(&m.afterGetStaffByIdCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetStaffById")
	}
}

type mIStaffRepoMockUpdateStaff struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockUpdateStaffExpectation
	expectations       []*IStaffRepoMockUpdateStaffExpectation

	callArgs []*IStaffRepoMockUpdateStaffParams
	mutex    sync.RWMutex
}

// IStaffRepoMockUpdateStaffExpectation specifies expectation struct of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockUpdateStaffParams
	results *IStaffRepoMockUpdateStaffResults
	Counter uint64
}

// IStaffRepoMockUpdateStaffParams contains parameters of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffParams struct {
	record model.Staff
}

// IStaffRepoMockUpdateStaffResults contains results of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffResults struct {
	err error
}

// Expect sets up expected params for IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Expect(record model.Staff) *mIStaffRepoMockUpdateStaff {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	if mmUpdateStaff.defaultExpectation == nil {
		mmUpdateStaff.defaultExpectation = &IStaffRepoMockUpdateStaffExpectation{}
	}

	mmUpdateStaff.defaultExpectation.params = &IStaffRepoMockUpdateStaffParams{record}
	for _, e := range mmUpdateStaff.expectations {
		if minimock.Equal(e.params, mmUpdateStaff.defaultExpectation.params) {
			mmUpdateStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStaff.defaultExpectation.params)
		}
	}

	return mmUpdateStaff
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Inspect(f func(record model.Staff)) *mIStaffRepoMockUpdateStaff {
	if mmUpdateStaff.mock.inspectFuncUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.UpdateStaff")
	}

	mmUpdateStaff.mock.inspectFuncUpdateStaff = f

	return mmUpdateStaff
}

// Return sets up results that will be returned by IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Return(err error) *IStaffRepoMock {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	if mmUpdateStaff.defaultExpectation == nil {
		mmUpdateStaff.defaultExpectation = &IStaffRepoMockUpdateStaffExpectation{mock: mmUpdateStaff.mock}
	}
	mmUpdateStaff.defaultExpectation.results = &IStaffRepoMockUpdateStaffResults{err}
	return mmUpdateStaff.mock
}

// Set uses given function f to mock the IStaffRepo.UpdateStaff method
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Set(f func(record model.Staff) (err error)) *IStaffRepoMock {
	if mmUpdateStaff.defaultExpectation != nil {
		mmUpdateStaff.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.UpdateStaff method")
	}

	if len(mmUpdateStaff.expectations) > 0 {
		mmUpdateStaff.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.UpdateStaff method")
	}

	mmUpdateStaff.mock.funcUpdateStaff = f
	return mmUpdateStaff.mock
}

// When sets expectation for the IStaffRepo.UpdateStaff which will trigger the result defined by the following
// Then helper
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) When(record model.Staff) *IStaffRepoMockUpdateStaffExpectation {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	expectation := &IStaffRepoMockUpdateStaffExpectation{
		mock:   mmUpdateStaff.mock,
		params: &IStaffRepoMockUpdateStaffParams{record},
	}
	mmUpdateStaff.expectations = append(mmUpdateStaff.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.UpdateStaff return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockUpdateStaffExpectation) Then(err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockUpdateStaffResults{err}
	return e.mock
}

// UpdateStaff implements repository.IStaffRepo
func (mmUpdateStaff *IStaffRepoMock) UpdateStaff(record model.Staff) (err error) {
	mm_atomic.AddUint64(&mmUpdateStaff.beforeUpdateStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStaff.afterUpdateStaffCounter, 1)

	if mmUpdateStaff.inspectFuncUpdateStaff != nil {
		mmUpdateStaff.inspectFuncUpdateStaff(record)
	}

	mm_params := &IStaffRepoMockUpdateStaffParams{record}

	// Record call args
	mmUpdateStaff.UpdateStaffMock.mutex.Lock()
	mmUpdateStaff.UpdateStaffMock.callArgs = append(mmUpdateStaff.UpdateStaffMock.callArgs, mm_params)
	mmUpdateStaff.UpdateStaffMock.mutex.Unlock()

	for _, e := range mmUpdateStaff.UpdateStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStaff.UpdateStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStaff.UpdateStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStaff.UpdateStaffMock.defaultExpectation.params
		mm_got := IStaffRepoMockUpdateStaffParams{record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStaff.t.Errorf("IStaffRepoMock.UpdateStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStaff.UpdateStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStaff.t.Fatal("No results are set for the IStaffRepoMock.UpdateStaff")
		}
		return (*mm_results).err
	}
	if mmUpdateStaff.funcUpdateStaff != nil {
		return mmUpdateStaff.funcUpdateStaff(record)
	}
	mmUpdateStaff.t.Fatalf("Unexpected call to IStaffRepoMock.UpdateStaff. %v", record)
	return
}

// UpdateStaffAfterCounter returns a count of finished IStaffRepoMock.UpdateStaff invocations
func (mmUpdateStaff *IStaffRepoMock) UpdateStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStaff.afterUpdateStaffCounter)
}

// UpdateStaffBeforeCounter returns a count of IStaffRepoMock.UpdateStaff invocations
func (mmUpdateStaff *IStaffRepoMock) UpdateStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStaff.beforeUpdateStaffCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.UpdateStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Calls() []*IStaffRepoMockUpdateStaffParams {
	mmUpdateStaff.mutex.RLock()

	argCopy := make([]*IStaffRepoMockUpdateStaffParams, len(mmUpdateStaff.callArgs))
	copy(argCopy, mmUpdateStaff.callArgs)

	mmUpdateStaff.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStaffDone returns true if the count of the UpdateStaff invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockUpdateStaffDone() bool {
	for _, e := range m.UpdateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStaff != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStaffInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockUpdateStaffInspect() {
	for _, e := range m.UpdateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.UpdateStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		if m.UpdateStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.UpdateStaff")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.UpdateStaff with params: %#v", *m.UpdateStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStaff != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.UpdateStaff")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStaffRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateStaffInspect()

		m.MinimockDeleteStaffInspect()

		m.MinimockGetListInspect()

		m.MinimockGetListDoramaInspect()

		m.MinimockGetListNameInspect()

		m.MinimockGetStaffByIdInspect()

		m.MinimockUpdateStaffInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStaffRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStaffRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateStaffDone() &&
		m.MinimockDeleteStaffDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetListDoramaDone() &&
		m.MinimockGetListNameDone() &&
		m.MinimockGetStaffByIdDone() &&
		m.MinimockUpdateStaffDone()
}
