package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/controller.IPointsController -o ..\..\repository\mocks\i_points_controller_mock.go -n IPointsControllerMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IPointsControllerMock implements controller.IPointsController
type IPointsControllerMock struct {
	t minimock.Tester

	funcEarnPoint          func(user *model.User, point int) (err error)
	inspectFuncEarnPoint   func(user *model.User, point int)
	afterEarnPointCounter  uint64
	beforeEarnPointCounter uint64
	EarnPointMock          mIPointsControllerMockEarnPoint

	funcEarnPointForLogin          func(user *model.User) (err error)
	inspectFuncEarnPointForLogin   func(user *model.User)
	afterEarnPointForLoginCounter  uint64
	beforeEarnPointForLoginCounter uint64
	EarnPointForLoginMock          mIPointsControllerMockEarnPointForLogin

	funcPurgePoint          func(user *model.User, point int) (err error)
	inspectFuncPurgePoint   func(user *model.User, point int)
	afterPurgePointCounter  uint64
	beforePurgePointCounter uint64
	PurgePointMock          mIPointsControllerMockPurgePoint
}

// NewIPointsControllerMock returns a mock for controller.IPointsController
func NewIPointsControllerMock(t minimock.Tester) *IPointsControllerMock {
	m := &IPointsControllerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.EarnPointMock = mIPointsControllerMockEarnPoint{mock: m}
	m.EarnPointMock.callArgs = []*IPointsControllerMockEarnPointParams{}

	m.EarnPointForLoginMock = mIPointsControllerMockEarnPointForLogin{mock: m}
	m.EarnPointForLoginMock.callArgs = []*IPointsControllerMockEarnPointForLoginParams{}

	m.PurgePointMock = mIPointsControllerMockPurgePoint{mock: m}
	m.PurgePointMock.callArgs = []*IPointsControllerMockPurgePointParams{}

	return m
}

type mIPointsControllerMockEarnPoint struct {
	mock               *IPointsControllerMock
	defaultExpectation *IPointsControllerMockEarnPointExpectation
	expectations       []*IPointsControllerMockEarnPointExpectation

	callArgs []*IPointsControllerMockEarnPointParams
	mutex    sync.RWMutex
}

// IPointsControllerMockEarnPointExpectation specifies expectation struct of the IPointsController.EarnPoint
type IPointsControllerMockEarnPointExpectation struct {
	mock    *IPointsControllerMock
	params  *IPointsControllerMockEarnPointParams
	results *IPointsControllerMockEarnPointResults
	Counter uint64
}

// IPointsControllerMockEarnPointParams contains parameters of the IPointsController.EarnPoint
type IPointsControllerMockEarnPointParams struct {
	user  *model.User
	point int
}

// IPointsControllerMockEarnPointResults contains results of the IPointsController.EarnPoint
type IPointsControllerMockEarnPointResults struct {
	err error
}

// Expect sets up expected params for IPointsController.EarnPoint
func (mmEarnPoint *mIPointsControllerMockEarnPoint) Expect(user *model.User, point int) *mIPointsControllerMockEarnPoint {
	if mmEarnPoint.mock.funcEarnPoint != nil {
		mmEarnPoint.mock.t.Fatalf("IPointsControllerMock.EarnPoint mock is already set by Set")
	}

	if mmEarnPoint.defaultExpectation == nil {
		mmEarnPoint.defaultExpectation = &IPointsControllerMockEarnPointExpectation{}
	}

	mmEarnPoint.defaultExpectation.params = &IPointsControllerMockEarnPointParams{user, point}
	for _, e := range mmEarnPoint.expectations {
		if minimock.Equal(e.params, mmEarnPoint.defaultExpectation.params) {
			mmEarnPoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEarnPoint.defaultExpectation.params)
		}
	}

	return mmEarnPoint
}

// Inspect accepts an inspector function that has same arguments as the IPointsController.EarnPoint
func (mmEarnPoint *mIPointsControllerMockEarnPoint) Inspect(f func(user *model.User, point int)) *mIPointsControllerMockEarnPoint {
	if mmEarnPoint.mock.inspectFuncEarnPoint != nil {
		mmEarnPoint.mock.t.Fatalf("Inspect function is already set for IPointsControllerMock.EarnPoint")
	}

	mmEarnPoint.mock.inspectFuncEarnPoint = f

	return mmEarnPoint
}

// Return sets up results that will be returned by IPointsController.EarnPoint
func (mmEarnPoint *mIPointsControllerMockEarnPoint) Return(err error) *IPointsControllerMock {
	if mmEarnPoint.mock.funcEarnPoint != nil {
		mmEarnPoint.mock.t.Fatalf("IPointsControllerMock.EarnPoint mock is already set by Set")
	}

	if mmEarnPoint.defaultExpectation == nil {
		mmEarnPoint.defaultExpectation = &IPointsControllerMockEarnPointExpectation{mock: mmEarnPoint.mock}
	}
	mmEarnPoint.defaultExpectation.results = &IPointsControllerMockEarnPointResults{err}
	return mmEarnPoint.mock
}

// Set uses given function f to mock the IPointsController.EarnPoint method
func (mmEarnPoint *mIPointsControllerMockEarnPoint) Set(f func(user *model.User, point int) (err error)) *IPointsControllerMock {
	if mmEarnPoint.defaultExpectation != nil {
		mmEarnPoint.mock.t.Fatalf("Default expectation is already set for the IPointsController.EarnPoint method")
	}

	if len(mmEarnPoint.expectations) > 0 {
		mmEarnPoint.mock.t.Fatalf("Some expectations are already set for the IPointsController.EarnPoint method")
	}

	mmEarnPoint.mock.funcEarnPoint = f
	return mmEarnPoint.mock
}

// When sets expectation for the IPointsController.EarnPoint which will trigger the result defined by the following
// Then helper
func (mmEarnPoint *mIPointsControllerMockEarnPoint) When(user *model.User, point int) *IPointsControllerMockEarnPointExpectation {
	if mmEarnPoint.mock.funcEarnPoint != nil {
		mmEarnPoint.mock.t.Fatalf("IPointsControllerMock.EarnPoint mock is already set by Set")
	}

	expectation := &IPointsControllerMockEarnPointExpectation{
		mock:   mmEarnPoint.mock,
		params: &IPointsControllerMockEarnPointParams{user, point},
	}
	mmEarnPoint.expectations = append(mmEarnPoint.expectations, expectation)
	return expectation
}

// Then sets up IPointsController.EarnPoint return parameters for the expectation previously defined by the When method
func (e *IPointsControllerMockEarnPointExpectation) Then(err error) *IPointsControllerMock {
	e.results = &IPointsControllerMockEarnPointResults{err}
	return e.mock
}

// EarnPoint implements controller.IPointsController
func (mmEarnPoint *IPointsControllerMock) EarnPoint(user *model.User, point int) (err error) {
	mm_atomic.AddUint64(&mmEarnPoint.beforeEarnPointCounter, 1)
	defer mm_atomic.AddUint64(&mmEarnPoint.afterEarnPointCounter, 1)

	if mmEarnPoint.inspectFuncEarnPoint != nil {
		mmEarnPoint.inspectFuncEarnPoint(user, point)
	}

	mm_params := &IPointsControllerMockEarnPointParams{user, point}

	// Record call args
	mmEarnPoint.EarnPointMock.mutex.Lock()
	mmEarnPoint.EarnPointMock.callArgs = append(mmEarnPoint.EarnPointMock.callArgs, mm_params)
	mmEarnPoint.EarnPointMock.mutex.Unlock()

	for _, e := range mmEarnPoint.EarnPointMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEarnPoint.EarnPointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEarnPoint.EarnPointMock.defaultExpectation.Counter, 1)
		mm_want := mmEarnPoint.EarnPointMock.defaultExpectation.params
		mm_got := IPointsControllerMockEarnPointParams{user, point}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEarnPoint.t.Errorf("IPointsControllerMock.EarnPoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEarnPoint.EarnPointMock.defaultExpectation.results
		if mm_results == nil {
			mmEarnPoint.t.Fatal("No results are set for the IPointsControllerMock.EarnPoint")
		}
		return (*mm_results).err
	}
	if mmEarnPoint.funcEarnPoint != nil {
		return mmEarnPoint.funcEarnPoint(user, point)
	}
	mmEarnPoint.t.Fatalf("Unexpected call to IPointsControllerMock.EarnPoint. %v %v", user, point)
	return
}

// EarnPointAfterCounter returns a count of finished IPointsControllerMock.EarnPoint invocations
func (mmEarnPoint *IPointsControllerMock) EarnPointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEarnPoint.afterEarnPointCounter)
}

// EarnPointBeforeCounter returns a count of IPointsControllerMock.EarnPoint invocations
func (mmEarnPoint *IPointsControllerMock) EarnPointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEarnPoint.beforeEarnPointCounter)
}

// Calls returns a list of arguments used in each call to IPointsControllerMock.EarnPoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEarnPoint *mIPointsControllerMockEarnPoint) Calls() []*IPointsControllerMockEarnPointParams {
	mmEarnPoint.mutex.RLock()

	argCopy := make([]*IPointsControllerMockEarnPointParams, len(mmEarnPoint.callArgs))
	copy(argCopy, mmEarnPoint.callArgs)

	mmEarnPoint.mutex.RUnlock()

	return argCopy
}

// MinimockEarnPointDone returns true if the count of the EarnPoint invocations corresponds
// the number of defined expectations
func (m *IPointsControllerMock) MinimockEarnPointDone() bool {
	for _, e := range m.EarnPointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EarnPointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEarnPointCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEarnPoint != nil && mm_atomic.LoadUint64(&m.afterEarnPointCounter) < 1 {
		return false
	}
	return true
}

// MinimockEarnPointInspect logs each unmet expectation
func (m *IPointsControllerMock) MinimockEarnPointInspect() {
	for _, e := range m.EarnPointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPointsControllerMock.EarnPoint with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EarnPointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEarnPointCounter) < 1 {
		if m.EarnPointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPointsControllerMock.EarnPoint")
		} else {
			m.t.Errorf("Expected call to IPointsControllerMock.EarnPoint with params: %#v", *m.EarnPointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEarnPoint != nil && mm_atomic.LoadUint64(&m.afterEarnPointCounter) < 1 {
		m.t.Error("Expected call to IPointsControllerMock.EarnPoint")
	}
}

type mIPointsControllerMockEarnPointForLogin struct {
	mock               *IPointsControllerMock
	defaultExpectation *IPointsControllerMockEarnPointForLoginExpectation
	expectations       []*IPointsControllerMockEarnPointForLoginExpectation

	callArgs []*IPointsControllerMockEarnPointForLoginParams
	mutex    sync.RWMutex
}

// IPointsControllerMockEarnPointForLoginExpectation specifies expectation struct of the IPointsController.EarnPointForLogin
type IPointsControllerMockEarnPointForLoginExpectation struct {
	mock    *IPointsControllerMock
	params  *IPointsControllerMockEarnPointForLoginParams
	results *IPointsControllerMockEarnPointForLoginResults
	Counter uint64
}

// IPointsControllerMockEarnPointForLoginParams contains parameters of the IPointsController.EarnPointForLogin
type IPointsControllerMockEarnPointForLoginParams struct {
	user *model.User
}

// IPointsControllerMockEarnPointForLoginResults contains results of the IPointsController.EarnPointForLogin
type IPointsControllerMockEarnPointForLoginResults struct {
	err error
}

// Expect sets up expected params for IPointsController.EarnPointForLogin
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) Expect(user *model.User) *mIPointsControllerMockEarnPointForLogin {
	if mmEarnPointForLogin.mock.funcEarnPointForLogin != nil {
		mmEarnPointForLogin.mock.t.Fatalf("IPointsControllerMock.EarnPointForLogin mock is already set by Set")
	}

	if mmEarnPointForLogin.defaultExpectation == nil {
		mmEarnPointForLogin.defaultExpectation = &IPointsControllerMockEarnPointForLoginExpectation{}
	}

	mmEarnPointForLogin.defaultExpectation.params = &IPointsControllerMockEarnPointForLoginParams{user}
	for _, e := range mmEarnPointForLogin.expectations {
		if minimock.Equal(e.params, mmEarnPointForLogin.defaultExpectation.params) {
			mmEarnPointForLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEarnPointForLogin.defaultExpectation.params)
		}
	}

	return mmEarnPointForLogin
}

// Inspect accepts an inspector function that has same arguments as the IPointsController.EarnPointForLogin
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) Inspect(f func(user *model.User)) *mIPointsControllerMockEarnPointForLogin {
	if mmEarnPointForLogin.mock.inspectFuncEarnPointForLogin != nil {
		mmEarnPointForLogin.mock.t.Fatalf("Inspect function is already set for IPointsControllerMock.EarnPointForLogin")
	}

	mmEarnPointForLogin.mock.inspectFuncEarnPointForLogin = f

	return mmEarnPointForLogin
}

// Return sets up results that will be returned by IPointsController.EarnPointForLogin
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) Return(err error) *IPointsControllerMock {
	if mmEarnPointForLogin.mock.funcEarnPointForLogin != nil {
		mmEarnPointForLogin.mock.t.Fatalf("IPointsControllerMock.EarnPointForLogin mock is already set by Set")
	}

	if mmEarnPointForLogin.defaultExpectation == nil {
		mmEarnPointForLogin.defaultExpectation = &IPointsControllerMockEarnPointForLoginExpectation{mock: mmEarnPointForLogin.mock}
	}
	mmEarnPointForLogin.defaultExpectation.results = &IPointsControllerMockEarnPointForLoginResults{err}
	return mmEarnPointForLogin.mock
}

// Set uses given function f to mock the IPointsController.EarnPointForLogin method
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) Set(f func(user *model.User) (err error)) *IPointsControllerMock {
	if mmEarnPointForLogin.defaultExpectation != nil {
		mmEarnPointForLogin.mock.t.Fatalf("Default expectation is already set for the IPointsController.EarnPointForLogin method")
	}

	if len(mmEarnPointForLogin.expectations) > 0 {
		mmEarnPointForLogin.mock.t.Fatalf("Some expectations are already set for the IPointsController.EarnPointForLogin method")
	}

	mmEarnPointForLogin.mock.funcEarnPointForLogin = f
	return mmEarnPointForLogin.mock
}

// When sets expectation for the IPointsController.EarnPointForLogin which will trigger the result defined by the following
// Then helper
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) When(user *model.User) *IPointsControllerMockEarnPointForLoginExpectation {
	if mmEarnPointForLogin.mock.funcEarnPointForLogin != nil {
		mmEarnPointForLogin.mock.t.Fatalf("IPointsControllerMock.EarnPointForLogin mock is already set by Set")
	}

	expectation := &IPointsControllerMockEarnPointForLoginExpectation{
		mock:   mmEarnPointForLogin.mock,
		params: &IPointsControllerMockEarnPointForLoginParams{user},
	}
	mmEarnPointForLogin.expectations = append(mmEarnPointForLogin.expectations, expectation)
	return expectation
}

// Then sets up IPointsController.EarnPointForLogin return parameters for the expectation previously defined by the When method
func (e *IPointsControllerMockEarnPointForLoginExpectation) Then(err error) *IPointsControllerMock {
	e.results = &IPointsControllerMockEarnPointForLoginResults{err}
	return e.mock
}

// EarnPointForLogin implements controller.IPointsController
func (mmEarnPointForLogin *IPointsControllerMock) EarnPointForLogin(user *model.User) (err error) {
	mm_atomic.AddUint64(&mmEarnPointForLogin.beforeEarnPointForLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmEarnPointForLogin.afterEarnPointForLoginCounter, 1)

	if mmEarnPointForLogin.inspectFuncEarnPointForLogin != nil {
		mmEarnPointForLogin.inspectFuncEarnPointForLogin(user)
	}

	mm_params := &IPointsControllerMockEarnPointForLoginParams{user}

	// Record call args
	mmEarnPointForLogin.EarnPointForLoginMock.mutex.Lock()
	mmEarnPointForLogin.EarnPointForLoginMock.callArgs = append(mmEarnPointForLogin.EarnPointForLoginMock.callArgs, mm_params)
	mmEarnPointForLogin.EarnPointForLoginMock.mutex.Unlock()

	for _, e := range mmEarnPointForLogin.EarnPointForLoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEarnPointForLogin.EarnPointForLoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEarnPointForLogin.EarnPointForLoginMock.defaultExpectation.Counter, 1)
		mm_want := mmEarnPointForLogin.EarnPointForLoginMock.defaultExpectation.params
		mm_got := IPointsControllerMockEarnPointForLoginParams{user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEarnPointForLogin.t.Errorf("IPointsControllerMock.EarnPointForLogin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEarnPointForLogin.EarnPointForLoginMock.defaultExpectation.results
		if mm_results == nil {
			mmEarnPointForLogin.t.Fatal("No results are set for the IPointsControllerMock.EarnPointForLogin")
		}
		return (*mm_results).err
	}
	if mmEarnPointForLogin.funcEarnPointForLogin != nil {
		return mmEarnPointForLogin.funcEarnPointForLogin(user)
	}
	mmEarnPointForLogin.t.Fatalf("Unexpected call to IPointsControllerMock.EarnPointForLogin. %v", user)
	return
}

// EarnPointForLoginAfterCounter returns a count of finished IPointsControllerMock.EarnPointForLogin invocations
func (mmEarnPointForLogin *IPointsControllerMock) EarnPointForLoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEarnPointForLogin.afterEarnPointForLoginCounter)
}

// EarnPointForLoginBeforeCounter returns a count of IPointsControllerMock.EarnPointForLogin invocations
func (mmEarnPointForLogin *IPointsControllerMock) EarnPointForLoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEarnPointForLogin.beforeEarnPointForLoginCounter)
}

// Calls returns a list of arguments used in each call to IPointsControllerMock.EarnPointForLogin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEarnPointForLogin *mIPointsControllerMockEarnPointForLogin) Calls() []*IPointsControllerMockEarnPointForLoginParams {
	mmEarnPointForLogin.mutex.RLock()

	argCopy := make([]*IPointsControllerMockEarnPointForLoginParams, len(mmEarnPointForLogin.callArgs))
	copy(argCopy, mmEarnPointForLogin.callArgs)

	mmEarnPointForLogin.mutex.RUnlock()

	return argCopy
}

// MinimockEarnPointForLoginDone returns true if the count of the EarnPointForLogin invocations corresponds
// the number of defined expectations
func (m *IPointsControllerMock) MinimockEarnPointForLoginDone() bool {
	for _, e := range m.EarnPointForLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EarnPointForLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEarnPointForLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEarnPointForLogin != nil && mm_atomic.LoadUint64(&m.afterEarnPointForLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockEarnPointForLoginInspect logs each unmet expectation
func (m *IPointsControllerMock) MinimockEarnPointForLoginInspect() {
	for _, e := range m.EarnPointForLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPointsControllerMock.EarnPointForLogin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EarnPointForLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEarnPointForLoginCounter) < 1 {
		if m.EarnPointForLoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPointsControllerMock.EarnPointForLogin")
		} else {
			m.t.Errorf("Expected call to IPointsControllerMock.EarnPointForLogin with params: %#v", *m.EarnPointForLoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEarnPointForLogin != nil && mm_atomic.LoadUint64(&m.afterEarnPointForLoginCounter) < 1 {
		m.t.Error("Expected call to IPointsControllerMock.EarnPointForLogin")
	}
}

type mIPointsControllerMockPurgePoint struct {
	mock               *IPointsControllerMock
	defaultExpectation *IPointsControllerMockPurgePointExpectation
	expectations       []*IPointsControllerMockPurgePointExpectation

	callArgs []*IPointsControllerMockPurgePointParams
	mutex    sync.RWMutex
}

// IPointsControllerMockPurgePointExpectation specifies expectation struct of the IPointsController.PurgePoint
type IPointsControllerMockPurgePointExpectation struct {
	mock    *IPointsControllerMock
	params  *IPointsControllerMockPurgePointParams
	results *IPointsControllerMockPurgePointResults
	Counter uint64
}

// IPointsControllerMockPurgePointParams contains parameters of the IPointsController.PurgePoint
type IPointsControllerMockPurgePointParams struct {
	user  *model.User
	point int
}

// IPointsControllerMockPurgePointResults contains results of the IPointsController.PurgePoint
type IPointsControllerMockPurgePointResults struct {
	err error
}

// Expect sets up expected params for IPointsController.PurgePoint
func (mmPurgePoint *mIPointsControllerMockPurgePoint) Expect(user *model.User, point int) *mIPointsControllerMockPurgePoint {
	if mmPurgePoint.mock.funcPurgePoint != nil {
		mmPurgePoint.mock.t.Fatalf("IPointsControllerMock.PurgePoint mock is already set by Set")
	}

	if mmPurgePoint.defaultExpectation == nil {
		mmPurgePoint.defaultExpectation = &IPointsControllerMockPurgePointExpectation{}
	}

	mmPurgePoint.defaultExpectation.params = &IPointsControllerMockPurgePointParams{user, point}
	for _, e := range mmPurgePoint.expectations {
		if minimock.Equal(e.params, mmPurgePoint.defaultExpectation.params) {
			mmPurgePoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurgePoint.defaultExpectation.params)
		}
	}

	return mmPurgePoint
}

// Inspect accepts an inspector function that has same arguments as the IPointsController.PurgePoint
func (mmPurgePoint *mIPointsControllerMockPurgePoint) Inspect(f func(user *model.User, point int)) *mIPointsControllerMockPurgePoint {
	if mmPurgePoint.mock.inspectFuncPurgePoint != nil {
		mmPurgePoint.mock.t.Fatalf("Inspect function is already set for IPointsControllerMock.PurgePoint")
	}

	mmPurgePoint.mock.inspectFuncPurgePoint = f

	return mmPurgePoint
}

// Return sets up results that will be returned by IPointsController.PurgePoint
func (mmPurgePoint *mIPointsControllerMockPurgePoint) Return(err error) *IPointsControllerMock {
	if mmPurgePoint.mock.funcPurgePoint != nil {
		mmPurgePoint.mock.t.Fatalf("IPointsControllerMock.PurgePoint mock is already set by Set")
	}

	if mmPurgePoint.defaultExpectation == nil {
		mmPurgePoint.defaultExpectation = &IPointsControllerMockPurgePointExpectation{mock: mmPurgePoint.mock}
	}
	mmPurgePoint.defaultExpectation.results = &IPointsControllerMockPurgePointResults{err}
	return mmPurgePoint.mock
}

// Set uses given function f to mock the IPointsController.PurgePoint method
func (mmPurgePoint *mIPointsControllerMockPurgePoint) Set(f func(user *model.User, point int) (err error)) *IPointsControllerMock {
	if mmPurgePoint.defaultExpectation != nil {
		mmPurgePoint.mock.t.Fatalf("Default expectation is already set for the IPointsController.PurgePoint method")
	}

	if len(mmPurgePoint.expectations) > 0 {
		mmPurgePoint.mock.t.Fatalf("Some expectations are already set for the IPointsController.PurgePoint method")
	}

	mmPurgePoint.mock.funcPurgePoint = f
	return mmPurgePoint.mock
}

// When sets expectation for the IPointsController.PurgePoint which will trigger the result defined by the following
// Then helper
func (mmPurgePoint *mIPointsControllerMockPurgePoint) When(user *model.User, point int) *IPointsControllerMockPurgePointExpectation {
	if mmPurgePoint.mock.funcPurgePoint != nil {
		mmPurgePoint.mock.t.Fatalf("IPointsControllerMock.PurgePoint mock is already set by Set")
	}

	expectation := &IPointsControllerMockPurgePointExpectation{
		mock:   mmPurgePoint.mock,
		params: &IPointsControllerMockPurgePointParams{user, point},
	}
	mmPurgePoint.expectations = append(mmPurgePoint.expectations, expectation)
	return expectation
}

// Then sets up IPointsController.PurgePoint return parameters for the expectation previously defined by the When method
func (e *IPointsControllerMockPurgePointExpectation) Then(err error) *IPointsControllerMock {
	e.results = &IPointsControllerMockPurgePointResults{err}
	return e.mock
}

// PurgePoint implements controller.IPointsController
func (mmPurgePoint *IPointsControllerMock) PurgePoint(user *model.User, point int) (err error) {
	mm_atomic.AddUint64(&mmPurgePoint.beforePurgePointCounter, 1)
	defer mm_atomic.AddUint64(&mmPurgePoint.afterPurgePointCounter, 1)

	if mmPurgePoint.inspectFuncPurgePoint != nil {
		mmPurgePoint.inspectFuncPurgePoint(user, point)
	}

	mm_params := &IPointsControllerMockPurgePointParams{user, point}

	// Record call args
	mmPurgePoint.PurgePointMock.mutex.Lock()
	mmPurgePoint.PurgePointMock.callArgs = append(mmPurgePoint.PurgePointMock.callArgs, mm_params)
	mmPurgePoint.PurgePointMock.mutex.Unlock()

	for _, e := range mmPurgePoint.PurgePointMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurgePoint.PurgePointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurgePoint.PurgePointMock.defaultExpectation.Counter, 1)
		mm_want := mmPurgePoint.PurgePointMock.defaultExpectation.params
		mm_got := IPointsControllerMockPurgePointParams{user, point}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurgePoint.t.Errorf("IPointsControllerMock.PurgePoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurgePoint.PurgePointMock.defaultExpectation.results
		if mm_results == nil {
			mmPurgePoint.t.Fatal("No results are set for the IPointsControllerMock.PurgePoint")
		}
		return (*mm_results).err
	}
	if mmPurgePoint.funcPurgePoint != nil {
		return mmPurgePoint.funcPurgePoint(user, point)
	}
	mmPurgePoint.t.Fatalf("Unexpected call to IPointsControllerMock.PurgePoint. %v %v", user, point)
	return
}

// PurgePointAfterCounter returns a count of finished IPointsControllerMock.PurgePoint invocations
func (mmPurgePoint *IPointsControllerMock) PurgePointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgePoint.afterPurgePointCounter)
}

// PurgePointBeforeCounter returns a count of IPointsControllerMock.PurgePoint invocations
func (mmPurgePoint *IPointsControllerMock) PurgePointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgePoint.beforePurgePointCounter)
}

// Calls returns a list of arguments used in each call to IPointsControllerMock.PurgePoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurgePoint *mIPointsControllerMockPurgePoint) Calls() []*IPointsControllerMockPurgePointParams {
	mmPurgePoint.mutex.RLock()

	argCopy := make([]*IPointsControllerMockPurgePointParams, len(mmPurgePoint.callArgs))
	copy(argCopy, mmPurgePoint.callArgs)

	mmPurgePoint.mutex.RUnlock()

	return argCopy
}

// MinimockPurgePointDone returns true if the count of the PurgePoint invocations corresponds
// the number of defined expectations
func (m *IPointsControllerMock) MinimockPurgePointDone() bool {
	for _, e := range m.PurgePointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurgePointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurgePointCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurgePoint != nil && mm_atomic.LoadUint64(&m.afterPurgePointCounter) < 1 {
		return false
	}
	return true
}

// MinimockPurgePointInspect logs each unmet expectation
func (m *IPointsControllerMock) MinimockPurgePointInspect() {
	for _, e := range m.PurgePointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPointsControllerMock.PurgePoint with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurgePointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurgePointCounter) < 1 {
		if m.PurgePointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPointsControllerMock.PurgePoint")
		} else {
			m.t.Errorf("Expected call to IPointsControllerMock.PurgePoint with params: %#v", *m.PurgePointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurgePoint != nil && mm_atomic.LoadUint64(&m.afterPurgePointCounter) < 1 {
		m.t.Error("Expected call to IPointsControllerMock.PurgePoint")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPointsControllerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockEarnPointInspect()

		m.MinimockEarnPointForLoginInspect()

		m.MinimockPurgePointInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPointsControllerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPointsControllerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockEarnPointDone() &&
		m.MinimockEarnPointForLoginDone() &&
		m.MinimockPurgePointDone()
}
