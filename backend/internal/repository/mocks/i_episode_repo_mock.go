package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IEpisodeRepo -o ..\..\repository\mocks\i_episode_repo_mock.go -n IEpisodeRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IEpisodeRepoMock implements repository.IEpisodeRepo
type IEpisodeRepoMock struct {
	t minimock.Tester

	funcCreateEpisode          func(episode model.Episode, idD int) (i1 int, err error)
	inspectFuncCreateEpisode   func(episode model.Episode, idD int)
	afterCreateEpisodeCounter  uint64
	beforeCreateEpisodeCounter uint64
	CreateEpisodeMock          mIEpisodeRepoMockCreateEpisode

	funcDeleteEpisode          func(id int) (err error)
	inspectFuncDeleteEpisode   func(id int)
	afterDeleteEpisodeCounter  uint64
	beforeDeleteEpisodeCounter uint64
	DeleteEpisodeMock          mIEpisodeRepoMockDeleteEpisode

	funcGetEpisode          func(id int) (ep1 *model.Episode, err error)
	inspectFuncGetEpisode   func(id int)
	afterGetEpisodeCounter  uint64
	beforeGetEpisodeCounter uint64
	GetEpisodeMock          mIEpisodeRepoMockGetEpisode

	funcGetList          func(idDorama int) (ea1 []model.Episode, err error)
	inspectFuncGetList   func(idDorama int)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mIEpisodeRepoMockGetList

	funcMarkEpisode          func(idEp int, username string) (err error)
	inspectFuncMarkEpisode   func(idEp int, username string)
	afterMarkEpisodeCounter  uint64
	beforeMarkEpisodeCounter uint64
	MarkEpisodeMock          mIEpisodeRepoMockMarkEpisode
}

// NewIEpisodeRepoMock returns a mock for repository.IEpisodeRepo
func NewIEpisodeRepoMock(t minimock.Tester) *IEpisodeRepoMock {
	m := &IEpisodeRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEpisodeMock = mIEpisodeRepoMockCreateEpisode{mock: m}
	m.CreateEpisodeMock.callArgs = []*IEpisodeRepoMockCreateEpisodeParams{}

	m.DeleteEpisodeMock = mIEpisodeRepoMockDeleteEpisode{mock: m}
	m.DeleteEpisodeMock.callArgs = []*IEpisodeRepoMockDeleteEpisodeParams{}

	m.GetEpisodeMock = mIEpisodeRepoMockGetEpisode{mock: m}
	m.GetEpisodeMock.callArgs = []*IEpisodeRepoMockGetEpisodeParams{}

	m.GetListMock = mIEpisodeRepoMockGetList{mock: m}
	m.GetListMock.callArgs = []*IEpisodeRepoMockGetListParams{}

	m.MarkEpisodeMock = mIEpisodeRepoMockMarkEpisode{mock: m}
	m.MarkEpisodeMock.callArgs = []*IEpisodeRepoMockMarkEpisodeParams{}

	return m
}

type mIEpisodeRepoMockCreateEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockCreateEpisodeExpectation
	expectations       []*IEpisodeRepoMockCreateEpisodeExpectation

	callArgs []*IEpisodeRepoMockCreateEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockCreateEpisodeExpectation specifies expectation struct of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockCreateEpisodeParams
	results *IEpisodeRepoMockCreateEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockCreateEpisodeParams contains parameters of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeParams struct {
	episode model.Episode
	idD     int
}

// IEpisodeRepoMockCreateEpisodeResults contains results of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Expect(episode model.Episode, idD int) *mIEpisodeRepoMockCreateEpisode {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	if mmCreateEpisode.defaultExpectation == nil {
		mmCreateEpisode.defaultExpectation = &IEpisodeRepoMockCreateEpisodeExpectation{}
	}

	mmCreateEpisode.defaultExpectation.params = &IEpisodeRepoMockCreateEpisodeParams{episode, idD}
	for _, e := range mmCreateEpisode.expectations {
		if minimock.Equal(e.params, mmCreateEpisode.defaultExpectation.params) {
			mmCreateEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEpisode.defaultExpectation.params)
		}
	}

	return mmCreateEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Inspect(f func(episode model.Episode, idD int)) *mIEpisodeRepoMockCreateEpisode {
	if mmCreateEpisode.mock.inspectFuncCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.CreateEpisode")
	}

	mmCreateEpisode.mock.inspectFuncCreateEpisode = f

	return mmCreateEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Return(i1 int, err error) *IEpisodeRepoMock {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	if mmCreateEpisode.defaultExpectation == nil {
		mmCreateEpisode.defaultExpectation = &IEpisodeRepoMockCreateEpisodeExpectation{mock: mmCreateEpisode.mock}
	}
	mmCreateEpisode.defaultExpectation.results = &IEpisodeRepoMockCreateEpisodeResults{i1, err}
	return mmCreateEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.CreateEpisode method
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Set(f func(episode model.Episode, idD int) (i1 int, err error)) *IEpisodeRepoMock {
	if mmCreateEpisode.defaultExpectation != nil {
		mmCreateEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.CreateEpisode method")
	}

	if len(mmCreateEpisode.expectations) > 0 {
		mmCreateEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.CreateEpisode method")
	}

	mmCreateEpisode.mock.funcCreateEpisode = f
	return mmCreateEpisode.mock
}

// When sets expectation for the IEpisodeRepo.CreateEpisode which will trigger the result defined by the following
// Then helper
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) When(episode model.Episode, idD int) *IEpisodeRepoMockCreateEpisodeExpectation {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockCreateEpisodeExpectation{
		mock:   mmCreateEpisode.mock,
		params: &IEpisodeRepoMockCreateEpisodeParams{episode, idD},
	}
	mmCreateEpisode.expectations = append(mmCreateEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.CreateEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockCreateEpisodeExpectation) Then(i1 int, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockCreateEpisodeResults{i1, err}
	return e.mock
}

// CreateEpisode implements repository.IEpisodeRepo
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisode(episode model.Episode, idD int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateEpisode.beforeCreateEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEpisode.afterCreateEpisodeCounter, 1)

	if mmCreateEpisode.inspectFuncCreateEpisode != nil {
		mmCreateEpisode.inspectFuncCreateEpisode(episode, idD)
	}

	mm_params := &IEpisodeRepoMockCreateEpisodeParams{episode, idD}

	// Record call args
	mmCreateEpisode.CreateEpisodeMock.mutex.Lock()
	mmCreateEpisode.CreateEpisodeMock.callArgs = append(mmCreateEpisode.CreateEpisodeMock.callArgs, mm_params)
	mmCreateEpisode.CreateEpisodeMock.mutex.Unlock()

	for _, e := range mmCreateEpisode.CreateEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateEpisode.CreateEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEpisode.CreateEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEpisode.CreateEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockCreateEpisodeParams{episode, idD}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEpisode.t.Errorf("IEpisodeRepoMock.CreateEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEpisode.CreateEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.CreateEpisode")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateEpisode.funcCreateEpisode != nil {
		return mmCreateEpisode.funcCreateEpisode(episode, idD)
	}
	mmCreateEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.CreateEpisode. %v %v", episode, idD)
	return
}

// CreateEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.CreateEpisode invocations
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEpisode.afterCreateEpisodeCounter)
}

// CreateEpisodeBeforeCounter returns a count of IEpisodeRepoMock.CreateEpisode invocations
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEpisode.beforeCreateEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.CreateEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Calls() []*IEpisodeRepoMockCreateEpisodeParams {
	mmCreateEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockCreateEpisodeParams, len(mmCreateEpisode.callArgs))
	copy(argCopy, mmCreateEpisode.callArgs)

	mmCreateEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEpisodeDone returns true if the count of the CreateEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockCreateEpisodeDone() bool {
	for _, e := range m.CreateEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEpisode != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockCreateEpisodeInspect() {
	for _, e := range m.CreateEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.CreateEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		if m.CreateEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.CreateEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.CreateEpisode with params: %#v", *m.CreateEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEpisode != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.CreateEpisode")
	}
}

type mIEpisodeRepoMockDeleteEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockDeleteEpisodeExpectation
	expectations       []*IEpisodeRepoMockDeleteEpisodeExpectation

	callArgs []*IEpisodeRepoMockDeleteEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockDeleteEpisodeExpectation specifies expectation struct of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockDeleteEpisodeParams
	results *IEpisodeRepoMockDeleteEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockDeleteEpisodeParams contains parameters of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeParams struct {
	id int
}

// IEpisodeRepoMockDeleteEpisodeResults contains results of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeResults struct {
	err error
}

// Expect sets up expected params for IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Expect(id int) *mIEpisodeRepoMockDeleteEpisode {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	if mmDeleteEpisode.defaultExpectation == nil {
		mmDeleteEpisode.defaultExpectation = &IEpisodeRepoMockDeleteEpisodeExpectation{}
	}

	mmDeleteEpisode.defaultExpectation.params = &IEpisodeRepoMockDeleteEpisodeParams{id}
	for _, e := range mmDeleteEpisode.expectations {
		if minimock.Equal(e.params, mmDeleteEpisode.defaultExpectation.params) {
			mmDeleteEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEpisode.defaultExpectation.params)
		}
	}

	return mmDeleteEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Inspect(f func(id int)) *mIEpisodeRepoMockDeleteEpisode {
	if mmDeleteEpisode.mock.inspectFuncDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.DeleteEpisode")
	}

	mmDeleteEpisode.mock.inspectFuncDeleteEpisode = f

	return mmDeleteEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Return(err error) *IEpisodeRepoMock {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	if mmDeleteEpisode.defaultExpectation == nil {
		mmDeleteEpisode.defaultExpectation = &IEpisodeRepoMockDeleteEpisodeExpectation{mock: mmDeleteEpisode.mock}
	}
	mmDeleteEpisode.defaultExpectation.results = &IEpisodeRepoMockDeleteEpisodeResults{err}
	return mmDeleteEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.DeleteEpisode method
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Set(f func(id int) (err error)) *IEpisodeRepoMock {
	if mmDeleteEpisode.defaultExpectation != nil {
		mmDeleteEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.DeleteEpisode method")
	}

	if len(mmDeleteEpisode.expectations) > 0 {
		mmDeleteEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.DeleteEpisode method")
	}

	mmDeleteEpisode.mock.funcDeleteEpisode = f
	return mmDeleteEpisode.mock
}

// When sets expectation for the IEpisodeRepo.DeleteEpisode which will trigger the result defined by the following
// Then helper
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) When(id int) *IEpisodeRepoMockDeleteEpisodeExpectation {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockDeleteEpisodeExpectation{
		mock:   mmDeleteEpisode.mock,
		params: &IEpisodeRepoMockDeleteEpisodeParams{id},
	}
	mmDeleteEpisode.expectations = append(mmDeleteEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.DeleteEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockDeleteEpisodeExpectation) Then(err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockDeleteEpisodeResults{err}
	return e.mock
}

// DeleteEpisode implements repository.IEpisodeRepo
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisode(id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteEpisode.beforeDeleteEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEpisode.afterDeleteEpisodeCounter, 1)

	if mmDeleteEpisode.inspectFuncDeleteEpisode != nil {
		mmDeleteEpisode.inspectFuncDeleteEpisode(id)
	}

	mm_params := &IEpisodeRepoMockDeleteEpisodeParams{id}

	// Record call args
	mmDeleteEpisode.DeleteEpisodeMock.mutex.Lock()
	mmDeleteEpisode.DeleteEpisodeMock.callArgs = append(mmDeleteEpisode.DeleteEpisodeMock.callArgs, mm_params)
	mmDeleteEpisode.DeleteEpisodeMock.mutex.Unlock()

	for _, e := range mmDeleteEpisode.DeleteEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockDeleteEpisodeParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEpisode.t.Errorf("IEpisodeRepoMock.DeleteEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.DeleteEpisode")
		}
		return (*mm_results).err
	}
	if mmDeleteEpisode.funcDeleteEpisode != nil {
		return mmDeleteEpisode.funcDeleteEpisode(id)
	}
	mmDeleteEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.DeleteEpisode. %v", id)
	return
}

// DeleteEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.DeleteEpisode invocations
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEpisode.afterDeleteEpisodeCounter)
}

// DeleteEpisodeBeforeCounter returns a count of IEpisodeRepoMock.DeleteEpisode invocations
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEpisode.beforeDeleteEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.DeleteEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Calls() []*IEpisodeRepoMockDeleteEpisodeParams {
	mmDeleteEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockDeleteEpisodeParams, len(mmDeleteEpisode.callArgs))
	copy(argCopy, mmDeleteEpisode.callArgs)

	mmDeleteEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEpisodeDone returns true if the count of the DeleteEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockDeleteEpisodeDone() bool {
	for _, e := range m.DeleteEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEpisode != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockDeleteEpisodeInspect() {
	for _, e := range m.DeleteEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.DeleteEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		if m.DeleteEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.DeleteEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.DeleteEpisode with params: %#v", *m.DeleteEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEpisode != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.DeleteEpisode")
	}
}

type mIEpisodeRepoMockGetEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockGetEpisodeExpectation
	expectations       []*IEpisodeRepoMockGetEpisodeExpectation

	callArgs []*IEpisodeRepoMockGetEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockGetEpisodeExpectation specifies expectation struct of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockGetEpisodeParams
	results *IEpisodeRepoMockGetEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockGetEpisodeParams contains parameters of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeParams struct {
	id int
}

// IEpisodeRepoMockGetEpisodeResults contains results of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeResults struct {
	ep1 *model.Episode
	err error
}

// Expect sets up expected params for IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Expect(id int) *mIEpisodeRepoMockGetEpisode {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	if mmGetEpisode.defaultExpectation == nil {
		mmGetEpisode.defaultExpectation = &IEpisodeRepoMockGetEpisodeExpectation{}
	}

	mmGetEpisode.defaultExpectation.params = &IEpisodeRepoMockGetEpisodeParams{id}
	for _, e := range mmGetEpisode.expectations {
		if minimock.Equal(e.params, mmGetEpisode.defaultExpectation.params) {
			mmGetEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEpisode.defaultExpectation.params)
		}
	}

	return mmGetEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Inspect(f func(id int)) *mIEpisodeRepoMockGetEpisode {
	if mmGetEpisode.mock.inspectFuncGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.GetEpisode")
	}

	mmGetEpisode.mock.inspectFuncGetEpisode = f

	return mmGetEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Return(ep1 *model.Episode, err error) *IEpisodeRepoMock {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	if mmGetEpisode.defaultExpectation == nil {
		mmGetEpisode.defaultExpectation = &IEpisodeRepoMockGetEpisodeExpectation{mock: mmGetEpisode.mock}
	}
	mmGetEpisode.defaultExpectation.results = &IEpisodeRepoMockGetEpisodeResults{ep1, err}
	return mmGetEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.GetEpisode method
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Set(f func(id int) (ep1 *model.Episode, err error)) *IEpisodeRepoMock {
	if mmGetEpisode.defaultExpectation != nil {
		mmGetEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.GetEpisode method")
	}

	if len(mmGetEpisode.expectations) > 0 {
		mmGetEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.GetEpisode method")
	}

	mmGetEpisode.mock.funcGetEpisode = f
	return mmGetEpisode.mock
}

// When sets expectation for the IEpisodeRepo.GetEpisode which will trigger the result defined by the following
// Then helper
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) When(id int) *IEpisodeRepoMockGetEpisodeExpectation {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockGetEpisodeExpectation{
		mock:   mmGetEpisode.mock,
		params: &IEpisodeRepoMockGetEpisodeParams{id},
	}
	mmGetEpisode.expectations = append(mmGetEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.GetEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockGetEpisodeExpectation) Then(ep1 *model.Episode, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockGetEpisodeResults{ep1, err}
	return e.mock
}

// GetEpisode implements repository.IEpisodeRepo
func (mmGetEpisode *IEpisodeRepoMock) GetEpisode(id int) (ep1 *model.Episode, err error) {
	mm_atomic.AddUint64(&mmGetEpisode.beforeGetEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEpisode.afterGetEpisodeCounter, 1)

	if mmGetEpisode.inspectFuncGetEpisode != nil {
		mmGetEpisode.inspectFuncGetEpisode(id)
	}

	mm_params := &IEpisodeRepoMockGetEpisodeParams{id}

	// Record call args
	mmGetEpisode.GetEpisodeMock.mutex.Lock()
	mmGetEpisode.GetEpisodeMock.callArgs = append(mmGetEpisode.GetEpisodeMock.callArgs, mm_params)
	mmGetEpisode.GetEpisodeMock.mutex.Unlock()

	for _, e := range mmGetEpisode.GetEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmGetEpisode.GetEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEpisode.GetEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEpisode.GetEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockGetEpisodeParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEpisode.t.Errorf("IEpisodeRepoMock.GetEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEpisode.GetEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.GetEpisode")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmGetEpisode.funcGetEpisode != nil {
		return mmGetEpisode.funcGetEpisode(id)
	}
	mmGetEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.GetEpisode. %v", id)
	return
}

// GetEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.GetEpisode invocations
func (mmGetEpisode *IEpisodeRepoMock) GetEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEpisode.afterGetEpisodeCounter)
}

// GetEpisodeBeforeCounter returns a count of IEpisodeRepoMock.GetEpisode invocations
func (mmGetEpisode *IEpisodeRepoMock) GetEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEpisode.beforeGetEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.GetEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Calls() []*IEpisodeRepoMockGetEpisodeParams {
	mmGetEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockGetEpisodeParams, len(mmGetEpisode.callArgs))
	copy(argCopy, mmGetEpisode.callArgs)

	mmGetEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockGetEpisodeDone returns true if the count of the GetEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockGetEpisodeDone() bool {
	for _, e := range m.GetEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEpisode != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockGetEpisodeInspect() {
	for _, e := range m.GetEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		if m.GetEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.GetEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetEpisode with params: %#v", *m.GetEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEpisode != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.GetEpisode")
	}
}

type mIEpisodeRepoMockGetList struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockGetListExpectation
	expectations       []*IEpisodeRepoMockGetListExpectation

	callArgs []*IEpisodeRepoMockGetListParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockGetListExpectation specifies expectation struct of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockGetListParams
	results *IEpisodeRepoMockGetListResults
	Counter uint64
}

// IEpisodeRepoMockGetListParams contains parameters of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListParams struct {
	idDorama int
}

// IEpisodeRepoMockGetListResults contains results of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListResults struct {
	ea1 []model.Episode
	err error
}

// Expect sets up expected params for IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Expect(idDorama int) *mIEpisodeRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IEpisodeRepoMockGetListExpectation{}
	}

	mmGetList.defaultExpectation.params = &IEpisodeRepoMockGetListParams{idDorama}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Inspect(f func(idDorama int)) *mIEpisodeRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Return(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IEpisodeRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &IEpisodeRepoMockGetListResults{ea1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the IEpisodeRepo.GetList method
func (mmGetList *mIEpisodeRepoMockGetList) Set(f func(idDorama int) (ea1 []model.Episode, err error)) *IEpisodeRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the IEpisodeRepo.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mIEpisodeRepoMockGetList) When(idDorama int) *IEpisodeRepoMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &IEpisodeRepoMockGetListParams{idDorama},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.GetList return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockGetListExpectation) Then(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockGetListResults{ea1, err}
	return e.mock
}

// GetList implements repository.IEpisodeRepo
func (mmGetList *IEpisodeRepoMock) GetList(idDorama int) (ea1 []model.Episode, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(idDorama)
	}

	mm_params := &IEpisodeRepoMockGetListParams{idDorama}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockGetListParams{idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("IEpisodeRepoMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the IEpisodeRepoMock.GetList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(idDorama)
	}
	mmGetList.t.Fatalf("Unexpected call to IEpisodeRepoMock.GetList. %v", idDorama)
	return
}

// GetListAfterCounter returns a count of finished IEpisodeRepoMock.GetList invocations
func (mmGetList *IEpisodeRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of IEpisodeRepoMock.GetList invocations
func (mmGetList *IEpisodeRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mIEpisodeRepoMockGetList) Calls() []*IEpisodeRepoMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.GetList")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.GetList")
	}
}

type mIEpisodeRepoMockMarkEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockMarkEpisodeExpectation
	expectations       []*IEpisodeRepoMockMarkEpisodeExpectation

	callArgs []*IEpisodeRepoMockMarkEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockMarkEpisodeExpectation specifies expectation struct of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockMarkEpisodeParams
	results *IEpisodeRepoMockMarkEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockMarkEpisodeParams contains parameters of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeParams struct {
	idEp     int
	username string
}

// IEpisodeRepoMockMarkEpisodeResults contains results of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeResults struct {
	err error
}

// Expect sets up expected params for IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Expect(idEp int, username string) *mIEpisodeRepoMockMarkEpisode {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	if mmMarkEpisode.defaultExpectation == nil {
		mmMarkEpisode.defaultExpectation = &IEpisodeRepoMockMarkEpisodeExpectation{}
	}

	mmMarkEpisode.defaultExpectation.params = &IEpisodeRepoMockMarkEpisodeParams{idEp, username}
	for _, e := range mmMarkEpisode.expectations {
		if minimock.Equal(e.params, mmMarkEpisode.defaultExpectation.params) {
			mmMarkEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkEpisode.defaultExpectation.params)
		}
	}

	return mmMarkEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Inspect(f func(idEp int, username string)) *mIEpisodeRepoMockMarkEpisode {
	if mmMarkEpisode.mock.inspectFuncMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.MarkEpisode")
	}

	mmMarkEpisode.mock.inspectFuncMarkEpisode = f

	return mmMarkEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Return(err error) *IEpisodeRepoMock {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	if mmMarkEpisode.defaultExpectation == nil {
		mmMarkEpisode.defaultExpectation = &IEpisodeRepoMockMarkEpisodeExpectation{mock: mmMarkEpisode.mock}
	}
	mmMarkEpisode.defaultExpectation.results = &IEpisodeRepoMockMarkEpisodeResults{err}
	return mmMarkEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.MarkEpisode method
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Set(f func(idEp int, username string) (err error)) *IEpisodeRepoMock {
	if mmMarkEpisode.defaultExpectation != nil {
		mmMarkEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.MarkEpisode method")
	}

	if len(mmMarkEpisode.expectations) > 0 {
		mmMarkEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.MarkEpisode method")
	}

	mmMarkEpisode.mock.funcMarkEpisode = f
	return mmMarkEpisode.mock
}

// When sets expectation for the IEpisodeRepo.MarkEpisode which will trigger the result defined by the following
// Then helper
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) When(idEp int, username string) *IEpisodeRepoMockMarkEpisodeExpectation {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockMarkEpisodeExpectation{
		mock:   mmMarkEpisode.mock,
		params: &IEpisodeRepoMockMarkEpisodeParams{idEp, username},
	}
	mmMarkEpisode.expectations = append(mmMarkEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.MarkEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockMarkEpisodeExpectation) Then(err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockMarkEpisodeResults{err}
	return e.mock
}

// MarkEpisode implements repository.IEpisodeRepo
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisode(idEp int, username string) (err error) {
	mm_atomic.AddUint64(&mmMarkEpisode.beforeMarkEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkEpisode.afterMarkEpisodeCounter, 1)

	if mmMarkEpisode.inspectFuncMarkEpisode != nil {
		mmMarkEpisode.inspectFuncMarkEpisode(idEp, username)
	}

	mm_params := &IEpisodeRepoMockMarkEpisodeParams{idEp, username}

	// Record call args
	mmMarkEpisode.MarkEpisodeMock.mutex.Lock()
	mmMarkEpisode.MarkEpisodeMock.callArgs = append(mmMarkEpisode.MarkEpisodeMock.callArgs, mm_params)
	mmMarkEpisode.MarkEpisodeMock.mutex.Unlock()

	for _, e := range mmMarkEpisode.MarkEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkEpisode.MarkEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkEpisode.MarkEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkEpisode.MarkEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockMarkEpisodeParams{idEp, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkEpisode.t.Errorf("IEpisodeRepoMock.MarkEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkEpisode.MarkEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.MarkEpisode")
		}
		return (*mm_results).err
	}
	if mmMarkEpisode.funcMarkEpisode != nil {
		return mmMarkEpisode.funcMarkEpisode(idEp, username)
	}
	mmMarkEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.MarkEpisode. %v %v", idEp, username)
	return
}

// MarkEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.MarkEpisode invocations
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkEpisode.afterMarkEpisodeCounter)
}

// MarkEpisodeBeforeCounter returns a count of IEpisodeRepoMock.MarkEpisode invocations
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkEpisode.beforeMarkEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.MarkEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Calls() []*IEpisodeRepoMockMarkEpisodeParams {
	mmMarkEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockMarkEpisodeParams, len(mmMarkEpisode.callArgs))
	copy(argCopy, mmMarkEpisode.callArgs)

	mmMarkEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockMarkEpisodeDone returns true if the count of the MarkEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockMarkEpisodeDone() bool {
	for _, e := range m.MarkEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkEpisode != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMarkEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockMarkEpisodeInspect() {
	for _, e := range m.MarkEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.MarkEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		if m.MarkEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.MarkEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.MarkEpisode with params: %#v", *m.MarkEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkEpisode != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.MarkEpisode")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IEpisodeRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateEpisodeInspect()

		m.MinimockDeleteEpisodeInspect()

		m.MinimockGetEpisodeInspect()

		m.MinimockGetListInspect()

		m.MinimockMarkEpisodeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IEpisodeRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IEpisodeRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEpisodeDone() &&
		m.MinimockDeleteEpisodeDone() &&
		m.MinimockGetEpisodeDone() &&
		m.MinimockGetListDone() &&
		m.MinimockMarkEpisodeDone()
}
