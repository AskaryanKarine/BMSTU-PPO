package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IEpisodeRepo -o ./i_episode_repo_mock_test.go -n IEpisodeRepoMock

import (
	"DoramaSet/internal/logic/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IEpisodeRepoMock implements IEpisodeRepo
type IEpisodeRepoMock struct {
	t minimock.Tester

	funcCreateEpisode          func(ctx context.Context, episode model.Episode, idD int) (i1 int, err error)
	inspectFuncCreateEpisode   func(ctx context.Context, episode model.Episode, idD int)
	afterCreateEpisodeCounter  uint64
	beforeCreateEpisodeCounter uint64
	CreateEpisodeMock          mIEpisodeRepoMockCreateEpisode

	funcDeleteEpisode          func(ctx context.Context, id int) (err error)
	inspectFuncDeleteEpisode   func(ctx context.Context, id int)
	afterDeleteEpisodeCounter  uint64
	beforeDeleteEpisodeCounter uint64
	DeleteEpisodeMock          mIEpisodeRepoMockDeleteEpisode

	funcGetEpisode          func(ctx context.Context, id int) (ep1 *model.Episode, err error)
	inspectFuncGetEpisode   func(ctx context.Context, id int)
	afterGetEpisodeCounter  uint64
	beforeGetEpisodeCounter uint64
	GetEpisodeMock          mIEpisodeRepoMockGetEpisode

	funcGetList          func(ctx context.Context, idDorama int) (ea1 []model.Episode, err error)
	inspectFuncGetList   func(ctx context.Context, idDorama int)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mIEpisodeRepoMockGetList

	funcGetWatchingList          func(ctx context.Context, username string, idD int) (ea1 []model.Episode, err error)
	inspectFuncGetWatchingList   func(ctx context.Context, username string, idD int)
	afterGetWatchingListCounter  uint64
	beforeGetWatchingListCounter uint64
	GetWatchingListMock          mIEpisodeRepoMockGetWatchingList

	funcMarkEpisode          func(ctx context.Context, idEp int, username string) (err error)
	inspectFuncMarkEpisode   func(ctx context.Context, idEp int, username string)
	afterMarkEpisodeCounter  uint64
	beforeMarkEpisodeCounter uint64
	MarkEpisodeMock          mIEpisodeRepoMockMarkEpisode
}

// NewIEpisodeRepoMock returns a mock for IEpisodeRepo
func NewIEpisodeRepoMock(t minimock.Tester) *IEpisodeRepoMock {
	m := &IEpisodeRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEpisodeMock = mIEpisodeRepoMockCreateEpisode{mock: m}
	m.CreateEpisodeMock.callArgs = []*IEpisodeRepoMockCreateEpisodeParams{}

	m.DeleteEpisodeMock = mIEpisodeRepoMockDeleteEpisode{mock: m}
	m.DeleteEpisodeMock.callArgs = []*IEpisodeRepoMockDeleteEpisodeParams{}

	m.GetEpisodeMock = mIEpisodeRepoMockGetEpisode{mock: m}
	m.GetEpisodeMock.callArgs = []*IEpisodeRepoMockGetEpisodeParams{}

	m.GetListMock = mIEpisodeRepoMockGetList{mock: m}
	m.GetListMock.callArgs = []*IEpisodeRepoMockGetListParams{}

	m.GetWatchingListMock = mIEpisodeRepoMockGetWatchingList{mock: m}
	m.GetWatchingListMock.callArgs = []*IEpisodeRepoMockGetWatchingListParams{}

	m.MarkEpisodeMock = mIEpisodeRepoMockMarkEpisode{mock: m}
	m.MarkEpisodeMock.callArgs = []*IEpisodeRepoMockMarkEpisodeParams{}

	return m
}

type mIEpisodeRepoMockCreateEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockCreateEpisodeExpectation
	expectations       []*IEpisodeRepoMockCreateEpisodeExpectation

	callArgs []*IEpisodeRepoMockCreateEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockCreateEpisodeExpectation specifies expectation struct of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockCreateEpisodeParams
	results *IEpisodeRepoMockCreateEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockCreateEpisodeParams contains parameters of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeParams struct {
	ctx     context.Context
	episode model.Episode
	idD     int
}

// IEpisodeRepoMockCreateEpisodeResults contains results of the IEpisodeRepo.CreateEpisode
type IEpisodeRepoMockCreateEpisodeResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Expect(ctx context.Context, episode model.Episode, idD int) *mIEpisodeRepoMockCreateEpisode {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	if mmCreateEpisode.defaultExpectation == nil {
		mmCreateEpisode.defaultExpectation = &IEpisodeRepoMockCreateEpisodeExpectation{}
	}

	mmCreateEpisode.defaultExpectation.params = &IEpisodeRepoMockCreateEpisodeParams{ctx, episode, idD}
	for _, e := range mmCreateEpisode.expectations {
		if minimock.Equal(e.params, mmCreateEpisode.defaultExpectation.params) {
			mmCreateEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEpisode.defaultExpectation.params)
		}
	}

	return mmCreateEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Inspect(f func(ctx context.Context, episode model.Episode, idD int)) *mIEpisodeRepoMockCreateEpisode {
	if mmCreateEpisode.mock.inspectFuncCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.CreateEpisode")
	}

	mmCreateEpisode.mock.inspectFuncCreateEpisode = f

	return mmCreateEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.CreateEpisode
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Return(i1 int, err error) *IEpisodeRepoMock {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	if mmCreateEpisode.defaultExpectation == nil {
		mmCreateEpisode.defaultExpectation = &IEpisodeRepoMockCreateEpisodeExpectation{mock: mmCreateEpisode.mock}
	}
	mmCreateEpisode.defaultExpectation.results = &IEpisodeRepoMockCreateEpisodeResults{i1, err}
	return mmCreateEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.CreateEpisode method
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Set(f func(ctx context.Context, episode model.Episode, idD int) (i1 int, err error)) *IEpisodeRepoMock {
	if mmCreateEpisode.defaultExpectation != nil {
		mmCreateEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.CreateEpisode method")
	}

	if len(mmCreateEpisode.expectations) > 0 {
		mmCreateEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.CreateEpisode method")
	}

	mmCreateEpisode.mock.funcCreateEpisode = f
	return mmCreateEpisode.mock
}

// When sets expectation for the IEpisodeRepo.CreateEpisode which will trigger the result defined by the following
// Then helper
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) When(ctx context.Context, episode model.Episode, idD int) *IEpisodeRepoMockCreateEpisodeExpectation {
	if mmCreateEpisode.mock.funcCreateEpisode != nil {
		mmCreateEpisode.mock.t.Fatalf("IEpisodeRepoMock.CreateEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockCreateEpisodeExpectation{
		mock:   mmCreateEpisode.mock,
		params: &IEpisodeRepoMockCreateEpisodeParams{ctx, episode, idD},
	}
	mmCreateEpisode.expectations = append(mmCreateEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.CreateEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockCreateEpisodeExpectation) Then(i1 int, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockCreateEpisodeResults{i1, err}
	return e.mock
}

// CreateEpisode implements IEpisodeRepo
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisode(ctx context.Context, episode model.Episode, idD int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateEpisode.beforeCreateEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEpisode.afterCreateEpisodeCounter, 1)

	if mmCreateEpisode.inspectFuncCreateEpisode != nil {
		mmCreateEpisode.inspectFuncCreateEpisode(ctx, episode, idD)
	}

	mm_params := &IEpisodeRepoMockCreateEpisodeParams{ctx, episode, idD}

	// Record call args
	mmCreateEpisode.CreateEpisodeMock.mutex.Lock()
	mmCreateEpisode.CreateEpisodeMock.callArgs = append(mmCreateEpisode.CreateEpisodeMock.callArgs, mm_params)
	mmCreateEpisode.CreateEpisodeMock.mutex.Unlock()

	for _, e := range mmCreateEpisode.CreateEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateEpisode.CreateEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEpisode.CreateEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEpisode.CreateEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockCreateEpisodeParams{ctx, episode, idD}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEpisode.t.Errorf("IEpisodeRepoMock.CreateEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEpisode.CreateEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.CreateEpisode")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateEpisode.funcCreateEpisode != nil {
		return mmCreateEpisode.funcCreateEpisode(ctx, episode, idD)
	}
	mmCreateEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.CreateEpisode. %v %v %v", ctx, episode, idD)
	return
}

// CreateEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.CreateEpisode invocations
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEpisode.afterCreateEpisodeCounter)
}

// CreateEpisodeBeforeCounter returns a count of IEpisodeRepoMock.CreateEpisode invocations
func (mmCreateEpisode *IEpisodeRepoMock) CreateEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEpisode.beforeCreateEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.CreateEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEpisode *mIEpisodeRepoMockCreateEpisode) Calls() []*IEpisodeRepoMockCreateEpisodeParams {
	mmCreateEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockCreateEpisodeParams, len(mmCreateEpisode.callArgs))
	copy(argCopy, mmCreateEpisode.callArgs)

	mmCreateEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEpisodeDone returns true if the count of the CreateEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockCreateEpisodeDone() bool {
	for _, e := range m.CreateEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEpisode != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockCreateEpisodeInspect() {
	for _, e := range m.CreateEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.CreateEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		if m.CreateEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.CreateEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.CreateEpisode with params: %#v", *m.CreateEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEpisode != nil && mm_atomic.LoadUint64(&m.afterCreateEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.CreateEpisode")
	}
}

type mIEpisodeRepoMockDeleteEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockDeleteEpisodeExpectation
	expectations       []*IEpisodeRepoMockDeleteEpisodeExpectation

	callArgs []*IEpisodeRepoMockDeleteEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockDeleteEpisodeExpectation specifies expectation struct of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockDeleteEpisodeParams
	results *IEpisodeRepoMockDeleteEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockDeleteEpisodeParams contains parameters of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeParams struct {
	ctx context.Context
	id  int
}

// IEpisodeRepoMockDeleteEpisodeResults contains results of the IEpisodeRepo.DeleteEpisode
type IEpisodeRepoMockDeleteEpisodeResults struct {
	err error
}

// Expect sets up expected params for IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Expect(ctx context.Context, id int) *mIEpisodeRepoMockDeleteEpisode {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	if mmDeleteEpisode.defaultExpectation == nil {
		mmDeleteEpisode.defaultExpectation = &IEpisodeRepoMockDeleteEpisodeExpectation{}
	}

	mmDeleteEpisode.defaultExpectation.params = &IEpisodeRepoMockDeleteEpisodeParams{ctx, id}
	for _, e := range mmDeleteEpisode.expectations {
		if minimock.Equal(e.params, mmDeleteEpisode.defaultExpectation.params) {
			mmDeleteEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEpisode.defaultExpectation.params)
		}
	}

	return mmDeleteEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Inspect(f func(ctx context.Context, id int)) *mIEpisodeRepoMockDeleteEpisode {
	if mmDeleteEpisode.mock.inspectFuncDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.DeleteEpisode")
	}

	mmDeleteEpisode.mock.inspectFuncDeleteEpisode = f

	return mmDeleteEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.DeleteEpisode
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Return(err error) *IEpisodeRepoMock {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	if mmDeleteEpisode.defaultExpectation == nil {
		mmDeleteEpisode.defaultExpectation = &IEpisodeRepoMockDeleteEpisodeExpectation{mock: mmDeleteEpisode.mock}
	}
	mmDeleteEpisode.defaultExpectation.results = &IEpisodeRepoMockDeleteEpisodeResults{err}
	return mmDeleteEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.DeleteEpisode method
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Set(f func(ctx context.Context, id int) (err error)) *IEpisodeRepoMock {
	if mmDeleteEpisode.defaultExpectation != nil {
		mmDeleteEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.DeleteEpisode method")
	}

	if len(mmDeleteEpisode.expectations) > 0 {
		mmDeleteEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.DeleteEpisode method")
	}

	mmDeleteEpisode.mock.funcDeleteEpisode = f
	return mmDeleteEpisode.mock
}

// When sets expectation for the IEpisodeRepo.DeleteEpisode which will trigger the result defined by the following
// Then helper
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) When(ctx context.Context, id int) *IEpisodeRepoMockDeleteEpisodeExpectation {
	if mmDeleteEpisode.mock.funcDeleteEpisode != nil {
		mmDeleteEpisode.mock.t.Fatalf("IEpisodeRepoMock.DeleteEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockDeleteEpisodeExpectation{
		mock:   mmDeleteEpisode.mock,
		params: &IEpisodeRepoMockDeleteEpisodeParams{ctx, id},
	}
	mmDeleteEpisode.expectations = append(mmDeleteEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.DeleteEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockDeleteEpisodeExpectation) Then(err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockDeleteEpisodeResults{err}
	return e.mock
}

// DeleteEpisode implements IEpisodeRepo
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisode(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteEpisode.beforeDeleteEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEpisode.afterDeleteEpisodeCounter, 1)

	if mmDeleteEpisode.inspectFuncDeleteEpisode != nil {
		mmDeleteEpisode.inspectFuncDeleteEpisode(ctx, id)
	}

	mm_params := &IEpisodeRepoMockDeleteEpisodeParams{ctx, id}

	// Record call args
	mmDeleteEpisode.DeleteEpisodeMock.mutex.Lock()
	mmDeleteEpisode.DeleteEpisodeMock.callArgs = append(mmDeleteEpisode.DeleteEpisodeMock.callArgs, mm_params)
	mmDeleteEpisode.DeleteEpisodeMock.mutex.Unlock()

	for _, e := range mmDeleteEpisode.DeleteEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockDeleteEpisodeParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEpisode.t.Errorf("IEpisodeRepoMock.DeleteEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEpisode.DeleteEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.DeleteEpisode")
		}
		return (*mm_results).err
	}
	if mmDeleteEpisode.funcDeleteEpisode != nil {
		return mmDeleteEpisode.funcDeleteEpisode(ctx, id)
	}
	mmDeleteEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.DeleteEpisode. %v %v", ctx, id)
	return
}

// DeleteEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.DeleteEpisode invocations
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEpisode.afterDeleteEpisodeCounter)
}

// DeleteEpisodeBeforeCounter returns a count of IEpisodeRepoMock.DeleteEpisode invocations
func (mmDeleteEpisode *IEpisodeRepoMock) DeleteEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEpisode.beforeDeleteEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.DeleteEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEpisode *mIEpisodeRepoMockDeleteEpisode) Calls() []*IEpisodeRepoMockDeleteEpisodeParams {
	mmDeleteEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockDeleteEpisodeParams, len(mmDeleteEpisode.callArgs))
	copy(argCopy, mmDeleteEpisode.callArgs)

	mmDeleteEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEpisodeDone returns true if the count of the DeleteEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockDeleteEpisodeDone() bool {
	for _, e := range m.DeleteEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEpisode != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockDeleteEpisodeInspect() {
	for _, e := range m.DeleteEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.DeleteEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		if m.DeleteEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.DeleteEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.DeleteEpisode with params: %#v", *m.DeleteEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEpisode != nil && mm_atomic.LoadUint64(&m.afterDeleteEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.DeleteEpisode")
	}
}

type mIEpisodeRepoMockGetEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockGetEpisodeExpectation
	expectations       []*IEpisodeRepoMockGetEpisodeExpectation

	callArgs []*IEpisodeRepoMockGetEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockGetEpisodeExpectation specifies expectation struct of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockGetEpisodeParams
	results *IEpisodeRepoMockGetEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockGetEpisodeParams contains parameters of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeParams struct {
	ctx context.Context
	id  int
}

// IEpisodeRepoMockGetEpisodeResults contains results of the IEpisodeRepo.GetEpisode
type IEpisodeRepoMockGetEpisodeResults struct {
	ep1 *model.Episode
	err error
}

// Expect sets up expected params for IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Expect(ctx context.Context, id int) *mIEpisodeRepoMockGetEpisode {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	if mmGetEpisode.defaultExpectation == nil {
		mmGetEpisode.defaultExpectation = &IEpisodeRepoMockGetEpisodeExpectation{}
	}

	mmGetEpisode.defaultExpectation.params = &IEpisodeRepoMockGetEpisodeParams{ctx, id}
	for _, e := range mmGetEpisode.expectations {
		if minimock.Equal(e.params, mmGetEpisode.defaultExpectation.params) {
			mmGetEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEpisode.defaultExpectation.params)
		}
	}

	return mmGetEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Inspect(f func(ctx context.Context, id int)) *mIEpisodeRepoMockGetEpisode {
	if mmGetEpisode.mock.inspectFuncGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.GetEpisode")
	}

	mmGetEpisode.mock.inspectFuncGetEpisode = f

	return mmGetEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.GetEpisode
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Return(ep1 *model.Episode, err error) *IEpisodeRepoMock {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	if mmGetEpisode.defaultExpectation == nil {
		mmGetEpisode.defaultExpectation = &IEpisodeRepoMockGetEpisodeExpectation{mock: mmGetEpisode.mock}
	}
	mmGetEpisode.defaultExpectation.results = &IEpisodeRepoMockGetEpisodeResults{ep1, err}
	return mmGetEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.GetEpisode method
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Set(f func(ctx context.Context, id int) (ep1 *model.Episode, err error)) *IEpisodeRepoMock {
	if mmGetEpisode.defaultExpectation != nil {
		mmGetEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.GetEpisode method")
	}

	if len(mmGetEpisode.expectations) > 0 {
		mmGetEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.GetEpisode method")
	}

	mmGetEpisode.mock.funcGetEpisode = f
	return mmGetEpisode.mock
}

// When sets expectation for the IEpisodeRepo.GetEpisode which will trigger the result defined by the following
// Then helper
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) When(ctx context.Context, id int) *IEpisodeRepoMockGetEpisodeExpectation {
	if mmGetEpisode.mock.funcGetEpisode != nil {
		mmGetEpisode.mock.t.Fatalf("IEpisodeRepoMock.GetEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockGetEpisodeExpectation{
		mock:   mmGetEpisode.mock,
		params: &IEpisodeRepoMockGetEpisodeParams{ctx, id},
	}
	mmGetEpisode.expectations = append(mmGetEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.GetEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockGetEpisodeExpectation) Then(ep1 *model.Episode, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockGetEpisodeResults{ep1, err}
	return e.mock
}

// GetEpisode implements IEpisodeRepo
func (mmGetEpisode *IEpisodeRepoMock) GetEpisode(ctx context.Context, id int) (ep1 *model.Episode, err error) {
	mm_atomic.AddUint64(&mmGetEpisode.beforeGetEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEpisode.afterGetEpisodeCounter, 1)

	if mmGetEpisode.inspectFuncGetEpisode != nil {
		mmGetEpisode.inspectFuncGetEpisode(ctx, id)
	}

	mm_params := &IEpisodeRepoMockGetEpisodeParams{ctx, id}

	// Record call args
	mmGetEpisode.GetEpisodeMock.mutex.Lock()
	mmGetEpisode.GetEpisodeMock.callArgs = append(mmGetEpisode.GetEpisodeMock.callArgs, mm_params)
	mmGetEpisode.GetEpisodeMock.mutex.Unlock()

	for _, e := range mmGetEpisode.GetEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmGetEpisode.GetEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEpisode.GetEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEpisode.GetEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockGetEpisodeParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEpisode.t.Errorf("IEpisodeRepoMock.GetEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEpisode.GetEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.GetEpisode")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmGetEpisode.funcGetEpisode != nil {
		return mmGetEpisode.funcGetEpisode(ctx, id)
	}
	mmGetEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.GetEpisode. %v %v", ctx, id)
	return
}

// GetEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.GetEpisode invocations
func (mmGetEpisode *IEpisodeRepoMock) GetEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEpisode.afterGetEpisodeCounter)
}

// GetEpisodeBeforeCounter returns a count of IEpisodeRepoMock.GetEpisode invocations
func (mmGetEpisode *IEpisodeRepoMock) GetEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEpisode.beforeGetEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.GetEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEpisode *mIEpisodeRepoMockGetEpisode) Calls() []*IEpisodeRepoMockGetEpisodeParams {
	mmGetEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockGetEpisodeParams, len(mmGetEpisode.callArgs))
	copy(argCopy, mmGetEpisode.callArgs)

	mmGetEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockGetEpisodeDone returns true if the count of the GetEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockGetEpisodeDone() bool {
	for _, e := range m.GetEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEpisode != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockGetEpisodeInspect() {
	for _, e := range m.GetEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		if m.GetEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.GetEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetEpisode with params: %#v", *m.GetEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEpisode != nil && mm_atomic.LoadUint64(&m.afterGetEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.GetEpisode")
	}
}

type mIEpisodeRepoMockGetList struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockGetListExpectation
	expectations       []*IEpisodeRepoMockGetListExpectation

	callArgs []*IEpisodeRepoMockGetListParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockGetListExpectation specifies expectation struct of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockGetListParams
	results *IEpisodeRepoMockGetListResults
	Counter uint64
}

// IEpisodeRepoMockGetListParams contains parameters of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListParams struct {
	ctx      context.Context
	idDorama int
}

// IEpisodeRepoMockGetListResults contains results of the IEpisodeRepo.GetList
type IEpisodeRepoMockGetListResults struct {
	ea1 []model.Episode
	err error
}

// Expect sets up expected params for IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Expect(ctx context.Context, idDorama int) *mIEpisodeRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IEpisodeRepoMockGetListExpectation{}
	}

	mmGetList.defaultExpectation.params = &IEpisodeRepoMockGetListParams{ctx, idDorama}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Inspect(f func(ctx context.Context, idDorama int)) *mIEpisodeRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by IEpisodeRepo.GetList
func (mmGetList *mIEpisodeRepoMockGetList) Return(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IEpisodeRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &IEpisodeRepoMockGetListResults{ea1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the IEpisodeRepo.GetList method
func (mmGetList *mIEpisodeRepoMockGetList) Set(f func(ctx context.Context, idDorama int) (ea1 []model.Episode, err error)) *IEpisodeRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the IEpisodeRepo.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mIEpisodeRepoMockGetList) When(ctx context.Context, idDorama int) *IEpisodeRepoMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IEpisodeRepoMock.GetList mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &IEpisodeRepoMockGetListParams{ctx, idDorama},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.GetList return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockGetListExpectation) Then(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockGetListResults{ea1, err}
	return e.mock
}

// GetList implements IEpisodeRepo
func (mmGetList *IEpisodeRepoMock) GetList(ctx context.Context, idDorama int) (ea1 []model.Episode, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(ctx, idDorama)
	}

	mm_params := &IEpisodeRepoMockGetListParams{ctx, idDorama}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockGetListParams{ctx, idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("IEpisodeRepoMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the IEpisodeRepoMock.GetList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(ctx, idDorama)
	}
	mmGetList.t.Fatalf("Unexpected call to IEpisodeRepoMock.GetList. %v %v", ctx, idDorama)
	return
}

// GetListAfterCounter returns a count of finished IEpisodeRepoMock.GetList invocations
func (mmGetList *IEpisodeRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of IEpisodeRepoMock.GetList invocations
func (mmGetList *IEpisodeRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mIEpisodeRepoMockGetList) Calls() []*IEpisodeRepoMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.GetList")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.GetList")
	}
}

type mIEpisodeRepoMockGetWatchingList struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockGetWatchingListExpectation
	expectations       []*IEpisodeRepoMockGetWatchingListExpectation

	callArgs []*IEpisodeRepoMockGetWatchingListParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockGetWatchingListExpectation specifies expectation struct of the IEpisodeRepo.GetWatchingList
type IEpisodeRepoMockGetWatchingListExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockGetWatchingListParams
	results *IEpisodeRepoMockGetWatchingListResults
	Counter uint64
}

// IEpisodeRepoMockGetWatchingListParams contains parameters of the IEpisodeRepo.GetWatchingList
type IEpisodeRepoMockGetWatchingListParams struct {
	ctx      context.Context
	username string
	idD      int
}

// IEpisodeRepoMockGetWatchingListResults contains results of the IEpisodeRepo.GetWatchingList
type IEpisodeRepoMockGetWatchingListResults struct {
	ea1 []model.Episode
	err error
}

// Expect sets up expected params for IEpisodeRepo.GetWatchingList
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) Expect(ctx context.Context, username string, idD int) *mIEpisodeRepoMockGetWatchingList {
	if mmGetWatchingList.mock.funcGetWatchingList != nil {
		mmGetWatchingList.mock.t.Fatalf("IEpisodeRepoMock.GetWatchingList mock is already set by Set")
	}

	if mmGetWatchingList.defaultExpectation == nil {
		mmGetWatchingList.defaultExpectation = &IEpisodeRepoMockGetWatchingListExpectation{}
	}

	mmGetWatchingList.defaultExpectation.params = &IEpisodeRepoMockGetWatchingListParams{ctx, username, idD}
	for _, e := range mmGetWatchingList.expectations {
		if minimock.Equal(e.params, mmGetWatchingList.defaultExpectation.params) {
			mmGetWatchingList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWatchingList.defaultExpectation.params)
		}
	}

	return mmGetWatchingList
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.GetWatchingList
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) Inspect(f func(ctx context.Context, username string, idD int)) *mIEpisodeRepoMockGetWatchingList {
	if mmGetWatchingList.mock.inspectFuncGetWatchingList != nil {
		mmGetWatchingList.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.GetWatchingList")
	}

	mmGetWatchingList.mock.inspectFuncGetWatchingList = f

	return mmGetWatchingList
}

// Return sets up results that will be returned by IEpisodeRepo.GetWatchingList
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) Return(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	if mmGetWatchingList.mock.funcGetWatchingList != nil {
		mmGetWatchingList.mock.t.Fatalf("IEpisodeRepoMock.GetWatchingList mock is already set by Set")
	}

	if mmGetWatchingList.defaultExpectation == nil {
		mmGetWatchingList.defaultExpectation = &IEpisodeRepoMockGetWatchingListExpectation{mock: mmGetWatchingList.mock}
	}
	mmGetWatchingList.defaultExpectation.results = &IEpisodeRepoMockGetWatchingListResults{ea1, err}
	return mmGetWatchingList.mock
}

// Set uses given function f to mock the IEpisodeRepo.GetWatchingList method
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) Set(f func(ctx context.Context, username string, idD int) (ea1 []model.Episode, err error)) *IEpisodeRepoMock {
	if mmGetWatchingList.defaultExpectation != nil {
		mmGetWatchingList.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.GetWatchingList method")
	}

	if len(mmGetWatchingList.expectations) > 0 {
		mmGetWatchingList.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.GetWatchingList method")
	}

	mmGetWatchingList.mock.funcGetWatchingList = f
	return mmGetWatchingList.mock
}

// When sets expectation for the IEpisodeRepo.GetWatchingList which will trigger the result defined by the following
// Then helper
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) When(ctx context.Context, username string, idD int) *IEpisodeRepoMockGetWatchingListExpectation {
	if mmGetWatchingList.mock.funcGetWatchingList != nil {
		mmGetWatchingList.mock.t.Fatalf("IEpisodeRepoMock.GetWatchingList mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockGetWatchingListExpectation{
		mock:   mmGetWatchingList.mock,
		params: &IEpisodeRepoMockGetWatchingListParams{ctx, username, idD},
	}
	mmGetWatchingList.expectations = append(mmGetWatchingList.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.GetWatchingList return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockGetWatchingListExpectation) Then(ea1 []model.Episode, err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockGetWatchingListResults{ea1, err}
	return e.mock
}

// GetWatchingList implements IEpisodeRepo
func (mmGetWatchingList *IEpisodeRepoMock) GetWatchingList(ctx context.Context, username string, idD int) (ea1 []model.Episode, err error) {
	mm_atomic.AddUint64(&mmGetWatchingList.beforeGetWatchingListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWatchingList.afterGetWatchingListCounter, 1)

	if mmGetWatchingList.inspectFuncGetWatchingList != nil {
		mmGetWatchingList.inspectFuncGetWatchingList(ctx, username, idD)
	}

	mm_params := &IEpisodeRepoMockGetWatchingListParams{ctx, username, idD}

	// Record call args
	mmGetWatchingList.GetWatchingListMock.mutex.Lock()
	mmGetWatchingList.GetWatchingListMock.callArgs = append(mmGetWatchingList.GetWatchingListMock.callArgs, mm_params)
	mmGetWatchingList.GetWatchingListMock.mutex.Unlock()

	for _, e := range mmGetWatchingList.GetWatchingListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetWatchingList.GetWatchingListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWatchingList.GetWatchingListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWatchingList.GetWatchingListMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockGetWatchingListParams{ctx, username, idD}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWatchingList.t.Errorf("IEpisodeRepoMock.GetWatchingList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWatchingList.GetWatchingListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWatchingList.t.Fatal("No results are set for the IEpisodeRepoMock.GetWatchingList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetWatchingList.funcGetWatchingList != nil {
		return mmGetWatchingList.funcGetWatchingList(ctx, username, idD)
	}
	mmGetWatchingList.t.Fatalf("Unexpected call to IEpisodeRepoMock.GetWatchingList. %v %v %v", ctx, username, idD)
	return
}

// GetWatchingListAfterCounter returns a count of finished IEpisodeRepoMock.GetWatchingList invocations
func (mmGetWatchingList *IEpisodeRepoMock) GetWatchingListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWatchingList.afterGetWatchingListCounter)
}

// GetWatchingListBeforeCounter returns a count of IEpisodeRepoMock.GetWatchingList invocations
func (mmGetWatchingList *IEpisodeRepoMock) GetWatchingListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWatchingList.beforeGetWatchingListCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.GetWatchingList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWatchingList *mIEpisodeRepoMockGetWatchingList) Calls() []*IEpisodeRepoMockGetWatchingListParams {
	mmGetWatchingList.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockGetWatchingListParams, len(mmGetWatchingList.callArgs))
	copy(argCopy, mmGetWatchingList.callArgs)

	mmGetWatchingList.mutex.RUnlock()

	return argCopy
}

// MinimockGetWatchingListDone returns true if the count of the GetWatchingList invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockGetWatchingListDone() bool {
	for _, e := range m.GetWatchingListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWatchingListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWatchingListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWatchingList != nil && mm_atomic.LoadUint64(&m.afterGetWatchingListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWatchingListInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockGetWatchingListInspect() {
	for _, e := range m.GetWatchingListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetWatchingList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWatchingListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWatchingListCounter) < 1 {
		if m.GetWatchingListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.GetWatchingList")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.GetWatchingList with params: %#v", *m.GetWatchingListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWatchingList != nil && mm_atomic.LoadUint64(&m.afterGetWatchingListCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.GetWatchingList")
	}
}

type mIEpisodeRepoMockMarkEpisode struct {
	mock               *IEpisodeRepoMock
	defaultExpectation *IEpisodeRepoMockMarkEpisodeExpectation
	expectations       []*IEpisodeRepoMockMarkEpisodeExpectation

	callArgs []*IEpisodeRepoMockMarkEpisodeParams
	mutex    sync.RWMutex
}

// IEpisodeRepoMockMarkEpisodeExpectation specifies expectation struct of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeExpectation struct {
	mock    *IEpisodeRepoMock
	params  *IEpisodeRepoMockMarkEpisodeParams
	results *IEpisodeRepoMockMarkEpisodeResults
	Counter uint64
}

// IEpisodeRepoMockMarkEpisodeParams contains parameters of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeParams struct {
	ctx      context.Context
	idEp     int
	username string
}

// IEpisodeRepoMockMarkEpisodeResults contains results of the IEpisodeRepo.MarkEpisode
type IEpisodeRepoMockMarkEpisodeResults struct {
	err error
}

// Expect sets up expected params for IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Expect(ctx context.Context, idEp int, username string) *mIEpisodeRepoMockMarkEpisode {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	if mmMarkEpisode.defaultExpectation == nil {
		mmMarkEpisode.defaultExpectation = &IEpisodeRepoMockMarkEpisodeExpectation{}
	}

	mmMarkEpisode.defaultExpectation.params = &IEpisodeRepoMockMarkEpisodeParams{ctx, idEp, username}
	for _, e := range mmMarkEpisode.expectations {
		if minimock.Equal(e.params, mmMarkEpisode.defaultExpectation.params) {
			mmMarkEpisode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkEpisode.defaultExpectation.params)
		}
	}

	return mmMarkEpisode
}

// Inspect accepts an inspector function that has same arguments as the IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Inspect(f func(ctx context.Context, idEp int, username string)) *mIEpisodeRepoMockMarkEpisode {
	if mmMarkEpisode.mock.inspectFuncMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("Inspect function is already set for IEpisodeRepoMock.MarkEpisode")
	}

	mmMarkEpisode.mock.inspectFuncMarkEpisode = f

	return mmMarkEpisode
}

// Return sets up results that will be returned by IEpisodeRepo.MarkEpisode
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Return(err error) *IEpisodeRepoMock {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	if mmMarkEpisode.defaultExpectation == nil {
		mmMarkEpisode.defaultExpectation = &IEpisodeRepoMockMarkEpisodeExpectation{mock: mmMarkEpisode.mock}
	}
	mmMarkEpisode.defaultExpectation.results = &IEpisodeRepoMockMarkEpisodeResults{err}
	return mmMarkEpisode.mock
}

// Set uses given function f to mock the IEpisodeRepo.MarkEpisode method
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Set(f func(ctx context.Context, idEp int, username string) (err error)) *IEpisodeRepoMock {
	if mmMarkEpisode.defaultExpectation != nil {
		mmMarkEpisode.mock.t.Fatalf("Default expectation is already set for the IEpisodeRepo.MarkEpisode method")
	}

	if len(mmMarkEpisode.expectations) > 0 {
		mmMarkEpisode.mock.t.Fatalf("Some expectations are already set for the IEpisodeRepo.MarkEpisode method")
	}

	mmMarkEpisode.mock.funcMarkEpisode = f
	return mmMarkEpisode.mock
}

// When sets expectation for the IEpisodeRepo.MarkEpisode which will trigger the result defined by the following
// Then helper
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) When(ctx context.Context, idEp int, username string) *IEpisodeRepoMockMarkEpisodeExpectation {
	if mmMarkEpisode.mock.funcMarkEpisode != nil {
		mmMarkEpisode.mock.t.Fatalf("IEpisodeRepoMock.MarkEpisode mock is already set by Set")
	}

	expectation := &IEpisodeRepoMockMarkEpisodeExpectation{
		mock:   mmMarkEpisode.mock,
		params: &IEpisodeRepoMockMarkEpisodeParams{ctx, idEp, username},
	}
	mmMarkEpisode.expectations = append(mmMarkEpisode.expectations, expectation)
	return expectation
}

// Then sets up IEpisodeRepo.MarkEpisode return parameters for the expectation previously defined by the When method
func (e *IEpisodeRepoMockMarkEpisodeExpectation) Then(err error) *IEpisodeRepoMock {
	e.results = &IEpisodeRepoMockMarkEpisodeResults{err}
	return e.mock
}

// MarkEpisode implements IEpisodeRepo
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisode(ctx context.Context, idEp int, username string) (err error) {
	mm_atomic.AddUint64(&mmMarkEpisode.beforeMarkEpisodeCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkEpisode.afterMarkEpisodeCounter, 1)

	if mmMarkEpisode.inspectFuncMarkEpisode != nil {
		mmMarkEpisode.inspectFuncMarkEpisode(ctx, idEp, username)
	}

	mm_params := &IEpisodeRepoMockMarkEpisodeParams{ctx, idEp, username}

	// Record call args
	mmMarkEpisode.MarkEpisodeMock.mutex.Lock()
	mmMarkEpisode.MarkEpisodeMock.callArgs = append(mmMarkEpisode.MarkEpisodeMock.callArgs, mm_params)
	mmMarkEpisode.MarkEpisodeMock.mutex.Unlock()

	for _, e := range mmMarkEpisode.MarkEpisodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkEpisode.MarkEpisodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkEpisode.MarkEpisodeMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkEpisode.MarkEpisodeMock.defaultExpectation.params
		mm_got := IEpisodeRepoMockMarkEpisodeParams{ctx, idEp, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkEpisode.t.Errorf("IEpisodeRepoMock.MarkEpisode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkEpisode.MarkEpisodeMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkEpisode.t.Fatal("No results are set for the IEpisodeRepoMock.MarkEpisode")
		}
		return (*mm_results).err
	}
	if mmMarkEpisode.funcMarkEpisode != nil {
		return mmMarkEpisode.funcMarkEpisode(ctx, idEp, username)
	}
	mmMarkEpisode.t.Fatalf("Unexpected call to IEpisodeRepoMock.MarkEpisode. %v %v %v", ctx, idEp, username)
	return
}

// MarkEpisodeAfterCounter returns a count of finished IEpisodeRepoMock.MarkEpisode invocations
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkEpisode.afterMarkEpisodeCounter)
}

// MarkEpisodeBeforeCounter returns a count of IEpisodeRepoMock.MarkEpisode invocations
func (mmMarkEpisode *IEpisodeRepoMock) MarkEpisodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkEpisode.beforeMarkEpisodeCounter)
}

// Calls returns a list of arguments used in each call to IEpisodeRepoMock.MarkEpisode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkEpisode *mIEpisodeRepoMockMarkEpisode) Calls() []*IEpisodeRepoMockMarkEpisodeParams {
	mmMarkEpisode.mutex.RLock()

	argCopy := make([]*IEpisodeRepoMockMarkEpisodeParams, len(mmMarkEpisode.callArgs))
	copy(argCopy, mmMarkEpisode.callArgs)

	mmMarkEpisode.mutex.RUnlock()

	return argCopy
}

// MinimockMarkEpisodeDone returns true if the count of the MarkEpisode invocations corresponds
// the number of defined expectations
func (m *IEpisodeRepoMock) MinimockMarkEpisodeDone() bool {
	for _, e := range m.MarkEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkEpisode != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMarkEpisodeInspect logs each unmet expectation
func (m *IEpisodeRepoMock) MinimockMarkEpisodeInspect() {
	for _, e := range m.MarkEpisodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEpisodeRepoMock.MarkEpisode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkEpisodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		if m.MarkEpisodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IEpisodeRepoMock.MarkEpisode")
		} else {
			m.t.Errorf("Expected call to IEpisodeRepoMock.MarkEpisode with params: %#v", *m.MarkEpisodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkEpisode != nil && mm_atomic.LoadUint64(&m.afterMarkEpisodeCounter) < 1 {
		m.t.Error("Expected call to IEpisodeRepoMock.MarkEpisode")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IEpisodeRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateEpisodeInspect()

		m.MinimockDeleteEpisodeInspect()

		m.MinimockGetEpisodeInspect()

		m.MinimockGetListInspect()

		m.MinimockGetWatchingListInspect()

		m.MinimockMarkEpisodeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IEpisodeRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IEpisodeRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEpisodeDone() &&
		m.MinimockDeleteEpisodeDone() &&
		m.MinimockGetEpisodeDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetWatchingListDone() &&
		m.MinimockMarkEpisodeDone()
}
