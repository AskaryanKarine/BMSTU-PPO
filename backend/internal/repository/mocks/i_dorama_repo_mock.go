package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IDoramaRepo -o ..\..\repository\mocks\i_dorama_repo_mock.go -n IDoramaRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IDoramaRepoMock implements repository.IDoramaRepo
type IDoramaRepoMock struct {
	t minimock.Tester

	funcAddStaff          func(idD int, idS int) (err error)
	inspectFuncAddStaff   func(idD int, idS int)
	afterAddStaffCounter  uint64
	beforeAddStaffCounter uint64
	AddStaffMock          mIDoramaRepoMockAddStaff

	funcCreateDorama          func(dorama model.Dorama) (i1 int, err error)
	inspectFuncCreateDorama   func(dorama model.Dorama)
	afterCreateDoramaCounter  uint64
	beforeCreateDoramaCounter uint64
	CreateDoramaMock          mIDoramaRepoMockCreateDorama

	funcDeleteDorama          func(id int) (err error)
	inspectFuncDeleteDorama   func(id int)
	afterDeleteDoramaCounter  uint64
	beforeDeleteDoramaCounter uint64
	DeleteDoramaMock          mIDoramaRepoMockDeleteDorama

	funcGetDorama          func(id int) (dp1 *model.Dorama, err error)
	inspectFuncGetDorama   func(id int)
	afterGetDoramaCounter  uint64
	beforeGetDoramaCounter uint64
	GetDoramaMock          mIDoramaRepoMockGetDorama

	funcGetList          func() (da1 []model.Dorama, err error)
	inspectFuncGetList   func()
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mIDoramaRepoMockGetList

	funcGetListByListId          func(idL int) (da1 []model.Dorama, err error)
	inspectFuncGetListByListId   func(idL int)
	afterGetListByListIdCounter  uint64
	beforeGetListByListIdCounter uint64
	GetListByListIdMock          mIDoramaRepoMockGetListByListId

	funcGetListName          func(name string) (da1 []model.Dorama, err error)
	inspectFuncGetListName   func(name string)
	afterGetListNameCounter  uint64
	beforeGetListNameCounter uint64
	GetListNameMock          mIDoramaRepoMockGetListName

	funcUpdateDorama          func(dorama model.Dorama) (err error)
	inspectFuncUpdateDorama   func(dorama model.Dorama)
	afterUpdateDoramaCounter  uint64
	beforeUpdateDoramaCounter uint64
	UpdateDoramaMock          mIDoramaRepoMockUpdateDorama
}

// NewIDoramaRepoMock returns a mock for repository.IDoramaRepo
func NewIDoramaRepoMock(t minimock.Tester) *IDoramaRepoMock {
	m := &IDoramaRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddStaffMock = mIDoramaRepoMockAddStaff{mock: m}
	m.AddStaffMock.callArgs = []*IDoramaRepoMockAddStaffParams{}

	m.CreateDoramaMock = mIDoramaRepoMockCreateDorama{mock: m}
	m.CreateDoramaMock.callArgs = []*IDoramaRepoMockCreateDoramaParams{}

	m.DeleteDoramaMock = mIDoramaRepoMockDeleteDorama{mock: m}
	m.DeleteDoramaMock.callArgs = []*IDoramaRepoMockDeleteDoramaParams{}

	m.GetDoramaMock = mIDoramaRepoMockGetDorama{mock: m}
	m.GetDoramaMock.callArgs = []*IDoramaRepoMockGetDoramaParams{}

	m.GetListMock = mIDoramaRepoMockGetList{mock: m}

	m.GetListByListIdMock = mIDoramaRepoMockGetListByListId{mock: m}
	m.GetListByListIdMock.callArgs = []*IDoramaRepoMockGetListByListIdParams{}

	m.GetListNameMock = mIDoramaRepoMockGetListName{mock: m}
	m.GetListNameMock.callArgs = []*IDoramaRepoMockGetListNameParams{}

	m.UpdateDoramaMock = mIDoramaRepoMockUpdateDorama{mock: m}
	m.UpdateDoramaMock.callArgs = []*IDoramaRepoMockUpdateDoramaParams{}

	return m
}

type mIDoramaRepoMockAddStaff struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockAddStaffExpectation
	expectations       []*IDoramaRepoMockAddStaffExpectation

	callArgs []*IDoramaRepoMockAddStaffParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockAddStaffExpectation specifies expectation struct of the IDoramaRepo.AddStaff
type IDoramaRepoMockAddStaffExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockAddStaffParams
	results *IDoramaRepoMockAddStaffResults
	Counter uint64
}

// IDoramaRepoMockAddStaffParams contains parameters of the IDoramaRepo.AddStaff
type IDoramaRepoMockAddStaffParams struct {
	idD int
	idS int
}

// IDoramaRepoMockAddStaffResults contains results of the IDoramaRepo.AddStaff
type IDoramaRepoMockAddStaffResults struct {
	err error
}

// Expect sets up expected params for IDoramaRepo.AddStaff
func (mmAddStaff *mIDoramaRepoMockAddStaff) Expect(idD int, idS int) *mIDoramaRepoMockAddStaff {
	if mmAddStaff.mock.funcAddStaff != nil {
		mmAddStaff.mock.t.Fatalf("IDoramaRepoMock.AddStaff mock is already set by Set")
	}

	if mmAddStaff.defaultExpectation == nil {
		mmAddStaff.defaultExpectation = &IDoramaRepoMockAddStaffExpectation{}
	}

	mmAddStaff.defaultExpectation.params = &IDoramaRepoMockAddStaffParams{idD, idS}
	for _, e := range mmAddStaff.expectations {
		if minimock.Equal(e.params, mmAddStaff.defaultExpectation.params) {
			mmAddStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddStaff.defaultExpectation.params)
		}
	}

	return mmAddStaff
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.AddStaff
func (mmAddStaff *mIDoramaRepoMockAddStaff) Inspect(f func(idD int, idS int)) *mIDoramaRepoMockAddStaff {
	if mmAddStaff.mock.inspectFuncAddStaff != nil {
		mmAddStaff.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.AddStaff")
	}

	mmAddStaff.mock.inspectFuncAddStaff = f

	return mmAddStaff
}

// Return sets up results that will be returned by IDoramaRepo.AddStaff
func (mmAddStaff *mIDoramaRepoMockAddStaff) Return(err error) *IDoramaRepoMock {
	if mmAddStaff.mock.funcAddStaff != nil {
		mmAddStaff.mock.t.Fatalf("IDoramaRepoMock.AddStaff mock is already set by Set")
	}

	if mmAddStaff.defaultExpectation == nil {
		mmAddStaff.defaultExpectation = &IDoramaRepoMockAddStaffExpectation{mock: mmAddStaff.mock}
	}
	mmAddStaff.defaultExpectation.results = &IDoramaRepoMockAddStaffResults{err}
	return mmAddStaff.mock
}

// Set uses given function f to mock the IDoramaRepo.AddStaff method
func (mmAddStaff *mIDoramaRepoMockAddStaff) Set(f func(idD int, idS int) (err error)) *IDoramaRepoMock {
	if mmAddStaff.defaultExpectation != nil {
		mmAddStaff.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.AddStaff method")
	}

	if len(mmAddStaff.expectations) > 0 {
		mmAddStaff.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.AddStaff method")
	}

	mmAddStaff.mock.funcAddStaff = f
	return mmAddStaff.mock
}

// When sets expectation for the IDoramaRepo.AddStaff which will trigger the result defined by the following
// Then helper
func (mmAddStaff *mIDoramaRepoMockAddStaff) When(idD int, idS int) *IDoramaRepoMockAddStaffExpectation {
	if mmAddStaff.mock.funcAddStaff != nil {
		mmAddStaff.mock.t.Fatalf("IDoramaRepoMock.AddStaff mock is already set by Set")
	}

	expectation := &IDoramaRepoMockAddStaffExpectation{
		mock:   mmAddStaff.mock,
		params: &IDoramaRepoMockAddStaffParams{idD, idS},
	}
	mmAddStaff.expectations = append(mmAddStaff.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.AddStaff return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockAddStaffExpectation) Then(err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockAddStaffResults{err}
	return e.mock
}

// AddStaff implements repository.IDoramaRepo
func (mmAddStaff *IDoramaRepoMock) AddStaff(idD int, idS int) (err error) {
	mm_atomic.AddUint64(&mmAddStaff.beforeAddStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmAddStaff.afterAddStaffCounter, 1)

	if mmAddStaff.inspectFuncAddStaff != nil {
		mmAddStaff.inspectFuncAddStaff(idD, idS)
	}

	mm_params := &IDoramaRepoMockAddStaffParams{idD, idS}

	// Record call args
	mmAddStaff.AddStaffMock.mutex.Lock()
	mmAddStaff.AddStaffMock.callArgs = append(mmAddStaff.AddStaffMock.callArgs, mm_params)
	mmAddStaff.AddStaffMock.mutex.Unlock()

	for _, e := range mmAddStaff.AddStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddStaff.AddStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddStaff.AddStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmAddStaff.AddStaffMock.defaultExpectation.params
		mm_got := IDoramaRepoMockAddStaffParams{idD, idS}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddStaff.t.Errorf("IDoramaRepoMock.AddStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddStaff.AddStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmAddStaff.t.Fatal("No results are set for the IDoramaRepoMock.AddStaff")
		}
		return (*mm_results).err
	}
	if mmAddStaff.funcAddStaff != nil {
		return mmAddStaff.funcAddStaff(idD, idS)
	}
	mmAddStaff.t.Fatalf("Unexpected call to IDoramaRepoMock.AddStaff. %v %v", idD, idS)
	return
}

// AddStaffAfterCounter returns a count of finished IDoramaRepoMock.AddStaff invocations
func (mmAddStaff *IDoramaRepoMock) AddStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStaff.afterAddStaffCounter)
}

// AddStaffBeforeCounter returns a count of IDoramaRepoMock.AddStaff invocations
func (mmAddStaff *IDoramaRepoMock) AddStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStaff.beforeAddStaffCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.AddStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddStaff *mIDoramaRepoMockAddStaff) Calls() []*IDoramaRepoMockAddStaffParams {
	mmAddStaff.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockAddStaffParams, len(mmAddStaff.callArgs))
	copy(argCopy, mmAddStaff.callArgs)

	mmAddStaff.mutex.RUnlock()

	return argCopy
}

// MinimockAddStaffDone returns true if the count of the AddStaff invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockAddStaffDone() bool {
	for _, e := range m.AddStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStaff != nil && mm_atomic.LoadUint64(&m.afterAddStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddStaffInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockAddStaffInspect() {
	for _, e := range m.AddStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.AddStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddStaffCounter) < 1 {
		if m.AddStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.AddStaff")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.AddStaff with params: %#v", *m.AddStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStaff != nil && mm_atomic.LoadUint64(&m.afterAddStaffCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.AddStaff")
	}
}

type mIDoramaRepoMockCreateDorama struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockCreateDoramaExpectation
	expectations       []*IDoramaRepoMockCreateDoramaExpectation

	callArgs []*IDoramaRepoMockCreateDoramaParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockCreateDoramaExpectation specifies expectation struct of the IDoramaRepo.CreateDorama
type IDoramaRepoMockCreateDoramaExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockCreateDoramaParams
	results *IDoramaRepoMockCreateDoramaResults
	Counter uint64
}

// IDoramaRepoMockCreateDoramaParams contains parameters of the IDoramaRepo.CreateDorama
type IDoramaRepoMockCreateDoramaParams struct {
	dorama model.Dorama
}

// IDoramaRepoMockCreateDoramaResults contains results of the IDoramaRepo.CreateDorama
type IDoramaRepoMockCreateDoramaResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IDoramaRepo.CreateDorama
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) Expect(dorama model.Dorama) *mIDoramaRepoMockCreateDorama {
	if mmCreateDorama.mock.funcCreateDorama != nil {
		mmCreateDorama.mock.t.Fatalf("IDoramaRepoMock.CreateDorama mock is already set by Set")
	}

	if mmCreateDorama.defaultExpectation == nil {
		mmCreateDorama.defaultExpectation = &IDoramaRepoMockCreateDoramaExpectation{}
	}

	mmCreateDorama.defaultExpectation.params = &IDoramaRepoMockCreateDoramaParams{dorama}
	for _, e := range mmCreateDorama.expectations {
		if minimock.Equal(e.params, mmCreateDorama.defaultExpectation.params) {
			mmCreateDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateDorama.defaultExpectation.params)
		}
	}

	return mmCreateDorama
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.CreateDorama
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) Inspect(f func(dorama model.Dorama)) *mIDoramaRepoMockCreateDorama {
	if mmCreateDorama.mock.inspectFuncCreateDorama != nil {
		mmCreateDorama.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.CreateDorama")
	}

	mmCreateDorama.mock.inspectFuncCreateDorama = f

	return mmCreateDorama
}

// Return sets up results that will be returned by IDoramaRepo.CreateDorama
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) Return(i1 int, err error) *IDoramaRepoMock {
	if mmCreateDorama.mock.funcCreateDorama != nil {
		mmCreateDorama.mock.t.Fatalf("IDoramaRepoMock.CreateDorama mock is already set by Set")
	}

	if mmCreateDorama.defaultExpectation == nil {
		mmCreateDorama.defaultExpectation = &IDoramaRepoMockCreateDoramaExpectation{mock: mmCreateDorama.mock}
	}
	mmCreateDorama.defaultExpectation.results = &IDoramaRepoMockCreateDoramaResults{i1, err}
	return mmCreateDorama.mock
}

// Set uses given function f to mock the IDoramaRepo.CreateDorama method
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) Set(f func(dorama model.Dorama) (i1 int, err error)) *IDoramaRepoMock {
	if mmCreateDorama.defaultExpectation != nil {
		mmCreateDorama.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.CreateDorama method")
	}

	if len(mmCreateDorama.expectations) > 0 {
		mmCreateDorama.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.CreateDorama method")
	}

	mmCreateDorama.mock.funcCreateDorama = f
	return mmCreateDorama.mock
}

// When sets expectation for the IDoramaRepo.CreateDorama which will trigger the result defined by the following
// Then helper
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) When(dorama model.Dorama) *IDoramaRepoMockCreateDoramaExpectation {
	if mmCreateDorama.mock.funcCreateDorama != nil {
		mmCreateDorama.mock.t.Fatalf("IDoramaRepoMock.CreateDorama mock is already set by Set")
	}

	expectation := &IDoramaRepoMockCreateDoramaExpectation{
		mock:   mmCreateDorama.mock,
		params: &IDoramaRepoMockCreateDoramaParams{dorama},
	}
	mmCreateDorama.expectations = append(mmCreateDorama.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.CreateDorama return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockCreateDoramaExpectation) Then(i1 int, err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockCreateDoramaResults{i1, err}
	return e.mock
}

// CreateDorama implements repository.IDoramaRepo
func (mmCreateDorama *IDoramaRepoMock) CreateDorama(dorama model.Dorama) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateDorama.beforeCreateDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateDorama.afterCreateDoramaCounter, 1)

	if mmCreateDorama.inspectFuncCreateDorama != nil {
		mmCreateDorama.inspectFuncCreateDorama(dorama)
	}

	mm_params := &IDoramaRepoMockCreateDoramaParams{dorama}

	// Record call args
	mmCreateDorama.CreateDoramaMock.mutex.Lock()
	mmCreateDorama.CreateDoramaMock.callArgs = append(mmCreateDorama.CreateDoramaMock.callArgs, mm_params)
	mmCreateDorama.CreateDoramaMock.mutex.Unlock()

	for _, e := range mmCreateDorama.CreateDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateDorama.CreateDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateDorama.CreateDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateDorama.CreateDoramaMock.defaultExpectation.params
		mm_got := IDoramaRepoMockCreateDoramaParams{dorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateDorama.t.Errorf("IDoramaRepoMock.CreateDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateDorama.CreateDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateDorama.t.Fatal("No results are set for the IDoramaRepoMock.CreateDorama")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateDorama.funcCreateDorama != nil {
		return mmCreateDorama.funcCreateDorama(dorama)
	}
	mmCreateDorama.t.Fatalf("Unexpected call to IDoramaRepoMock.CreateDorama. %v", dorama)
	return
}

// CreateDoramaAfterCounter returns a count of finished IDoramaRepoMock.CreateDorama invocations
func (mmCreateDorama *IDoramaRepoMock) CreateDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDorama.afterCreateDoramaCounter)
}

// CreateDoramaBeforeCounter returns a count of IDoramaRepoMock.CreateDorama invocations
func (mmCreateDorama *IDoramaRepoMock) CreateDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDorama.beforeCreateDoramaCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.CreateDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateDorama *mIDoramaRepoMockCreateDorama) Calls() []*IDoramaRepoMockCreateDoramaParams {
	mmCreateDorama.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockCreateDoramaParams, len(mmCreateDorama.callArgs))
	copy(argCopy, mmCreateDorama.callArgs)

	mmCreateDorama.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDoramaDone returns true if the count of the CreateDorama invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockCreateDoramaDone() bool {
	for _, e := range m.CreateDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDorama != nil && mm_atomic.LoadUint64(&m.afterCreateDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateDoramaInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockCreateDoramaInspect() {
	for _, e := range m.CreateDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.CreateDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateDoramaCounter) < 1 {
		if m.CreateDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.CreateDorama")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.CreateDorama with params: %#v", *m.CreateDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDorama != nil && mm_atomic.LoadUint64(&m.afterCreateDoramaCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.CreateDorama")
	}
}

type mIDoramaRepoMockDeleteDorama struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockDeleteDoramaExpectation
	expectations       []*IDoramaRepoMockDeleteDoramaExpectation

	callArgs []*IDoramaRepoMockDeleteDoramaParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockDeleteDoramaExpectation specifies expectation struct of the IDoramaRepo.DeleteDorama
type IDoramaRepoMockDeleteDoramaExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockDeleteDoramaParams
	results *IDoramaRepoMockDeleteDoramaResults
	Counter uint64
}

// IDoramaRepoMockDeleteDoramaParams contains parameters of the IDoramaRepo.DeleteDorama
type IDoramaRepoMockDeleteDoramaParams struct {
	id int
}

// IDoramaRepoMockDeleteDoramaResults contains results of the IDoramaRepo.DeleteDorama
type IDoramaRepoMockDeleteDoramaResults struct {
	err error
}

// Expect sets up expected params for IDoramaRepo.DeleteDorama
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) Expect(id int) *mIDoramaRepoMockDeleteDorama {
	if mmDeleteDorama.mock.funcDeleteDorama != nil {
		mmDeleteDorama.mock.t.Fatalf("IDoramaRepoMock.DeleteDorama mock is already set by Set")
	}

	if mmDeleteDorama.defaultExpectation == nil {
		mmDeleteDorama.defaultExpectation = &IDoramaRepoMockDeleteDoramaExpectation{}
	}

	mmDeleteDorama.defaultExpectation.params = &IDoramaRepoMockDeleteDoramaParams{id}
	for _, e := range mmDeleteDorama.expectations {
		if minimock.Equal(e.params, mmDeleteDorama.defaultExpectation.params) {
			mmDeleteDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteDorama.defaultExpectation.params)
		}
	}

	return mmDeleteDorama
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.DeleteDorama
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) Inspect(f func(id int)) *mIDoramaRepoMockDeleteDorama {
	if mmDeleteDorama.mock.inspectFuncDeleteDorama != nil {
		mmDeleteDorama.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.DeleteDorama")
	}

	mmDeleteDorama.mock.inspectFuncDeleteDorama = f

	return mmDeleteDorama
}

// Return sets up results that will be returned by IDoramaRepo.DeleteDorama
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) Return(err error) *IDoramaRepoMock {
	if mmDeleteDorama.mock.funcDeleteDorama != nil {
		mmDeleteDorama.mock.t.Fatalf("IDoramaRepoMock.DeleteDorama mock is already set by Set")
	}

	if mmDeleteDorama.defaultExpectation == nil {
		mmDeleteDorama.defaultExpectation = &IDoramaRepoMockDeleteDoramaExpectation{mock: mmDeleteDorama.mock}
	}
	mmDeleteDorama.defaultExpectation.results = &IDoramaRepoMockDeleteDoramaResults{err}
	return mmDeleteDorama.mock
}

// Set uses given function f to mock the IDoramaRepo.DeleteDorama method
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) Set(f func(id int) (err error)) *IDoramaRepoMock {
	if mmDeleteDorama.defaultExpectation != nil {
		mmDeleteDorama.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.DeleteDorama method")
	}

	if len(mmDeleteDorama.expectations) > 0 {
		mmDeleteDorama.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.DeleteDorama method")
	}

	mmDeleteDorama.mock.funcDeleteDorama = f
	return mmDeleteDorama.mock
}

// When sets expectation for the IDoramaRepo.DeleteDorama which will trigger the result defined by the following
// Then helper
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) When(id int) *IDoramaRepoMockDeleteDoramaExpectation {
	if mmDeleteDorama.mock.funcDeleteDorama != nil {
		mmDeleteDorama.mock.t.Fatalf("IDoramaRepoMock.DeleteDorama mock is already set by Set")
	}

	expectation := &IDoramaRepoMockDeleteDoramaExpectation{
		mock:   mmDeleteDorama.mock,
		params: &IDoramaRepoMockDeleteDoramaParams{id},
	}
	mmDeleteDorama.expectations = append(mmDeleteDorama.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.DeleteDorama return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockDeleteDoramaExpectation) Then(err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockDeleteDoramaResults{err}
	return e.mock
}

// DeleteDorama implements repository.IDoramaRepo
func (mmDeleteDorama *IDoramaRepoMock) DeleteDorama(id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteDorama.beforeDeleteDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteDorama.afterDeleteDoramaCounter, 1)

	if mmDeleteDorama.inspectFuncDeleteDorama != nil {
		mmDeleteDorama.inspectFuncDeleteDorama(id)
	}

	mm_params := &IDoramaRepoMockDeleteDoramaParams{id}

	// Record call args
	mmDeleteDorama.DeleteDoramaMock.mutex.Lock()
	mmDeleteDorama.DeleteDoramaMock.callArgs = append(mmDeleteDorama.DeleteDoramaMock.callArgs, mm_params)
	mmDeleteDorama.DeleteDoramaMock.mutex.Unlock()

	for _, e := range mmDeleteDorama.DeleteDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteDorama.DeleteDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteDorama.DeleteDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteDorama.DeleteDoramaMock.defaultExpectation.params
		mm_got := IDoramaRepoMockDeleteDoramaParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteDorama.t.Errorf("IDoramaRepoMock.DeleteDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteDorama.DeleteDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteDorama.t.Fatal("No results are set for the IDoramaRepoMock.DeleteDorama")
		}
		return (*mm_results).err
	}
	if mmDeleteDorama.funcDeleteDorama != nil {
		return mmDeleteDorama.funcDeleteDorama(id)
	}
	mmDeleteDorama.t.Fatalf("Unexpected call to IDoramaRepoMock.DeleteDorama. %v", id)
	return
}

// DeleteDoramaAfterCounter returns a count of finished IDoramaRepoMock.DeleteDorama invocations
func (mmDeleteDorama *IDoramaRepoMock) DeleteDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDorama.afterDeleteDoramaCounter)
}

// DeleteDoramaBeforeCounter returns a count of IDoramaRepoMock.DeleteDorama invocations
func (mmDeleteDorama *IDoramaRepoMock) DeleteDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDorama.beforeDeleteDoramaCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.DeleteDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteDorama *mIDoramaRepoMockDeleteDorama) Calls() []*IDoramaRepoMockDeleteDoramaParams {
	mmDeleteDorama.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockDeleteDoramaParams, len(mmDeleteDorama.callArgs))
	copy(argCopy, mmDeleteDorama.callArgs)

	mmDeleteDorama.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDoramaDone returns true if the count of the DeleteDorama invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockDeleteDoramaDone() bool {
	for _, e := range m.DeleteDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteDorama != nil && mm_atomic.LoadUint64(&m.afterDeleteDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteDoramaInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockDeleteDoramaInspect() {
	for _, e := range m.DeleteDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.DeleteDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteDoramaCounter) < 1 {
		if m.DeleteDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.DeleteDorama")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.DeleteDorama with params: %#v", *m.DeleteDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteDorama != nil && mm_atomic.LoadUint64(&m.afterDeleteDoramaCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.DeleteDorama")
	}
}

type mIDoramaRepoMockGetDorama struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockGetDoramaExpectation
	expectations       []*IDoramaRepoMockGetDoramaExpectation

	callArgs []*IDoramaRepoMockGetDoramaParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockGetDoramaExpectation specifies expectation struct of the IDoramaRepo.GetDorama
type IDoramaRepoMockGetDoramaExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockGetDoramaParams
	results *IDoramaRepoMockGetDoramaResults
	Counter uint64
}

// IDoramaRepoMockGetDoramaParams contains parameters of the IDoramaRepo.GetDorama
type IDoramaRepoMockGetDoramaParams struct {
	id int
}

// IDoramaRepoMockGetDoramaResults contains results of the IDoramaRepo.GetDorama
type IDoramaRepoMockGetDoramaResults struct {
	dp1 *model.Dorama
	err error
}

// Expect sets up expected params for IDoramaRepo.GetDorama
func (mmGetDorama *mIDoramaRepoMockGetDorama) Expect(id int) *mIDoramaRepoMockGetDorama {
	if mmGetDorama.mock.funcGetDorama != nil {
		mmGetDorama.mock.t.Fatalf("IDoramaRepoMock.GetDorama mock is already set by Set")
	}

	if mmGetDorama.defaultExpectation == nil {
		mmGetDorama.defaultExpectation = &IDoramaRepoMockGetDoramaExpectation{}
	}

	mmGetDorama.defaultExpectation.params = &IDoramaRepoMockGetDoramaParams{id}
	for _, e := range mmGetDorama.expectations {
		if minimock.Equal(e.params, mmGetDorama.defaultExpectation.params) {
			mmGetDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDorama.defaultExpectation.params)
		}
	}

	return mmGetDorama
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.GetDorama
func (mmGetDorama *mIDoramaRepoMockGetDorama) Inspect(f func(id int)) *mIDoramaRepoMockGetDorama {
	if mmGetDorama.mock.inspectFuncGetDorama != nil {
		mmGetDorama.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.GetDorama")
	}

	mmGetDorama.mock.inspectFuncGetDorama = f

	return mmGetDorama
}

// Return sets up results that will be returned by IDoramaRepo.GetDorama
func (mmGetDorama *mIDoramaRepoMockGetDorama) Return(dp1 *model.Dorama, err error) *IDoramaRepoMock {
	if mmGetDorama.mock.funcGetDorama != nil {
		mmGetDorama.mock.t.Fatalf("IDoramaRepoMock.GetDorama mock is already set by Set")
	}

	if mmGetDorama.defaultExpectation == nil {
		mmGetDorama.defaultExpectation = &IDoramaRepoMockGetDoramaExpectation{mock: mmGetDorama.mock}
	}
	mmGetDorama.defaultExpectation.results = &IDoramaRepoMockGetDoramaResults{dp1, err}
	return mmGetDorama.mock
}

// Set uses given function f to mock the IDoramaRepo.GetDorama method
func (mmGetDorama *mIDoramaRepoMockGetDorama) Set(f func(id int) (dp1 *model.Dorama, err error)) *IDoramaRepoMock {
	if mmGetDorama.defaultExpectation != nil {
		mmGetDorama.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.GetDorama method")
	}

	if len(mmGetDorama.expectations) > 0 {
		mmGetDorama.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.GetDorama method")
	}

	mmGetDorama.mock.funcGetDorama = f
	return mmGetDorama.mock
}

// When sets expectation for the IDoramaRepo.GetDorama which will trigger the result defined by the following
// Then helper
func (mmGetDorama *mIDoramaRepoMockGetDorama) When(id int) *IDoramaRepoMockGetDoramaExpectation {
	if mmGetDorama.mock.funcGetDorama != nil {
		mmGetDorama.mock.t.Fatalf("IDoramaRepoMock.GetDorama mock is already set by Set")
	}

	expectation := &IDoramaRepoMockGetDoramaExpectation{
		mock:   mmGetDorama.mock,
		params: &IDoramaRepoMockGetDoramaParams{id},
	}
	mmGetDorama.expectations = append(mmGetDorama.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.GetDorama return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockGetDoramaExpectation) Then(dp1 *model.Dorama, err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockGetDoramaResults{dp1, err}
	return e.mock
}

// GetDorama implements repository.IDoramaRepo
func (mmGetDorama *IDoramaRepoMock) GetDorama(id int) (dp1 *model.Dorama, err error) {
	mm_atomic.AddUint64(&mmGetDorama.beforeGetDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDorama.afterGetDoramaCounter, 1)

	if mmGetDorama.inspectFuncGetDorama != nil {
		mmGetDorama.inspectFuncGetDorama(id)
	}

	mm_params := &IDoramaRepoMockGetDoramaParams{id}

	// Record call args
	mmGetDorama.GetDoramaMock.mutex.Lock()
	mmGetDorama.GetDoramaMock.callArgs = append(mmGetDorama.GetDoramaMock.callArgs, mm_params)
	mmGetDorama.GetDoramaMock.mutex.Unlock()

	for _, e := range mmGetDorama.GetDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGetDorama.GetDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDorama.GetDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDorama.GetDoramaMock.defaultExpectation.params
		mm_got := IDoramaRepoMockGetDoramaParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDorama.t.Errorf("IDoramaRepoMock.GetDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDorama.GetDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDorama.t.Fatal("No results are set for the IDoramaRepoMock.GetDorama")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetDorama.funcGetDorama != nil {
		return mmGetDorama.funcGetDorama(id)
	}
	mmGetDorama.t.Fatalf("Unexpected call to IDoramaRepoMock.GetDorama. %v", id)
	return
}

// GetDoramaAfterCounter returns a count of finished IDoramaRepoMock.GetDorama invocations
func (mmGetDorama *IDoramaRepoMock) GetDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDorama.afterGetDoramaCounter)
}

// GetDoramaBeforeCounter returns a count of IDoramaRepoMock.GetDorama invocations
func (mmGetDorama *IDoramaRepoMock) GetDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDorama.beforeGetDoramaCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.GetDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDorama *mIDoramaRepoMockGetDorama) Calls() []*IDoramaRepoMockGetDoramaParams {
	mmGetDorama.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockGetDoramaParams, len(mmGetDorama.callArgs))
	copy(argCopy, mmGetDorama.callArgs)

	mmGetDorama.mutex.RUnlock()

	return argCopy
}

// MinimockGetDoramaDone returns true if the count of the GetDorama invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockGetDoramaDone() bool {
	for _, e := range m.GetDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDorama != nil && mm_atomic.LoadUint64(&m.afterGetDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDoramaInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockGetDoramaInspect() {
	for _, e := range m.GetDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDoramaCounter) < 1 {
		if m.GetDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.GetDorama")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetDorama with params: %#v", *m.GetDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDorama != nil && mm_atomic.LoadUint64(&m.afterGetDoramaCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.GetDorama")
	}
}

type mIDoramaRepoMockGetList struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockGetListExpectation
	expectations       []*IDoramaRepoMockGetListExpectation
}

// IDoramaRepoMockGetListExpectation specifies expectation struct of the IDoramaRepo.GetStaffList
type IDoramaRepoMockGetListExpectation struct {
	mock *IDoramaRepoMock

	results *IDoramaRepoMockGetListResults
	Counter uint64
}

// IDoramaRepoMockGetListResults contains results of the IDoramaRepo.GetStaffList
type IDoramaRepoMockGetListResults struct {
	da1 []model.Dorama
	err error
}

// Expect sets up expected params for IDoramaRepo.GetStaffList
func (mmGetList *mIDoramaRepoMockGetList) Expect() *mIDoramaRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IDoramaRepoMock.GetStaffList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IDoramaRepoMockGetListExpectation{}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.GetStaffList
func (mmGetList *mIDoramaRepoMockGetList) Inspect(f func()) *mIDoramaRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.GetStaffList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by IDoramaRepo.GetStaffList
func (mmGetList *mIDoramaRepoMockGetList) Return(da1 []model.Dorama, err error) *IDoramaRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IDoramaRepoMock.GetStaffList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IDoramaRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &IDoramaRepoMockGetListResults{da1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the IDoramaRepo.GetStaffList method
func (mmGetList *mIDoramaRepoMockGetList) Set(f func() (da1 []model.Dorama, err error)) *IDoramaRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.GetStaffList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.GetStaffList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// GetList implements repository.IDoramaRepo
func (mmGetList *IDoramaRepoMock) GetList() (da1 []model.Dorama, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList()
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the IDoramaRepoMock.GetStaffList")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList()
	}
	mmGetList.t.Fatalf("Unexpected call to IDoramaRepoMock.GetStaffList.")
	return
}

// GetListAfterCounter returns a count of finished IDoramaRepoMock.GetList invocations
func (mmGetList *IDoramaRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of IDoramaRepoMock.GetList invocations
func (mmGetList *IDoramaRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IDoramaRepoMock.GetStaffList")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.GetStaffList")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.GetStaffList")
	}
}

type mIDoramaRepoMockGetListByListId struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockGetListByListIdExpectation
	expectations       []*IDoramaRepoMockGetListByListIdExpectation

	callArgs []*IDoramaRepoMockGetListByListIdParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockGetListByListIdExpectation specifies expectation struct of the IDoramaRepo.GetListByListId
type IDoramaRepoMockGetListByListIdExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockGetListByListIdParams
	results *IDoramaRepoMockGetListByListIdResults
	Counter uint64
}

// IDoramaRepoMockGetListByListIdParams contains parameters of the IDoramaRepo.GetListByListId
type IDoramaRepoMockGetListByListIdParams struct {
	idL int
}

// IDoramaRepoMockGetListByListIdResults contains results of the IDoramaRepo.GetListByListId
type IDoramaRepoMockGetListByListIdResults struct {
	da1 []model.Dorama
	err error
}

// Expect sets up expected params for IDoramaRepo.GetListByListId
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) Expect(idL int) *mIDoramaRepoMockGetListByListId {
	if mmGetListByListId.mock.funcGetListByListId != nil {
		mmGetListByListId.mock.t.Fatalf("IDoramaRepoMock.GetListByListId mock is already set by Set")
	}

	if mmGetListByListId.defaultExpectation == nil {
		mmGetListByListId.defaultExpectation = &IDoramaRepoMockGetListByListIdExpectation{}
	}

	mmGetListByListId.defaultExpectation.params = &IDoramaRepoMockGetListByListIdParams{idL}
	for _, e := range mmGetListByListId.expectations {
		if minimock.Equal(e.params, mmGetListByListId.defaultExpectation.params) {
			mmGetListByListId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListByListId.defaultExpectation.params)
		}
	}

	return mmGetListByListId
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.GetListByListId
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) Inspect(f func(idL int)) *mIDoramaRepoMockGetListByListId {
	if mmGetListByListId.mock.inspectFuncGetListByListId != nil {
		mmGetListByListId.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.GetListByListId")
	}

	mmGetListByListId.mock.inspectFuncGetListByListId = f

	return mmGetListByListId
}

// Return sets up results that will be returned by IDoramaRepo.GetListByListId
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) Return(da1 []model.Dorama, err error) *IDoramaRepoMock {
	if mmGetListByListId.mock.funcGetListByListId != nil {
		mmGetListByListId.mock.t.Fatalf("IDoramaRepoMock.GetListByListId mock is already set by Set")
	}

	if mmGetListByListId.defaultExpectation == nil {
		mmGetListByListId.defaultExpectation = &IDoramaRepoMockGetListByListIdExpectation{mock: mmGetListByListId.mock}
	}
	mmGetListByListId.defaultExpectation.results = &IDoramaRepoMockGetListByListIdResults{da1, err}
	return mmGetListByListId.mock
}

// Set uses given function f to mock the IDoramaRepo.GetListByListId method
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) Set(f func(idL int) (da1 []model.Dorama, err error)) *IDoramaRepoMock {
	if mmGetListByListId.defaultExpectation != nil {
		mmGetListByListId.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.GetListByListId method")
	}

	if len(mmGetListByListId.expectations) > 0 {
		mmGetListByListId.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.GetListByListId method")
	}

	mmGetListByListId.mock.funcGetListByListId = f
	return mmGetListByListId.mock
}

// When sets expectation for the IDoramaRepo.GetListByListId which will trigger the result defined by the following
// Then helper
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) When(idL int) *IDoramaRepoMockGetListByListIdExpectation {
	if mmGetListByListId.mock.funcGetListByListId != nil {
		mmGetListByListId.mock.t.Fatalf("IDoramaRepoMock.GetListByListId mock is already set by Set")
	}

	expectation := &IDoramaRepoMockGetListByListIdExpectation{
		mock:   mmGetListByListId.mock,
		params: &IDoramaRepoMockGetListByListIdParams{idL},
	}
	mmGetListByListId.expectations = append(mmGetListByListId.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.GetListByListId return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockGetListByListIdExpectation) Then(da1 []model.Dorama, err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockGetListByListIdResults{da1, err}
	return e.mock
}

// GetListByListId implements repository.IDoramaRepo
func (mmGetListByListId *IDoramaRepoMock) GetListByListId(idL int) (da1 []model.Dorama, err error) {
	mm_atomic.AddUint64(&mmGetListByListId.beforeGetListByListIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListByListId.afterGetListByListIdCounter, 1)

	if mmGetListByListId.inspectFuncGetListByListId != nil {
		mmGetListByListId.inspectFuncGetListByListId(idL)
	}

	mm_params := &IDoramaRepoMockGetListByListIdParams{idL}

	// Record call args
	mmGetListByListId.GetListByListIdMock.mutex.Lock()
	mmGetListByListId.GetListByListIdMock.callArgs = append(mmGetListByListId.GetListByListIdMock.callArgs, mm_params)
	mmGetListByListId.GetListByListIdMock.mutex.Unlock()

	for _, e := range mmGetListByListId.GetListByListIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmGetListByListId.GetListByListIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListByListId.GetListByListIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListByListId.GetListByListIdMock.defaultExpectation.params
		mm_got := IDoramaRepoMockGetListByListIdParams{idL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListByListId.t.Errorf("IDoramaRepoMock.GetListByListId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListByListId.GetListByListIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListByListId.t.Fatal("No results are set for the IDoramaRepoMock.GetListByListId")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmGetListByListId.funcGetListByListId != nil {
		return mmGetListByListId.funcGetListByListId(idL)
	}
	mmGetListByListId.t.Fatalf("Unexpected call to IDoramaRepoMock.GetListByListId. %v", idL)
	return
}

// GetListByListIdAfterCounter returns a count of finished IDoramaRepoMock.GetListByListId invocations
func (mmGetListByListId *IDoramaRepoMock) GetListByListIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListByListId.afterGetListByListIdCounter)
}

// GetListByListIdBeforeCounter returns a count of IDoramaRepoMock.GetListByListId invocations
func (mmGetListByListId *IDoramaRepoMock) GetListByListIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListByListId.beforeGetListByListIdCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.GetListByListId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListByListId *mIDoramaRepoMockGetListByListId) Calls() []*IDoramaRepoMockGetListByListIdParams {
	mmGetListByListId.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockGetListByListIdParams, len(mmGetListByListId.callArgs))
	copy(argCopy, mmGetListByListId.callArgs)

	mmGetListByListId.mutex.RUnlock()

	return argCopy
}

// MinimockGetListByListIdDone returns true if the count of the GetListByListId invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockGetListByListIdDone() bool {
	for _, e := range m.GetListByListIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListByListIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListByListIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListByListId != nil && mm_atomic.LoadUint64(&m.afterGetListByListIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListByListIdInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockGetListByListIdInspect() {
	for _, e := range m.GetListByListIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetListByListId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListByListIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListByListIdCounter) < 1 {
		if m.GetListByListIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.GetListByListId")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetListByListId with params: %#v", *m.GetListByListIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListByListId != nil && mm_atomic.LoadUint64(&m.afterGetListByListIdCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.GetListByListId")
	}
}

type mIDoramaRepoMockGetListName struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockGetListNameExpectation
	expectations       []*IDoramaRepoMockGetListNameExpectation

	callArgs []*IDoramaRepoMockGetListNameParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockGetListNameExpectation specifies expectation struct of the IDoramaRepo.GetListName
type IDoramaRepoMockGetListNameExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockGetListNameParams
	results *IDoramaRepoMockGetListNameResults
	Counter uint64
}

// IDoramaRepoMockGetListNameParams contains parameters of the IDoramaRepo.GetListName
type IDoramaRepoMockGetListNameParams struct {
	name string
}

// IDoramaRepoMockGetListNameResults contains results of the IDoramaRepo.GetListName
type IDoramaRepoMockGetListNameResults struct {
	da1 []model.Dorama
	err error
}

// Expect sets up expected params for IDoramaRepo.GetListName
func (mmGetListName *mIDoramaRepoMockGetListName) Expect(name string) *mIDoramaRepoMockGetListName {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IDoramaRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IDoramaRepoMockGetListNameExpectation{}
	}

	mmGetListName.defaultExpectation.params = &IDoramaRepoMockGetListNameParams{name}
	for _, e := range mmGetListName.expectations {
		if minimock.Equal(e.params, mmGetListName.defaultExpectation.params) {
			mmGetListName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListName.defaultExpectation.params)
		}
	}

	return mmGetListName
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.GetListName
func (mmGetListName *mIDoramaRepoMockGetListName) Inspect(f func(name string)) *mIDoramaRepoMockGetListName {
	if mmGetListName.mock.inspectFuncGetListName != nil {
		mmGetListName.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.GetListName")
	}

	mmGetListName.mock.inspectFuncGetListName = f

	return mmGetListName
}

// Return sets up results that will be returned by IDoramaRepo.GetListName
func (mmGetListName *mIDoramaRepoMockGetListName) Return(da1 []model.Dorama, err error) *IDoramaRepoMock {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IDoramaRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IDoramaRepoMockGetListNameExpectation{mock: mmGetListName.mock}
	}
	mmGetListName.defaultExpectation.results = &IDoramaRepoMockGetListNameResults{da1, err}
	return mmGetListName.mock
}

// Set uses given function f to mock the IDoramaRepo.GetListName method
func (mmGetListName *mIDoramaRepoMockGetListName) Set(f func(name string) (da1 []model.Dorama, err error)) *IDoramaRepoMock {
	if mmGetListName.defaultExpectation != nil {
		mmGetListName.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.GetListName method")
	}

	if len(mmGetListName.expectations) > 0 {
		mmGetListName.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.GetListName method")
	}

	mmGetListName.mock.funcGetListName = f
	return mmGetListName.mock
}

// When sets expectation for the IDoramaRepo.GetListName which will trigger the result defined by the following
// Then helper
func (mmGetListName *mIDoramaRepoMockGetListName) When(name string) *IDoramaRepoMockGetListNameExpectation {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IDoramaRepoMock.GetListName mock is already set by Set")
	}

	expectation := &IDoramaRepoMockGetListNameExpectation{
		mock:   mmGetListName.mock,
		params: &IDoramaRepoMockGetListNameParams{name},
	}
	mmGetListName.expectations = append(mmGetListName.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.GetListName return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockGetListNameExpectation) Then(da1 []model.Dorama, err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockGetListNameResults{da1, err}
	return e.mock
}

// GetListName implements repository.IDoramaRepo
func (mmGetListName *IDoramaRepoMock) GetListName(name string) (da1 []model.Dorama, err error) {
	mm_atomic.AddUint64(&mmGetListName.beforeGetListNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListName.afterGetListNameCounter, 1)

	if mmGetListName.inspectFuncGetListName != nil {
		mmGetListName.inspectFuncGetListName(name)
	}

	mm_params := &IDoramaRepoMockGetListNameParams{name}

	// Record call args
	mmGetListName.GetListNameMock.mutex.Lock()
	mmGetListName.GetListNameMock.callArgs = append(mmGetListName.GetListNameMock.callArgs, mm_params)
	mmGetListName.GetListNameMock.mutex.Unlock()

	for _, e := range mmGetListName.GetListNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmGetListName.GetListNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListName.GetListNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListName.GetListNameMock.defaultExpectation.params
		mm_got := IDoramaRepoMockGetListNameParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListName.t.Errorf("IDoramaRepoMock.GetListName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListName.GetListNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListName.t.Fatal("No results are set for the IDoramaRepoMock.GetListName")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmGetListName.funcGetListName != nil {
		return mmGetListName.funcGetListName(name)
	}
	mmGetListName.t.Fatalf("Unexpected call to IDoramaRepoMock.GetListName. %v", name)
	return
}

// GetListNameAfterCounter returns a count of finished IDoramaRepoMock.GetListName invocations
func (mmGetListName *IDoramaRepoMock) GetListNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.afterGetListNameCounter)
}

// GetListNameBeforeCounter returns a count of IDoramaRepoMock.GetListName invocations
func (mmGetListName *IDoramaRepoMock) GetListNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.beforeGetListNameCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.GetListName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListName *mIDoramaRepoMockGetListName) Calls() []*IDoramaRepoMockGetListNameParams {
	mmGetListName.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockGetListNameParams, len(mmGetListName.callArgs))
	copy(argCopy, mmGetListName.callArgs)

	mmGetListName.mutex.RUnlock()

	return argCopy
}

// MinimockGetListNameDone returns true if the count of the GetListName invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockGetListNameDone() bool {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListNameInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockGetListNameInspect() {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetListName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		if m.GetListNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.GetListName")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.GetListName with params: %#v", *m.GetListNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.GetListName")
	}
}

type mIDoramaRepoMockUpdateDorama struct {
	mock               *IDoramaRepoMock
	defaultExpectation *IDoramaRepoMockUpdateDoramaExpectation
	expectations       []*IDoramaRepoMockUpdateDoramaExpectation

	callArgs []*IDoramaRepoMockUpdateDoramaParams
	mutex    sync.RWMutex
}

// IDoramaRepoMockUpdateDoramaExpectation specifies expectation struct of the IDoramaRepo.UpdateDorama
type IDoramaRepoMockUpdateDoramaExpectation struct {
	mock    *IDoramaRepoMock
	params  *IDoramaRepoMockUpdateDoramaParams
	results *IDoramaRepoMockUpdateDoramaResults
	Counter uint64
}

// IDoramaRepoMockUpdateDoramaParams contains parameters of the IDoramaRepo.UpdateDorama
type IDoramaRepoMockUpdateDoramaParams struct {
	dorama model.Dorama
}

// IDoramaRepoMockUpdateDoramaResults contains results of the IDoramaRepo.UpdateDorama
type IDoramaRepoMockUpdateDoramaResults struct {
	err error
}

// Expect sets up expected params for IDoramaRepo.UpdateDorama
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) Expect(dorama model.Dorama) *mIDoramaRepoMockUpdateDorama {
	if mmUpdateDorama.mock.funcUpdateDorama != nil {
		mmUpdateDorama.mock.t.Fatalf("IDoramaRepoMock.UpdateDorama mock is already set by Set")
	}

	if mmUpdateDorama.defaultExpectation == nil {
		mmUpdateDorama.defaultExpectation = &IDoramaRepoMockUpdateDoramaExpectation{}
	}

	mmUpdateDorama.defaultExpectation.params = &IDoramaRepoMockUpdateDoramaParams{dorama}
	for _, e := range mmUpdateDorama.expectations {
		if minimock.Equal(e.params, mmUpdateDorama.defaultExpectation.params) {
			mmUpdateDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDorama.defaultExpectation.params)
		}
	}

	return mmUpdateDorama
}

// Inspect accepts an inspector function that has same arguments as the IDoramaRepo.UpdateDorama
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) Inspect(f func(dorama model.Dorama)) *mIDoramaRepoMockUpdateDorama {
	if mmUpdateDorama.mock.inspectFuncUpdateDorama != nil {
		mmUpdateDorama.mock.t.Fatalf("Inspect function is already set for IDoramaRepoMock.UpdateDorama")
	}

	mmUpdateDorama.mock.inspectFuncUpdateDorama = f

	return mmUpdateDorama
}

// Return sets up results that will be returned by IDoramaRepo.UpdateDorama
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) Return(err error) *IDoramaRepoMock {
	if mmUpdateDorama.mock.funcUpdateDorama != nil {
		mmUpdateDorama.mock.t.Fatalf("IDoramaRepoMock.UpdateDorama mock is already set by Set")
	}

	if mmUpdateDorama.defaultExpectation == nil {
		mmUpdateDorama.defaultExpectation = &IDoramaRepoMockUpdateDoramaExpectation{mock: mmUpdateDorama.mock}
	}
	mmUpdateDorama.defaultExpectation.results = &IDoramaRepoMockUpdateDoramaResults{err}
	return mmUpdateDorama.mock
}

// Set uses given function f to mock the IDoramaRepo.UpdateDorama method
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) Set(f func(dorama model.Dorama) (err error)) *IDoramaRepoMock {
	if mmUpdateDorama.defaultExpectation != nil {
		mmUpdateDorama.mock.t.Fatalf("Default expectation is already set for the IDoramaRepo.UpdateDorama method")
	}

	if len(mmUpdateDorama.expectations) > 0 {
		mmUpdateDorama.mock.t.Fatalf("Some expectations are already set for the IDoramaRepo.UpdateDorama method")
	}

	mmUpdateDorama.mock.funcUpdateDorama = f
	return mmUpdateDorama.mock
}

// When sets expectation for the IDoramaRepo.UpdateDorama which will trigger the result defined by the following
// Then helper
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) When(dorama model.Dorama) *IDoramaRepoMockUpdateDoramaExpectation {
	if mmUpdateDorama.mock.funcUpdateDorama != nil {
		mmUpdateDorama.mock.t.Fatalf("IDoramaRepoMock.UpdateDorama mock is already set by Set")
	}

	expectation := &IDoramaRepoMockUpdateDoramaExpectation{
		mock:   mmUpdateDorama.mock,
		params: &IDoramaRepoMockUpdateDoramaParams{dorama},
	}
	mmUpdateDorama.expectations = append(mmUpdateDorama.expectations, expectation)
	return expectation
}

// Then sets up IDoramaRepo.UpdateDorama return parameters for the expectation previously defined by the When method
func (e *IDoramaRepoMockUpdateDoramaExpectation) Then(err error) *IDoramaRepoMock {
	e.results = &IDoramaRepoMockUpdateDoramaResults{err}
	return e.mock
}

// UpdateDorama implements repository.IDoramaRepo
func (mmUpdateDorama *IDoramaRepoMock) UpdateDorama(dorama model.Dorama) (err error) {
	mm_atomic.AddUint64(&mmUpdateDorama.beforeUpdateDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDorama.afterUpdateDoramaCounter, 1)

	if mmUpdateDorama.inspectFuncUpdateDorama != nil {
		mmUpdateDorama.inspectFuncUpdateDorama(dorama)
	}

	mm_params := &IDoramaRepoMockUpdateDoramaParams{dorama}

	// Record call args
	mmUpdateDorama.UpdateDoramaMock.mutex.Lock()
	mmUpdateDorama.UpdateDoramaMock.callArgs = append(mmUpdateDorama.UpdateDoramaMock.callArgs, mm_params)
	mmUpdateDorama.UpdateDoramaMock.mutex.Unlock()

	for _, e := range mmUpdateDorama.UpdateDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateDorama.UpdateDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDorama.UpdateDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDorama.UpdateDoramaMock.defaultExpectation.params
		mm_got := IDoramaRepoMockUpdateDoramaParams{dorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDorama.t.Errorf("IDoramaRepoMock.UpdateDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateDorama.UpdateDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateDorama.t.Fatal("No results are set for the IDoramaRepoMock.UpdateDorama")
		}
		return (*mm_results).err
	}
	if mmUpdateDorama.funcUpdateDorama != nil {
		return mmUpdateDorama.funcUpdateDorama(dorama)
	}
	mmUpdateDorama.t.Fatalf("Unexpected call to IDoramaRepoMock.UpdateDorama. %v", dorama)
	return
}

// UpdateDoramaAfterCounter returns a count of finished IDoramaRepoMock.UpdateDorama invocations
func (mmUpdateDorama *IDoramaRepoMock) UpdateDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDorama.afterUpdateDoramaCounter)
}

// UpdateDoramaBeforeCounter returns a count of IDoramaRepoMock.UpdateDorama invocations
func (mmUpdateDorama *IDoramaRepoMock) UpdateDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDorama.beforeUpdateDoramaCounter)
}

// Calls returns a list of arguments used in each call to IDoramaRepoMock.UpdateDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDorama *mIDoramaRepoMockUpdateDorama) Calls() []*IDoramaRepoMockUpdateDoramaParams {
	mmUpdateDorama.mutex.RLock()

	argCopy := make([]*IDoramaRepoMockUpdateDoramaParams, len(mmUpdateDorama.callArgs))
	copy(argCopy, mmUpdateDorama.callArgs)

	mmUpdateDorama.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDoramaDone returns true if the count of the UpdateDorama invocations corresponds
// the number of defined expectations
func (m *IDoramaRepoMock) MinimockUpdateDoramaDone() bool {
	for _, e := range m.UpdateDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDorama != nil && mm_atomic.LoadUint64(&m.afterUpdateDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateDoramaInspect logs each unmet expectation
func (m *IDoramaRepoMock) MinimockUpdateDoramaInspect() {
	for _, e := range m.UpdateDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDoramaRepoMock.UpdateDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDoramaCounter) < 1 {
		if m.UpdateDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IDoramaRepoMock.UpdateDorama")
		} else {
			m.t.Errorf("Expected call to IDoramaRepoMock.UpdateDorama with params: %#v", *m.UpdateDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDorama != nil && mm_atomic.LoadUint64(&m.afterUpdateDoramaCounter) < 1 {
		m.t.Error("Expected call to IDoramaRepoMock.UpdateDorama")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IDoramaRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddStaffInspect()

		m.MinimockCreateDoramaInspect()

		m.MinimockDeleteDoramaInspect()

		m.MinimockGetDoramaInspect()

		m.MinimockGetListInspect()

		m.MinimockGetListByListIdInspect()

		m.MinimockGetListNameInspect()

		m.MinimockUpdateDoramaInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IDoramaRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IDoramaRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddStaffDone() &&
		m.MinimockCreateDoramaDone() &&
		m.MinimockDeleteDoramaDone() &&
		m.MinimockGetDoramaDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetListByListIdDone() &&
		m.MinimockGetListNameDone() &&
		m.MinimockUpdateDoramaDone()
}
