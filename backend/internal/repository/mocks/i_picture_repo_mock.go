package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IPictureRepo -o ..\..\repository\mocks\i_picture_repo_mock_test.go -n IPictureRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IPictureRepoMock implements repository.IPictureRepo
type IPictureRepoMock struct {
	t minimock.Tester

	funcCreatePicture          func(record model.Picture) (err error)
	inspectFuncCreatePicture   func(record model.Picture)
	afterCreatePictureCounter  uint64
	beforeCreatePictureCounter uint64
	CreatePictureMock          mIPictureRepoMockCreatePicture

	funcGetListDorama          func(idDorama int) (pa1 []model.Picture, err error)
	inspectFuncGetListDorama   func(idDorama int)
	afterGetListDoramaCounter  uint64
	beforeGetListDoramaCounter uint64
	GetListDoramaMock          mIPictureRepoMockGetListDorama

	funcGetListStaff          func(idStaff int) (pa1 []model.Picture, err error)
	inspectFuncGetListStaff   func(idStaff int)
	afterGetListStaffCounter  uint64
	beforeGetListStaffCounter uint64
	GetListStaffMock          mIPictureRepoMockGetListStaff
}

// NewIPictureRepoMock returns a mock for repository.IPictureRepo
func NewIPictureRepoMock(t minimock.Tester) *IPictureRepoMock {
	m := &IPictureRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePictureMock = mIPictureRepoMockCreatePicture{mock: m}
	m.CreatePictureMock.callArgs = []*IPictureRepoMockCreatePictureParams{}

	m.GetListDoramaMock = mIPictureRepoMockGetListDorama{mock: m}
	m.GetListDoramaMock.callArgs = []*IPictureRepoMockGetListDoramaParams{}

	m.GetListStaffMock = mIPictureRepoMockGetListStaff{mock: m}
	m.GetListStaffMock.callArgs = []*IPictureRepoMockGetListStaffParams{}

	return m
}

type mIPictureRepoMockCreatePicture struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockCreatePictureExpectation
	expectations       []*IPictureRepoMockCreatePictureExpectation

	callArgs []*IPictureRepoMockCreatePictureParams
	mutex    sync.RWMutex
}

// IPictureRepoMockCreatePictureExpectation specifies expectation struct of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockCreatePictureParams
	results *IPictureRepoMockCreatePictureResults
	Counter uint64
}

// IPictureRepoMockCreatePictureParams contains parameters of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureParams struct {
	record model.Picture
}

// IPictureRepoMockCreatePictureResults contains results of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureResults struct {
	err error
}

// Expect sets up expected params for IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Expect(record model.Picture) *mIPictureRepoMockCreatePicture {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	if mmCreatePicture.defaultExpectation == nil {
		mmCreatePicture.defaultExpectation = &IPictureRepoMockCreatePictureExpectation{}
	}

	mmCreatePicture.defaultExpectation.params = &IPictureRepoMockCreatePictureParams{record}
	for _, e := range mmCreatePicture.expectations {
		if minimock.Equal(e.params, mmCreatePicture.defaultExpectation.params) {
			mmCreatePicture.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePicture.defaultExpectation.params)
		}
	}

	return mmCreatePicture
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Inspect(f func(record model.Picture)) *mIPictureRepoMockCreatePicture {
	if mmCreatePicture.mock.inspectFuncCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.CreatePicture")
	}

	mmCreatePicture.mock.inspectFuncCreatePicture = f

	return mmCreatePicture
}

// Return sets up results that will be returned by IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Return(err error) *IPictureRepoMock {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	if mmCreatePicture.defaultExpectation == nil {
		mmCreatePicture.defaultExpectation = &IPictureRepoMockCreatePictureExpectation{mock: mmCreatePicture.mock}
	}
	mmCreatePicture.defaultExpectation.results = &IPictureRepoMockCreatePictureResults{err}
	return mmCreatePicture.mock
}

// Set uses given function f to mock the IPictureRepo.CreatePicture method
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Set(f func(record model.Picture) (err error)) *IPictureRepoMock {
	if mmCreatePicture.defaultExpectation != nil {
		mmCreatePicture.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.CreatePicture method")
	}

	if len(mmCreatePicture.expectations) > 0 {
		mmCreatePicture.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.CreatePicture method")
	}

	mmCreatePicture.mock.funcCreatePicture = f
	return mmCreatePicture.mock
}

// When sets expectation for the IPictureRepo.CreatePicture which will trigger the result defined by the following
// Then helper
func (mmCreatePicture *mIPictureRepoMockCreatePicture) When(record model.Picture) *IPictureRepoMockCreatePictureExpectation {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	expectation := &IPictureRepoMockCreatePictureExpectation{
		mock:   mmCreatePicture.mock,
		params: &IPictureRepoMockCreatePictureParams{record},
	}
	mmCreatePicture.expectations = append(mmCreatePicture.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.CreatePicture return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockCreatePictureExpectation) Then(err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockCreatePictureResults{err}
	return e.mock
}

// CreatePicture implements repository.IPictureRepo
func (mmCreatePicture *IPictureRepoMock) CreatePicture(record model.Picture) (err error) {
	mm_atomic.AddUint64(&mmCreatePicture.beforeCreatePictureCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePicture.afterCreatePictureCounter, 1)

	if mmCreatePicture.inspectFuncCreatePicture != nil {
		mmCreatePicture.inspectFuncCreatePicture(record)
	}

	mm_params := &IPictureRepoMockCreatePictureParams{record}

	// Record call args
	mmCreatePicture.CreatePictureMock.mutex.Lock()
	mmCreatePicture.CreatePictureMock.callArgs = append(mmCreatePicture.CreatePictureMock.callArgs, mm_params)
	mmCreatePicture.CreatePictureMock.mutex.Unlock()

	for _, e := range mmCreatePicture.CreatePictureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePicture.CreatePictureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePicture.CreatePictureMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePicture.CreatePictureMock.defaultExpectation.params
		mm_got := IPictureRepoMockCreatePictureParams{record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePicture.t.Errorf("IPictureRepoMock.CreatePicture got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePicture.CreatePictureMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePicture.t.Fatal("No results are set for the IPictureRepoMock.CreatePicture")
		}
		return (*mm_results).err
	}
	if mmCreatePicture.funcCreatePicture != nil {
		return mmCreatePicture.funcCreatePicture(record)
	}
	mmCreatePicture.t.Fatalf("Unexpected call to IPictureRepoMock.CreatePicture. %v", record)
	return
}

// CreatePictureAfterCounter returns a count of finished IPictureRepoMock.CreatePicture invocations
func (mmCreatePicture *IPictureRepoMock) CreatePictureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePicture.afterCreatePictureCounter)
}

// CreatePictureBeforeCounter returns a count of IPictureRepoMock.CreatePicture invocations
func (mmCreatePicture *IPictureRepoMock) CreatePictureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePicture.beforeCreatePictureCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.CreatePicture.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Calls() []*IPictureRepoMockCreatePictureParams {
	mmCreatePicture.mutex.RLock()

	argCopy := make([]*IPictureRepoMockCreatePictureParams, len(mmCreatePicture.callArgs))
	copy(argCopy, mmCreatePicture.callArgs)

	mmCreatePicture.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePictureDone returns true if the count of the CreatePicture invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockCreatePictureDone() bool {
	for _, e := range m.CreatePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePicture != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreatePictureInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockCreatePictureInspect() {
	for _, e := range m.CreatePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.CreatePicture with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		if m.CreatePictureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.CreatePicture")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.CreatePicture with params: %#v", *m.CreatePictureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePicture != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.CreatePicture")
	}
}

type mIPictureRepoMockGetListDorama struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockGetListDoramaExpectation
	expectations       []*IPictureRepoMockGetListDoramaExpectation

	callArgs []*IPictureRepoMockGetListDoramaParams
	mutex    sync.RWMutex
}

// IPictureRepoMockGetListDoramaExpectation specifies expectation struct of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockGetListDoramaParams
	results *IPictureRepoMockGetListDoramaResults
	Counter uint64
}

// IPictureRepoMockGetListDoramaParams contains parameters of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaParams struct {
	idDorama int
}

// IPictureRepoMockGetListDoramaResults contains results of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaResults struct {
	pa1 []model.Picture
	err error
}

// Expect sets up expected params for IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Expect(idDorama int) *mIPictureRepoMockGetListDorama {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IPictureRepoMockGetListDoramaExpectation{}
	}

	mmGetListDorama.defaultExpectation.params = &IPictureRepoMockGetListDoramaParams{idDorama}
	for _, e := range mmGetListDorama.expectations {
		if minimock.Equal(e.params, mmGetListDorama.defaultExpectation.params) {
			mmGetListDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListDorama.defaultExpectation.params)
		}
	}

	return mmGetListDorama
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Inspect(f func(idDorama int)) *mIPictureRepoMockGetListDorama {
	if mmGetListDorama.mock.inspectFuncGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.GetListDorama")
	}

	mmGetListDorama.mock.inspectFuncGetListDorama = f

	return mmGetListDorama
}

// Return sets up results that will be returned by IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Return(pa1 []model.Picture, err error) *IPictureRepoMock {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IPictureRepoMockGetListDoramaExpectation{mock: mmGetListDorama.mock}
	}
	mmGetListDorama.defaultExpectation.results = &IPictureRepoMockGetListDoramaResults{pa1, err}
	return mmGetListDorama.mock
}

// Set uses given function f to mock the IPictureRepo.GetListDorama method
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Set(f func(idDorama int) (pa1 []model.Picture, err error)) *IPictureRepoMock {
	if mmGetListDorama.defaultExpectation != nil {
		mmGetListDorama.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.GetListDorama method")
	}

	if len(mmGetListDorama.expectations) > 0 {
		mmGetListDorama.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.GetListDorama method")
	}

	mmGetListDorama.mock.funcGetListDorama = f
	return mmGetListDorama.mock
}

// When sets expectation for the IPictureRepo.GetListDorama which will trigger the result defined by the following
// Then helper
func (mmGetListDorama *mIPictureRepoMockGetListDorama) When(idDorama int) *IPictureRepoMockGetListDoramaExpectation {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	expectation := &IPictureRepoMockGetListDoramaExpectation{
		mock:   mmGetListDorama.mock,
		params: &IPictureRepoMockGetListDoramaParams{idDorama},
	}
	mmGetListDorama.expectations = append(mmGetListDorama.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.GetListDorama return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockGetListDoramaExpectation) Then(pa1 []model.Picture, err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockGetListDoramaResults{pa1, err}
	return e.mock
}

// GetListDorama implements repository.IPictureRepo
func (mmGetListDorama *IPictureRepoMock) GetListDorama(idDorama int) (pa1 []model.Picture, err error) {
	mm_atomic.AddUint64(&mmGetListDorama.beforeGetListDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListDorama.afterGetListDoramaCounter, 1)

	if mmGetListDorama.inspectFuncGetListDorama != nil {
		mmGetListDorama.inspectFuncGetListDorama(idDorama)
	}

	mm_params := &IPictureRepoMockGetListDoramaParams{idDorama}

	// Record call args
	mmGetListDorama.GetListDoramaMock.mutex.Lock()
	mmGetListDorama.GetListDoramaMock.callArgs = append(mmGetListDorama.GetListDoramaMock.callArgs, mm_params)
	mmGetListDorama.GetListDoramaMock.mutex.Unlock()

	for _, e := range mmGetListDorama.GetListDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetListDorama.GetListDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListDorama.GetListDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListDorama.GetListDoramaMock.defaultExpectation.params
		mm_got := IPictureRepoMockGetListDoramaParams{idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListDorama.t.Errorf("IPictureRepoMock.GetListDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListDorama.GetListDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListDorama.t.Fatal("No results are set for the IPictureRepoMock.GetListDorama")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetListDorama.funcGetListDorama != nil {
		return mmGetListDorama.funcGetListDorama(idDorama)
	}
	mmGetListDorama.t.Fatalf("Unexpected call to IPictureRepoMock.GetListDorama. %v", idDorama)
	return
}

// GetListDoramaAfterCounter returns a count of finished IPictureRepoMock.GetListDorama invocations
func (mmGetListDorama *IPictureRepoMock) GetListDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.afterGetListDoramaCounter)
}

// GetListDoramaBeforeCounter returns a count of IPictureRepoMock.GetListDorama invocations
func (mmGetListDorama *IPictureRepoMock) GetListDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.beforeGetListDoramaCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.GetListDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Calls() []*IPictureRepoMockGetListDoramaParams {
	mmGetListDorama.mutex.RLock()

	argCopy := make([]*IPictureRepoMockGetListDoramaParams, len(mmGetListDorama.callArgs))
	copy(argCopy, mmGetListDorama.callArgs)

	mmGetListDorama.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDoramaDone returns true if the count of the GetListDorama invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockGetListDoramaDone() bool {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListDoramaInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockGetListDoramaInspect() {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		if m.GetListDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.GetListDorama")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListDorama with params: %#v", *m.GetListDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.GetListDorama")
	}
}

type mIPictureRepoMockGetListStaff struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockGetListStaffExpectation
	expectations       []*IPictureRepoMockGetListStaffExpectation

	callArgs []*IPictureRepoMockGetListStaffParams
	mutex    sync.RWMutex
}

// IPictureRepoMockGetListStaffExpectation specifies expectation struct of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockGetListStaffParams
	results *IPictureRepoMockGetListStaffResults
	Counter uint64
}

// IPictureRepoMockGetListStaffParams contains parameters of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffParams struct {
	idStaff int
}

// IPictureRepoMockGetListStaffResults contains results of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffResults struct {
	pa1 []model.Picture
	err error
}

// Expect sets up expected params for IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Expect(idStaff int) *mIPictureRepoMockGetListStaff {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	if mmGetListStaff.defaultExpectation == nil {
		mmGetListStaff.defaultExpectation = &IPictureRepoMockGetListStaffExpectation{}
	}

	mmGetListStaff.defaultExpectation.params = &IPictureRepoMockGetListStaffParams{idStaff}
	for _, e := range mmGetListStaff.expectations {
		if minimock.Equal(e.params, mmGetListStaff.defaultExpectation.params) {
			mmGetListStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListStaff.defaultExpectation.params)
		}
	}

	return mmGetListStaff
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Inspect(f func(idStaff int)) *mIPictureRepoMockGetListStaff {
	if mmGetListStaff.mock.inspectFuncGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.GetListStaff")
	}

	mmGetListStaff.mock.inspectFuncGetListStaff = f

	return mmGetListStaff
}

// Return sets up results that will be returned by IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Return(pa1 []model.Picture, err error) *IPictureRepoMock {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	if mmGetListStaff.defaultExpectation == nil {
		mmGetListStaff.defaultExpectation = &IPictureRepoMockGetListStaffExpectation{mock: mmGetListStaff.mock}
	}
	mmGetListStaff.defaultExpectation.results = &IPictureRepoMockGetListStaffResults{pa1, err}
	return mmGetListStaff.mock
}

// Set uses given function f to mock the IPictureRepo.GetListStaff method
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Set(f func(idStaff int) (pa1 []model.Picture, err error)) *IPictureRepoMock {
	if mmGetListStaff.defaultExpectation != nil {
		mmGetListStaff.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.GetListStaff method")
	}

	if len(mmGetListStaff.expectations) > 0 {
		mmGetListStaff.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.GetListStaff method")
	}

	mmGetListStaff.mock.funcGetListStaff = f
	return mmGetListStaff.mock
}

// When sets expectation for the IPictureRepo.GetListStaff which will trigger the result defined by the following
// Then helper
func (mmGetListStaff *mIPictureRepoMockGetListStaff) When(idStaff int) *IPictureRepoMockGetListStaffExpectation {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	expectation := &IPictureRepoMockGetListStaffExpectation{
		mock:   mmGetListStaff.mock,
		params: &IPictureRepoMockGetListStaffParams{idStaff},
	}
	mmGetListStaff.expectations = append(mmGetListStaff.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.GetListStaff return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockGetListStaffExpectation) Then(pa1 []model.Picture, err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockGetListStaffResults{pa1, err}
	return e.mock
}

// GetListStaff implements repository.IPictureRepo
func (mmGetListStaff *IPictureRepoMock) GetListStaff(idStaff int) (pa1 []model.Picture, err error) {
	mm_atomic.AddUint64(&mmGetListStaff.beforeGetListStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListStaff.afterGetListStaffCounter, 1)

	if mmGetListStaff.inspectFuncGetListStaff != nil {
		mmGetListStaff.inspectFuncGetListStaff(idStaff)
	}

	mm_params := &IPictureRepoMockGetListStaffParams{idStaff}

	// Record call args
	mmGetListStaff.GetListStaffMock.mutex.Lock()
	mmGetListStaff.GetListStaffMock.callArgs = append(mmGetListStaff.GetListStaffMock.callArgs, mm_params)
	mmGetListStaff.GetListStaffMock.mutex.Unlock()

	for _, e := range mmGetListStaff.GetListStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetListStaff.GetListStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListStaff.GetListStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListStaff.GetListStaffMock.defaultExpectation.params
		mm_got := IPictureRepoMockGetListStaffParams{idStaff}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListStaff.t.Errorf("IPictureRepoMock.GetListStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListStaff.GetListStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListStaff.t.Fatal("No results are set for the IPictureRepoMock.GetListStaff")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetListStaff.funcGetListStaff != nil {
		return mmGetListStaff.funcGetListStaff(idStaff)
	}
	mmGetListStaff.t.Fatalf("Unexpected call to IPictureRepoMock.GetListStaff. %v", idStaff)
	return
}

// GetListStaffAfterCounter returns a count of finished IPictureRepoMock.GetListStaff invocations
func (mmGetListStaff *IPictureRepoMock) GetListStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListStaff.afterGetListStaffCounter)
}

// GetListStaffBeforeCounter returns a count of IPictureRepoMock.GetListStaff invocations
func (mmGetListStaff *IPictureRepoMock) GetListStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListStaff.beforeGetListStaffCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.GetListStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Calls() []*IPictureRepoMockGetListStaffParams {
	mmGetListStaff.mutex.RLock()

	argCopy := make([]*IPictureRepoMockGetListStaffParams, len(mmGetListStaff.callArgs))
	copy(argCopy, mmGetListStaff.callArgs)

	mmGetListStaff.mutex.RUnlock()

	return argCopy
}

// MinimockGetListStaffDone returns true if the count of the GetListStaff invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockGetListStaffDone() bool {
	for _, e := range m.GetListStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListStaff != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListStaffInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockGetListStaffInspect() {
	for _, e := range m.GetListStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		if m.GetListStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.GetListStaff")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListStaff with params: %#v", *m.GetListStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListStaff != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.GetListStaff")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPictureRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreatePictureInspect()

		m.MinimockGetListDoramaInspect()

		m.MinimockGetListStaffInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPictureRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPictureRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePictureDone() &&
		m.MinimockGetListDoramaDone() &&
		m.MinimockGetListStaffDone()
}
