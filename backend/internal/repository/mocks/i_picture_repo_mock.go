package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces/repository.IPictureRepo -o ./i_picture_repo_mock_test.go -n IPictureRepoMock

import (
	"DoramaSet/internal/logic/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IPictureRepoMock implements IPictureRepo
type IPictureRepoMock struct {
	t minimock.Tester

	funcAddPictureToDorama          func(ctx context.Context, record model.Picture, id int) (err error)
	inspectFuncAddPictureToDorama   func(ctx context.Context, record model.Picture, id int)
	afterAddPictureToDoramaCounter  uint64
	beforeAddPictureToDoramaCounter uint64
	AddPictureToDoramaMock          mIPictureRepoMockAddPictureToDorama

	funcAddPictureToStaff          func(ctx context.Context, record model.Picture, id int) (err error)
	inspectFuncAddPictureToStaff   func(ctx context.Context, record model.Picture, id int)
	afterAddPictureToStaffCounter  uint64
	beforeAddPictureToStaffCounter uint64
	AddPictureToStaffMock          mIPictureRepoMockAddPictureToStaff

	funcCreatePicture          func(ctx context.Context, record model.Picture) (i1 int, err error)
	inspectFuncCreatePicture   func(ctx context.Context, record model.Picture)
	afterCreatePictureCounter  uint64
	beforeCreatePictureCounter uint64
	CreatePictureMock          mIPictureRepoMockCreatePicture

	funcDeletePicture          func(ctx context.Context, id int) (err error)
	inspectFuncDeletePicture   func(ctx context.Context, id int)
	afterDeletePictureCounter  uint64
	beforeDeletePictureCounter uint64
	DeletePictureMock          mIPictureRepoMockDeletePicture

	funcGetListDorama          func(ctx context.Context, idDorama int) (pa1 []model.Picture, err error)
	inspectFuncGetListDorama   func(ctx context.Context, idDorama int)
	afterGetListDoramaCounter  uint64
	beforeGetListDoramaCounter uint64
	GetListDoramaMock          mIPictureRepoMockGetListDorama

	funcGetListStaff          func(ctx context.Context, idStaff int) (pa1 []model.Picture, err error)
	inspectFuncGetListStaff   func(ctx context.Context, idStaff int)
	afterGetListStaffCounter  uint64
	beforeGetListStaffCounter uint64
	GetListStaffMock          mIPictureRepoMockGetListStaff
}

// NewIPictureRepoMock returns a mock for IPictureRepo
func NewIPictureRepoMock(t minimock.Tester) *IPictureRepoMock {
	m := &IPictureRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPictureToDoramaMock = mIPictureRepoMockAddPictureToDorama{mock: m}
	m.AddPictureToDoramaMock.callArgs = []*IPictureRepoMockAddPictureToDoramaParams{}

	m.AddPictureToStaffMock = mIPictureRepoMockAddPictureToStaff{mock: m}
	m.AddPictureToStaffMock.callArgs = []*IPictureRepoMockAddPictureToStaffParams{}

	m.CreatePictureMock = mIPictureRepoMockCreatePicture{mock: m}
	m.CreatePictureMock.callArgs = []*IPictureRepoMockCreatePictureParams{}

	m.DeletePictureMock = mIPictureRepoMockDeletePicture{mock: m}
	m.DeletePictureMock.callArgs = []*IPictureRepoMockDeletePictureParams{}

	m.GetListDoramaMock = mIPictureRepoMockGetListDorama{mock: m}
	m.GetListDoramaMock.callArgs = []*IPictureRepoMockGetListDoramaParams{}

	m.GetListStaffMock = mIPictureRepoMockGetListStaff{mock: m}
	m.GetListStaffMock.callArgs = []*IPictureRepoMockGetListStaffParams{}

	return m
}

type mIPictureRepoMockAddPictureToDorama struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockAddPictureToDoramaExpectation
	expectations       []*IPictureRepoMockAddPictureToDoramaExpectation

	callArgs []*IPictureRepoMockAddPictureToDoramaParams
	mutex    sync.RWMutex
}

// IPictureRepoMockAddPictureToDoramaExpectation specifies expectation struct of the IPictureRepo.AddPictureToDorama
type IPictureRepoMockAddPictureToDoramaExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockAddPictureToDoramaParams
	results *IPictureRepoMockAddPictureToDoramaResults
	Counter uint64
}

// IPictureRepoMockAddPictureToDoramaParams contains parameters of the IPictureRepo.AddPictureToDorama
type IPictureRepoMockAddPictureToDoramaParams struct {
	ctx    context.Context
	record model.Picture
	id     int
}

// IPictureRepoMockAddPictureToDoramaResults contains results of the IPictureRepo.AddPictureToDorama
type IPictureRepoMockAddPictureToDoramaResults struct {
	err error
}

// Expect sets up expected params for IPictureRepo.AddPictureToDorama
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) Expect(ctx context.Context, record model.Picture, id int) *mIPictureRepoMockAddPictureToDorama {
	if mmAddPictureToDorama.mock.funcAddPictureToDorama != nil {
		mmAddPictureToDorama.mock.t.Fatalf("IPictureRepoMock.AddPictureToDorama mock is already set by Set")
	}

	if mmAddPictureToDorama.defaultExpectation == nil {
		mmAddPictureToDorama.defaultExpectation = &IPictureRepoMockAddPictureToDoramaExpectation{}
	}

	mmAddPictureToDorama.defaultExpectation.params = &IPictureRepoMockAddPictureToDoramaParams{ctx, record, id}
	for _, e := range mmAddPictureToDorama.expectations {
		if minimock.Equal(e.params, mmAddPictureToDorama.defaultExpectation.params) {
			mmAddPictureToDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPictureToDorama.defaultExpectation.params)
		}
	}

	return mmAddPictureToDorama
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.AddPictureToDorama
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) Inspect(f func(ctx context.Context, record model.Picture, id int)) *mIPictureRepoMockAddPictureToDorama {
	if mmAddPictureToDorama.mock.inspectFuncAddPictureToDorama != nil {
		mmAddPictureToDorama.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.AddPictureToDorama")
	}

	mmAddPictureToDorama.mock.inspectFuncAddPictureToDorama = f

	return mmAddPictureToDorama
}

// Return sets up results that will be returned by IPictureRepo.AddPictureToDorama
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) Return(err error) *IPictureRepoMock {
	if mmAddPictureToDorama.mock.funcAddPictureToDorama != nil {
		mmAddPictureToDorama.mock.t.Fatalf("IPictureRepoMock.AddPictureToDorama mock is already set by Set")
	}

	if mmAddPictureToDorama.defaultExpectation == nil {
		mmAddPictureToDorama.defaultExpectation = &IPictureRepoMockAddPictureToDoramaExpectation{mock: mmAddPictureToDorama.mock}
	}
	mmAddPictureToDorama.defaultExpectation.results = &IPictureRepoMockAddPictureToDoramaResults{err}
	return mmAddPictureToDorama.mock
}

// Set uses given function f to mock the IPictureRepo.AddPictureToDorama method
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) Set(f func(ctx context.Context, record model.Picture, id int) (err error)) *IPictureRepoMock {
	if mmAddPictureToDorama.defaultExpectation != nil {
		mmAddPictureToDorama.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.AddPictureToDorama method")
	}

	if len(mmAddPictureToDorama.expectations) > 0 {
		mmAddPictureToDorama.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.AddPictureToDorama method")
	}

	mmAddPictureToDorama.mock.funcAddPictureToDorama = f
	return mmAddPictureToDorama.mock
}

// When sets expectation for the IPictureRepo.AddPictureToDorama which will trigger the result defined by the following
// Then helper
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) When(ctx context.Context, record model.Picture, id int) *IPictureRepoMockAddPictureToDoramaExpectation {
	if mmAddPictureToDorama.mock.funcAddPictureToDorama != nil {
		mmAddPictureToDorama.mock.t.Fatalf("IPictureRepoMock.AddPictureToDorama mock is already set by Set")
	}

	expectation := &IPictureRepoMockAddPictureToDoramaExpectation{
		mock:   mmAddPictureToDorama.mock,
		params: &IPictureRepoMockAddPictureToDoramaParams{ctx, record, id},
	}
	mmAddPictureToDorama.expectations = append(mmAddPictureToDorama.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.AddPictureToDorama return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockAddPictureToDoramaExpectation) Then(err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockAddPictureToDoramaResults{err}
	return e.mock
}

// AddPictureToDorama implements IPictureRepo
func (mmAddPictureToDorama *IPictureRepoMock) AddPictureToDorama(ctx context.Context, record model.Picture, id int) (err error) {
	mm_atomic.AddUint64(&mmAddPictureToDorama.beforeAddPictureToDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPictureToDorama.afterAddPictureToDoramaCounter, 1)

	if mmAddPictureToDorama.inspectFuncAddPictureToDorama != nil {
		mmAddPictureToDorama.inspectFuncAddPictureToDorama(ctx, record, id)
	}

	mm_params := &IPictureRepoMockAddPictureToDoramaParams{ctx, record, id}

	// Record call args
	mmAddPictureToDorama.AddPictureToDoramaMock.mutex.Lock()
	mmAddPictureToDorama.AddPictureToDoramaMock.callArgs = append(mmAddPictureToDorama.AddPictureToDoramaMock.callArgs, mm_params)
	mmAddPictureToDorama.AddPictureToDoramaMock.mutex.Unlock()

	for _, e := range mmAddPictureToDorama.AddPictureToDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPictureToDorama.AddPictureToDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPictureToDorama.AddPictureToDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPictureToDorama.AddPictureToDoramaMock.defaultExpectation.params
		mm_got := IPictureRepoMockAddPictureToDoramaParams{ctx, record, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPictureToDorama.t.Errorf("IPictureRepoMock.AddPictureToDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPictureToDorama.AddPictureToDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPictureToDorama.t.Fatal("No results are set for the IPictureRepoMock.AddPictureToDorama")
		}
		return (*mm_results).err
	}
	if mmAddPictureToDorama.funcAddPictureToDorama != nil {
		return mmAddPictureToDorama.funcAddPictureToDorama(ctx, record, id)
	}
	mmAddPictureToDorama.t.Fatalf("Unexpected call to IPictureRepoMock.AddPictureToDorama. %v %v %v", ctx, record, id)
	return
}

// AddPictureToDoramaAfterCounter returns a count of finished IPictureRepoMock.AddPictureToDorama invocations
func (mmAddPictureToDorama *IPictureRepoMock) AddPictureToDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPictureToDorama.afterAddPictureToDoramaCounter)
}

// AddPictureToDoramaBeforeCounter returns a count of IPictureRepoMock.AddPictureToDorama invocations
func (mmAddPictureToDorama *IPictureRepoMock) AddPictureToDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPictureToDorama.beforeAddPictureToDoramaCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.AddPictureToDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPictureToDorama *mIPictureRepoMockAddPictureToDorama) Calls() []*IPictureRepoMockAddPictureToDoramaParams {
	mmAddPictureToDorama.mutex.RLock()

	argCopy := make([]*IPictureRepoMockAddPictureToDoramaParams, len(mmAddPictureToDorama.callArgs))
	copy(argCopy, mmAddPictureToDorama.callArgs)

	mmAddPictureToDorama.mutex.RUnlock()

	return argCopy
}

// MinimockAddPictureToDoramaDone returns true if the count of the AddPictureToDorama invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockAddPictureToDoramaDone() bool {
	for _, e := range m.AddPictureToDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPictureToDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPictureToDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPictureToDorama != nil && mm_atomic.LoadUint64(&m.afterAddPictureToDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddPictureToDoramaInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockAddPictureToDoramaInspect() {
	for _, e := range m.AddPictureToDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.AddPictureToDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPictureToDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPictureToDoramaCounter) < 1 {
		if m.AddPictureToDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.AddPictureToDorama")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.AddPictureToDorama with params: %#v", *m.AddPictureToDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPictureToDorama != nil && mm_atomic.LoadUint64(&m.afterAddPictureToDoramaCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.AddPictureToDorama")
	}
}

type mIPictureRepoMockAddPictureToStaff struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockAddPictureToStaffExpectation
	expectations       []*IPictureRepoMockAddPictureToStaffExpectation

	callArgs []*IPictureRepoMockAddPictureToStaffParams
	mutex    sync.RWMutex
}

// IPictureRepoMockAddPictureToStaffExpectation specifies expectation struct of the IPictureRepo.AddPictureToStaff
type IPictureRepoMockAddPictureToStaffExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockAddPictureToStaffParams
	results *IPictureRepoMockAddPictureToStaffResults
	Counter uint64
}

// IPictureRepoMockAddPictureToStaffParams contains parameters of the IPictureRepo.AddPictureToStaff
type IPictureRepoMockAddPictureToStaffParams struct {
	ctx    context.Context
	record model.Picture
	id     int
}

// IPictureRepoMockAddPictureToStaffResults contains results of the IPictureRepo.AddPictureToStaff
type IPictureRepoMockAddPictureToStaffResults struct {
	err error
}

// Expect sets up expected params for IPictureRepo.AddPictureToStaff
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) Expect(ctx context.Context, record model.Picture, id int) *mIPictureRepoMockAddPictureToStaff {
	if mmAddPictureToStaff.mock.funcAddPictureToStaff != nil {
		mmAddPictureToStaff.mock.t.Fatalf("IPictureRepoMock.AddPictureToStaff mock is already set by Set")
	}

	if mmAddPictureToStaff.defaultExpectation == nil {
		mmAddPictureToStaff.defaultExpectation = &IPictureRepoMockAddPictureToStaffExpectation{}
	}

	mmAddPictureToStaff.defaultExpectation.params = &IPictureRepoMockAddPictureToStaffParams{ctx, record, id}
	for _, e := range mmAddPictureToStaff.expectations {
		if minimock.Equal(e.params, mmAddPictureToStaff.defaultExpectation.params) {
			mmAddPictureToStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPictureToStaff.defaultExpectation.params)
		}
	}

	return mmAddPictureToStaff
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.AddPictureToStaff
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) Inspect(f func(ctx context.Context, record model.Picture, id int)) *mIPictureRepoMockAddPictureToStaff {
	if mmAddPictureToStaff.mock.inspectFuncAddPictureToStaff != nil {
		mmAddPictureToStaff.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.AddPictureToStaff")
	}

	mmAddPictureToStaff.mock.inspectFuncAddPictureToStaff = f

	return mmAddPictureToStaff
}

// Return sets up results that will be returned by IPictureRepo.AddPictureToStaff
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) Return(err error) *IPictureRepoMock {
	if mmAddPictureToStaff.mock.funcAddPictureToStaff != nil {
		mmAddPictureToStaff.mock.t.Fatalf("IPictureRepoMock.AddPictureToStaff mock is already set by Set")
	}

	if mmAddPictureToStaff.defaultExpectation == nil {
		mmAddPictureToStaff.defaultExpectation = &IPictureRepoMockAddPictureToStaffExpectation{mock: mmAddPictureToStaff.mock}
	}
	mmAddPictureToStaff.defaultExpectation.results = &IPictureRepoMockAddPictureToStaffResults{err}
	return mmAddPictureToStaff.mock
}

// Set uses given function f to mock the IPictureRepo.AddPictureToStaff method
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) Set(f func(ctx context.Context, record model.Picture, id int) (err error)) *IPictureRepoMock {
	if mmAddPictureToStaff.defaultExpectation != nil {
		mmAddPictureToStaff.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.AddPictureToStaff method")
	}

	if len(mmAddPictureToStaff.expectations) > 0 {
		mmAddPictureToStaff.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.AddPictureToStaff method")
	}

	mmAddPictureToStaff.mock.funcAddPictureToStaff = f
	return mmAddPictureToStaff.mock
}

// When sets expectation for the IPictureRepo.AddPictureToStaff which will trigger the result defined by the following
// Then helper
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) When(ctx context.Context, record model.Picture, id int) *IPictureRepoMockAddPictureToStaffExpectation {
	if mmAddPictureToStaff.mock.funcAddPictureToStaff != nil {
		mmAddPictureToStaff.mock.t.Fatalf("IPictureRepoMock.AddPictureToStaff mock is already set by Set")
	}

	expectation := &IPictureRepoMockAddPictureToStaffExpectation{
		mock:   mmAddPictureToStaff.mock,
		params: &IPictureRepoMockAddPictureToStaffParams{ctx, record, id},
	}
	mmAddPictureToStaff.expectations = append(mmAddPictureToStaff.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.AddPictureToStaff return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockAddPictureToStaffExpectation) Then(err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockAddPictureToStaffResults{err}
	return e.mock
}

// AddPictureToStaff implements IPictureRepo
func (mmAddPictureToStaff *IPictureRepoMock) AddPictureToStaff(ctx context.Context, record model.Picture, id int) (err error) {
	mm_atomic.AddUint64(&mmAddPictureToStaff.beforeAddPictureToStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPictureToStaff.afterAddPictureToStaffCounter, 1)

	if mmAddPictureToStaff.inspectFuncAddPictureToStaff != nil {
		mmAddPictureToStaff.inspectFuncAddPictureToStaff(ctx, record, id)
	}

	mm_params := &IPictureRepoMockAddPictureToStaffParams{ctx, record, id}

	// Record call args
	mmAddPictureToStaff.AddPictureToStaffMock.mutex.Lock()
	mmAddPictureToStaff.AddPictureToStaffMock.callArgs = append(mmAddPictureToStaff.AddPictureToStaffMock.callArgs, mm_params)
	mmAddPictureToStaff.AddPictureToStaffMock.mutex.Unlock()

	for _, e := range mmAddPictureToStaff.AddPictureToStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPictureToStaff.AddPictureToStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPictureToStaff.AddPictureToStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPictureToStaff.AddPictureToStaffMock.defaultExpectation.params
		mm_got := IPictureRepoMockAddPictureToStaffParams{ctx, record, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPictureToStaff.t.Errorf("IPictureRepoMock.AddPictureToStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPictureToStaff.AddPictureToStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPictureToStaff.t.Fatal("No results are set for the IPictureRepoMock.AddPictureToStaff")
		}
		return (*mm_results).err
	}
	if mmAddPictureToStaff.funcAddPictureToStaff != nil {
		return mmAddPictureToStaff.funcAddPictureToStaff(ctx, record, id)
	}
	mmAddPictureToStaff.t.Fatalf("Unexpected call to IPictureRepoMock.AddPictureToStaff. %v %v %v", ctx, record, id)
	return
}

// AddPictureToStaffAfterCounter returns a count of finished IPictureRepoMock.AddPictureToStaff invocations
func (mmAddPictureToStaff *IPictureRepoMock) AddPictureToStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPictureToStaff.afterAddPictureToStaffCounter)
}

// AddPictureToStaffBeforeCounter returns a count of IPictureRepoMock.AddPictureToStaff invocations
func (mmAddPictureToStaff *IPictureRepoMock) AddPictureToStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPictureToStaff.beforeAddPictureToStaffCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.AddPictureToStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPictureToStaff *mIPictureRepoMockAddPictureToStaff) Calls() []*IPictureRepoMockAddPictureToStaffParams {
	mmAddPictureToStaff.mutex.RLock()

	argCopy := make([]*IPictureRepoMockAddPictureToStaffParams, len(mmAddPictureToStaff.callArgs))
	copy(argCopy, mmAddPictureToStaff.callArgs)

	mmAddPictureToStaff.mutex.RUnlock()

	return argCopy
}

// MinimockAddPictureToStaffDone returns true if the count of the AddPictureToStaff invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockAddPictureToStaffDone() bool {
	for _, e := range m.AddPictureToStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPictureToStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPictureToStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPictureToStaff != nil && mm_atomic.LoadUint64(&m.afterAddPictureToStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddPictureToStaffInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockAddPictureToStaffInspect() {
	for _, e := range m.AddPictureToStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.AddPictureToStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPictureToStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPictureToStaffCounter) < 1 {
		if m.AddPictureToStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.AddPictureToStaff")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.AddPictureToStaff with params: %#v", *m.AddPictureToStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPictureToStaff != nil && mm_atomic.LoadUint64(&m.afterAddPictureToStaffCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.AddPictureToStaff")
	}
}

type mIPictureRepoMockCreatePicture struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockCreatePictureExpectation
	expectations       []*IPictureRepoMockCreatePictureExpectation

	callArgs []*IPictureRepoMockCreatePictureParams
	mutex    sync.RWMutex
}

// IPictureRepoMockCreatePictureExpectation specifies expectation struct of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockCreatePictureParams
	results *IPictureRepoMockCreatePictureResults
	Counter uint64
}

// IPictureRepoMockCreatePictureParams contains parameters of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureParams struct {
	ctx    context.Context
	record model.Picture
}

// IPictureRepoMockCreatePictureResults contains results of the IPictureRepo.CreatePicture
type IPictureRepoMockCreatePictureResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Expect(ctx context.Context, record model.Picture) *mIPictureRepoMockCreatePicture {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	if mmCreatePicture.defaultExpectation == nil {
		mmCreatePicture.defaultExpectation = &IPictureRepoMockCreatePictureExpectation{}
	}

	mmCreatePicture.defaultExpectation.params = &IPictureRepoMockCreatePictureParams{ctx, record}
	for _, e := range mmCreatePicture.expectations {
		if minimock.Equal(e.params, mmCreatePicture.defaultExpectation.params) {
			mmCreatePicture.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePicture.defaultExpectation.params)
		}
	}

	return mmCreatePicture
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Inspect(f func(ctx context.Context, record model.Picture)) *mIPictureRepoMockCreatePicture {
	if mmCreatePicture.mock.inspectFuncCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.CreatePicture")
	}

	mmCreatePicture.mock.inspectFuncCreatePicture = f

	return mmCreatePicture
}

// Return sets up results that will be returned by IPictureRepo.CreatePicture
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Return(i1 int, err error) *IPictureRepoMock {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	if mmCreatePicture.defaultExpectation == nil {
		mmCreatePicture.defaultExpectation = &IPictureRepoMockCreatePictureExpectation{mock: mmCreatePicture.mock}
	}
	mmCreatePicture.defaultExpectation.results = &IPictureRepoMockCreatePictureResults{i1, err}
	return mmCreatePicture.mock
}

// Set uses given function f to mock the IPictureRepo.CreatePicture method
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Set(f func(ctx context.Context, record model.Picture) (i1 int, err error)) *IPictureRepoMock {
	if mmCreatePicture.defaultExpectation != nil {
		mmCreatePicture.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.CreatePicture method")
	}

	if len(mmCreatePicture.expectations) > 0 {
		mmCreatePicture.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.CreatePicture method")
	}

	mmCreatePicture.mock.funcCreatePicture = f
	return mmCreatePicture.mock
}

// When sets expectation for the IPictureRepo.CreatePicture which will trigger the result defined by the following
// Then helper
func (mmCreatePicture *mIPictureRepoMockCreatePicture) When(ctx context.Context, record model.Picture) *IPictureRepoMockCreatePictureExpectation {
	if mmCreatePicture.mock.funcCreatePicture != nil {
		mmCreatePicture.mock.t.Fatalf("IPictureRepoMock.CreatePicture mock is already set by Set")
	}

	expectation := &IPictureRepoMockCreatePictureExpectation{
		mock:   mmCreatePicture.mock,
		params: &IPictureRepoMockCreatePictureParams{ctx, record},
	}
	mmCreatePicture.expectations = append(mmCreatePicture.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.CreatePicture return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockCreatePictureExpectation) Then(i1 int, err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockCreatePictureResults{i1, err}
	return e.mock
}

// CreatePicture implements IPictureRepo
func (mmCreatePicture *IPictureRepoMock) CreatePicture(ctx context.Context, record model.Picture) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreatePicture.beforeCreatePictureCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePicture.afterCreatePictureCounter, 1)

	if mmCreatePicture.inspectFuncCreatePicture != nil {
		mmCreatePicture.inspectFuncCreatePicture(ctx, record)
	}

	mm_params := &IPictureRepoMockCreatePictureParams{ctx, record}

	// Record call args
	mmCreatePicture.CreatePictureMock.mutex.Lock()
	mmCreatePicture.CreatePictureMock.callArgs = append(mmCreatePicture.CreatePictureMock.callArgs, mm_params)
	mmCreatePicture.CreatePictureMock.mutex.Unlock()

	for _, e := range mmCreatePicture.CreatePictureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreatePicture.CreatePictureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePicture.CreatePictureMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePicture.CreatePictureMock.defaultExpectation.params
		mm_got := IPictureRepoMockCreatePictureParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePicture.t.Errorf("IPictureRepoMock.CreatePicture got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePicture.CreatePictureMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePicture.t.Fatal("No results are set for the IPictureRepoMock.CreatePicture")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreatePicture.funcCreatePicture != nil {
		return mmCreatePicture.funcCreatePicture(ctx, record)
	}
	mmCreatePicture.t.Fatalf("Unexpected call to IPictureRepoMock.CreatePicture. %v %v", ctx, record)
	return
}

// CreatePictureAfterCounter returns a count of finished IPictureRepoMock.CreatePicture invocations
func (mmCreatePicture *IPictureRepoMock) CreatePictureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePicture.afterCreatePictureCounter)
}

// CreatePictureBeforeCounter returns a count of IPictureRepoMock.CreatePicture invocations
func (mmCreatePicture *IPictureRepoMock) CreatePictureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePicture.beforeCreatePictureCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.CreatePicture.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePicture *mIPictureRepoMockCreatePicture) Calls() []*IPictureRepoMockCreatePictureParams {
	mmCreatePicture.mutex.RLock()

	argCopy := make([]*IPictureRepoMockCreatePictureParams, len(mmCreatePicture.callArgs))
	copy(argCopy, mmCreatePicture.callArgs)

	mmCreatePicture.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePictureDone returns true if the count of the CreatePicture invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockCreatePictureDone() bool {
	for _, e := range m.CreatePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePicture != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreatePictureInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockCreatePictureInspect() {
	for _, e := range m.CreatePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.CreatePicture with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		if m.CreatePictureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.CreatePicture")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.CreatePicture with params: %#v", *m.CreatePictureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePicture != nil && mm_atomic.LoadUint64(&m.afterCreatePictureCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.CreatePicture")
	}
}

type mIPictureRepoMockDeletePicture struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockDeletePictureExpectation
	expectations       []*IPictureRepoMockDeletePictureExpectation

	callArgs []*IPictureRepoMockDeletePictureParams
	mutex    sync.RWMutex
}

// IPictureRepoMockDeletePictureExpectation specifies expectation struct of the IPictureRepo.DeletePicture
type IPictureRepoMockDeletePictureExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockDeletePictureParams
	results *IPictureRepoMockDeletePictureResults
	Counter uint64
}

// IPictureRepoMockDeletePictureParams contains parameters of the IPictureRepo.DeletePicture
type IPictureRepoMockDeletePictureParams struct {
	ctx context.Context
	id  int
}

// IPictureRepoMockDeletePictureResults contains results of the IPictureRepo.DeletePicture
type IPictureRepoMockDeletePictureResults struct {
	err error
}

// Expect sets up expected params for IPictureRepo.DeletePicture
func (mmDeletePicture *mIPictureRepoMockDeletePicture) Expect(ctx context.Context, id int) *mIPictureRepoMockDeletePicture {
	if mmDeletePicture.mock.funcDeletePicture != nil {
		mmDeletePicture.mock.t.Fatalf("IPictureRepoMock.DeletePicture mock is already set by Set")
	}

	if mmDeletePicture.defaultExpectation == nil {
		mmDeletePicture.defaultExpectation = &IPictureRepoMockDeletePictureExpectation{}
	}

	mmDeletePicture.defaultExpectation.params = &IPictureRepoMockDeletePictureParams{ctx, id}
	for _, e := range mmDeletePicture.expectations {
		if minimock.Equal(e.params, mmDeletePicture.defaultExpectation.params) {
			mmDeletePicture.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePicture.defaultExpectation.params)
		}
	}

	return mmDeletePicture
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.DeletePicture
func (mmDeletePicture *mIPictureRepoMockDeletePicture) Inspect(f func(ctx context.Context, id int)) *mIPictureRepoMockDeletePicture {
	if mmDeletePicture.mock.inspectFuncDeletePicture != nil {
		mmDeletePicture.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.DeletePicture")
	}

	mmDeletePicture.mock.inspectFuncDeletePicture = f

	return mmDeletePicture
}

// Return sets up results that will be returned by IPictureRepo.DeletePicture
func (mmDeletePicture *mIPictureRepoMockDeletePicture) Return(err error) *IPictureRepoMock {
	if mmDeletePicture.mock.funcDeletePicture != nil {
		mmDeletePicture.mock.t.Fatalf("IPictureRepoMock.DeletePicture mock is already set by Set")
	}

	if mmDeletePicture.defaultExpectation == nil {
		mmDeletePicture.defaultExpectation = &IPictureRepoMockDeletePictureExpectation{mock: mmDeletePicture.mock}
	}
	mmDeletePicture.defaultExpectation.results = &IPictureRepoMockDeletePictureResults{err}
	return mmDeletePicture.mock
}

// Set uses given function f to mock the IPictureRepo.DeletePicture method
func (mmDeletePicture *mIPictureRepoMockDeletePicture) Set(f func(ctx context.Context, id int) (err error)) *IPictureRepoMock {
	if mmDeletePicture.defaultExpectation != nil {
		mmDeletePicture.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.DeletePicture method")
	}

	if len(mmDeletePicture.expectations) > 0 {
		mmDeletePicture.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.DeletePicture method")
	}

	mmDeletePicture.mock.funcDeletePicture = f
	return mmDeletePicture.mock
}

// When sets expectation for the IPictureRepo.DeletePicture which will trigger the result defined by the following
// Then helper
func (mmDeletePicture *mIPictureRepoMockDeletePicture) When(ctx context.Context, id int) *IPictureRepoMockDeletePictureExpectation {
	if mmDeletePicture.mock.funcDeletePicture != nil {
		mmDeletePicture.mock.t.Fatalf("IPictureRepoMock.DeletePicture mock is already set by Set")
	}

	expectation := &IPictureRepoMockDeletePictureExpectation{
		mock:   mmDeletePicture.mock,
		params: &IPictureRepoMockDeletePictureParams{ctx, id},
	}
	mmDeletePicture.expectations = append(mmDeletePicture.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.DeletePicture return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockDeletePictureExpectation) Then(err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockDeletePictureResults{err}
	return e.mock
}

// DeletePicture implements IPictureRepo
func (mmDeletePicture *IPictureRepoMock) DeletePicture(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeletePicture.beforeDeletePictureCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePicture.afterDeletePictureCounter, 1)

	if mmDeletePicture.inspectFuncDeletePicture != nil {
		mmDeletePicture.inspectFuncDeletePicture(ctx, id)
	}

	mm_params := &IPictureRepoMockDeletePictureParams{ctx, id}

	// Record call args
	mmDeletePicture.DeletePictureMock.mutex.Lock()
	mmDeletePicture.DeletePictureMock.callArgs = append(mmDeletePicture.DeletePictureMock.callArgs, mm_params)
	mmDeletePicture.DeletePictureMock.mutex.Unlock()

	for _, e := range mmDeletePicture.DeletePictureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePicture.DeletePictureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePicture.DeletePictureMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePicture.DeletePictureMock.defaultExpectation.params
		mm_got := IPictureRepoMockDeletePictureParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePicture.t.Errorf("IPictureRepoMock.DeletePicture got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePicture.DeletePictureMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePicture.t.Fatal("No results are set for the IPictureRepoMock.DeletePicture")
		}
		return (*mm_results).err
	}
	if mmDeletePicture.funcDeletePicture != nil {
		return mmDeletePicture.funcDeletePicture(ctx, id)
	}
	mmDeletePicture.t.Fatalf("Unexpected call to IPictureRepoMock.DeletePicture. %v %v", ctx, id)
	return
}

// DeletePictureAfterCounter returns a count of finished IPictureRepoMock.DeletePicture invocations
func (mmDeletePicture *IPictureRepoMock) DeletePictureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePicture.afterDeletePictureCounter)
}

// DeletePictureBeforeCounter returns a count of IPictureRepoMock.DeletePicture invocations
func (mmDeletePicture *IPictureRepoMock) DeletePictureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePicture.beforeDeletePictureCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.DeletePicture.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePicture *mIPictureRepoMockDeletePicture) Calls() []*IPictureRepoMockDeletePictureParams {
	mmDeletePicture.mutex.RLock()

	argCopy := make([]*IPictureRepoMockDeletePictureParams, len(mmDeletePicture.callArgs))
	copy(argCopy, mmDeletePicture.callArgs)

	mmDeletePicture.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePictureDone returns true if the count of the DeletePicture invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockDeletePictureDone() bool {
	for _, e := range m.DeletePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePictureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePicture != nil && mm_atomic.LoadUint64(&m.afterDeletePictureCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeletePictureInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockDeletePictureInspect() {
	for _, e := range m.DeletePictureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.DeletePicture with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePictureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePictureCounter) < 1 {
		if m.DeletePictureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.DeletePicture")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.DeletePicture with params: %#v", *m.DeletePictureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePicture != nil && mm_atomic.LoadUint64(&m.afterDeletePictureCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.DeletePicture")
	}
}

type mIPictureRepoMockGetListDorama struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockGetListDoramaExpectation
	expectations       []*IPictureRepoMockGetListDoramaExpectation

	callArgs []*IPictureRepoMockGetListDoramaParams
	mutex    sync.RWMutex
}

// IPictureRepoMockGetListDoramaExpectation specifies expectation struct of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockGetListDoramaParams
	results *IPictureRepoMockGetListDoramaResults
	Counter uint64
}

// IPictureRepoMockGetListDoramaParams contains parameters of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaParams struct {
	ctx      context.Context
	idDorama int
}

// IPictureRepoMockGetListDoramaResults contains results of the IPictureRepo.GetListDorama
type IPictureRepoMockGetListDoramaResults struct {
	pa1 []model.Picture
	err error
}

// Expect sets up expected params for IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Expect(ctx context.Context, idDorama int) *mIPictureRepoMockGetListDorama {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IPictureRepoMockGetListDoramaExpectation{}
	}

	mmGetListDorama.defaultExpectation.params = &IPictureRepoMockGetListDoramaParams{ctx, idDorama}
	for _, e := range mmGetListDorama.expectations {
		if minimock.Equal(e.params, mmGetListDorama.defaultExpectation.params) {
			mmGetListDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListDorama.defaultExpectation.params)
		}
	}

	return mmGetListDorama
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Inspect(f func(ctx context.Context, idDorama int)) *mIPictureRepoMockGetListDorama {
	if mmGetListDorama.mock.inspectFuncGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.GetListDorama")
	}

	mmGetListDorama.mock.inspectFuncGetListDorama = f

	return mmGetListDorama
}

// Return sets up results that will be returned by IPictureRepo.GetListDorama
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Return(pa1 []model.Picture, err error) *IPictureRepoMock {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IPictureRepoMockGetListDoramaExpectation{mock: mmGetListDorama.mock}
	}
	mmGetListDorama.defaultExpectation.results = &IPictureRepoMockGetListDoramaResults{pa1, err}
	return mmGetListDorama.mock
}

// Set uses given function f to mock the IPictureRepo.GetListDorama method
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Set(f func(ctx context.Context, idDorama int) (pa1 []model.Picture, err error)) *IPictureRepoMock {
	if mmGetListDorama.defaultExpectation != nil {
		mmGetListDorama.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.GetListDorama method")
	}

	if len(mmGetListDorama.expectations) > 0 {
		mmGetListDorama.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.GetListDorama method")
	}

	mmGetListDorama.mock.funcGetListDorama = f
	return mmGetListDorama.mock
}

// When sets expectation for the IPictureRepo.GetListDorama which will trigger the result defined by the following
// Then helper
func (mmGetListDorama *mIPictureRepoMockGetListDorama) When(ctx context.Context, idDorama int) *IPictureRepoMockGetListDoramaExpectation {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IPictureRepoMock.GetListDorama mock is already set by Set")
	}

	expectation := &IPictureRepoMockGetListDoramaExpectation{
		mock:   mmGetListDorama.mock,
		params: &IPictureRepoMockGetListDoramaParams{ctx, idDorama},
	}
	mmGetListDorama.expectations = append(mmGetListDorama.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.GetListDorama return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockGetListDoramaExpectation) Then(pa1 []model.Picture, err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockGetListDoramaResults{pa1, err}
	return e.mock
}

// GetListDorama implements IPictureRepo
func (mmGetListDorama *IPictureRepoMock) GetListDorama(ctx context.Context, idDorama int) (pa1 []model.Picture, err error) {
	mm_atomic.AddUint64(&mmGetListDorama.beforeGetListDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListDorama.afterGetListDoramaCounter, 1)

	if mmGetListDorama.inspectFuncGetListDorama != nil {
		mmGetListDorama.inspectFuncGetListDorama(ctx, idDorama)
	}

	mm_params := &IPictureRepoMockGetListDoramaParams{ctx, idDorama}

	// Record call args
	mmGetListDorama.GetListDoramaMock.mutex.Lock()
	mmGetListDorama.GetListDoramaMock.callArgs = append(mmGetListDorama.GetListDoramaMock.callArgs, mm_params)
	mmGetListDorama.GetListDoramaMock.mutex.Unlock()

	for _, e := range mmGetListDorama.GetListDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetListDorama.GetListDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListDorama.GetListDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListDorama.GetListDoramaMock.defaultExpectation.params
		mm_got := IPictureRepoMockGetListDoramaParams{ctx, idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListDorama.t.Errorf("IPictureRepoMock.GetListDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListDorama.GetListDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListDorama.t.Fatal("No results are set for the IPictureRepoMock.GetListDorama")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetListDorama.funcGetListDorama != nil {
		return mmGetListDorama.funcGetListDorama(ctx, idDorama)
	}
	mmGetListDorama.t.Fatalf("Unexpected call to IPictureRepoMock.GetListDorama. %v %v", ctx, idDorama)
	return
}

// GetListDoramaAfterCounter returns a count of finished IPictureRepoMock.GetListDorama invocations
func (mmGetListDorama *IPictureRepoMock) GetListDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.afterGetListDoramaCounter)
}

// GetListDoramaBeforeCounter returns a count of IPictureRepoMock.GetListDorama invocations
func (mmGetListDorama *IPictureRepoMock) GetListDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.beforeGetListDoramaCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.GetListDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListDorama *mIPictureRepoMockGetListDorama) Calls() []*IPictureRepoMockGetListDoramaParams {
	mmGetListDorama.mutex.RLock()

	argCopy := make([]*IPictureRepoMockGetListDoramaParams, len(mmGetListDorama.callArgs))
	copy(argCopy, mmGetListDorama.callArgs)

	mmGetListDorama.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDoramaDone returns true if the count of the GetListDorama invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockGetListDoramaDone() bool {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListDoramaInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockGetListDoramaInspect() {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		if m.GetListDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.GetListDorama")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListDorama with params: %#v", *m.GetListDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.GetListDorama")
	}
}

type mIPictureRepoMockGetListStaff struct {
	mock               *IPictureRepoMock
	defaultExpectation *IPictureRepoMockGetListStaffExpectation
	expectations       []*IPictureRepoMockGetListStaffExpectation

	callArgs []*IPictureRepoMockGetListStaffParams
	mutex    sync.RWMutex
}

// IPictureRepoMockGetListStaffExpectation specifies expectation struct of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffExpectation struct {
	mock    *IPictureRepoMock
	params  *IPictureRepoMockGetListStaffParams
	results *IPictureRepoMockGetListStaffResults
	Counter uint64
}

// IPictureRepoMockGetListStaffParams contains parameters of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffParams struct {
	ctx     context.Context
	idStaff int
}

// IPictureRepoMockGetListStaffResults contains results of the IPictureRepo.GetListStaff
type IPictureRepoMockGetListStaffResults struct {
	pa1 []model.Picture
	err error
}

// Expect sets up expected params for IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Expect(ctx context.Context, idStaff int) *mIPictureRepoMockGetListStaff {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	if mmGetListStaff.defaultExpectation == nil {
		mmGetListStaff.defaultExpectation = &IPictureRepoMockGetListStaffExpectation{}
	}

	mmGetListStaff.defaultExpectation.params = &IPictureRepoMockGetListStaffParams{ctx, idStaff}
	for _, e := range mmGetListStaff.expectations {
		if minimock.Equal(e.params, mmGetListStaff.defaultExpectation.params) {
			mmGetListStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListStaff.defaultExpectation.params)
		}
	}

	return mmGetListStaff
}

// Inspect accepts an inspector function that has same arguments as the IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Inspect(f func(ctx context.Context, idStaff int)) *mIPictureRepoMockGetListStaff {
	if mmGetListStaff.mock.inspectFuncGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("Inspect function is already set for IPictureRepoMock.GetListStaff")
	}

	mmGetListStaff.mock.inspectFuncGetListStaff = f

	return mmGetListStaff
}

// Return sets up results that will be returned by IPictureRepo.GetListStaff
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Return(pa1 []model.Picture, err error) *IPictureRepoMock {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	if mmGetListStaff.defaultExpectation == nil {
		mmGetListStaff.defaultExpectation = &IPictureRepoMockGetListStaffExpectation{mock: mmGetListStaff.mock}
	}
	mmGetListStaff.defaultExpectation.results = &IPictureRepoMockGetListStaffResults{pa1, err}
	return mmGetListStaff.mock
}

// Set uses given function f to mock the IPictureRepo.GetListStaff method
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Set(f func(ctx context.Context, idStaff int) (pa1 []model.Picture, err error)) *IPictureRepoMock {
	if mmGetListStaff.defaultExpectation != nil {
		mmGetListStaff.mock.t.Fatalf("Default expectation is already set for the IPictureRepo.GetListStaff method")
	}

	if len(mmGetListStaff.expectations) > 0 {
		mmGetListStaff.mock.t.Fatalf("Some expectations are already set for the IPictureRepo.GetListStaff method")
	}

	mmGetListStaff.mock.funcGetListStaff = f
	return mmGetListStaff.mock
}

// When sets expectation for the IPictureRepo.GetListStaff which will trigger the result defined by the following
// Then helper
func (mmGetListStaff *mIPictureRepoMockGetListStaff) When(ctx context.Context, idStaff int) *IPictureRepoMockGetListStaffExpectation {
	if mmGetListStaff.mock.funcGetListStaff != nil {
		mmGetListStaff.mock.t.Fatalf("IPictureRepoMock.GetListStaff mock is already set by Set")
	}

	expectation := &IPictureRepoMockGetListStaffExpectation{
		mock:   mmGetListStaff.mock,
		params: &IPictureRepoMockGetListStaffParams{ctx, idStaff},
	}
	mmGetListStaff.expectations = append(mmGetListStaff.expectations, expectation)
	return expectation
}

// Then sets up IPictureRepo.GetListStaff return parameters for the expectation previously defined by the When method
func (e *IPictureRepoMockGetListStaffExpectation) Then(pa1 []model.Picture, err error) *IPictureRepoMock {
	e.results = &IPictureRepoMockGetListStaffResults{pa1, err}
	return e.mock
}

// GetListStaff implements IPictureRepo
func (mmGetListStaff *IPictureRepoMock) GetListStaff(ctx context.Context, idStaff int) (pa1 []model.Picture, err error) {
	mm_atomic.AddUint64(&mmGetListStaff.beforeGetListStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListStaff.afterGetListStaffCounter, 1)

	if mmGetListStaff.inspectFuncGetListStaff != nil {
		mmGetListStaff.inspectFuncGetListStaff(ctx, idStaff)
	}

	mm_params := &IPictureRepoMockGetListStaffParams{ctx, idStaff}

	// Record call args
	mmGetListStaff.GetListStaffMock.mutex.Lock()
	mmGetListStaff.GetListStaffMock.callArgs = append(mmGetListStaff.GetListStaffMock.callArgs, mm_params)
	mmGetListStaff.GetListStaffMock.mutex.Unlock()

	for _, e := range mmGetListStaff.GetListStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetListStaff.GetListStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListStaff.GetListStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListStaff.GetListStaffMock.defaultExpectation.params
		mm_got := IPictureRepoMockGetListStaffParams{ctx, idStaff}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListStaff.t.Errorf("IPictureRepoMock.GetListStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListStaff.GetListStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListStaff.t.Fatal("No results are set for the IPictureRepoMock.GetListStaff")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetListStaff.funcGetListStaff != nil {
		return mmGetListStaff.funcGetListStaff(ctx, idStaff)
	}
	mmGetListStaff.t.Fatalf("Unexpected call to IPictureRepoMock.GetListStaff. %v %v", ctx, idStaff)
	return
}

// GetListStaffAfterCounter returns a count of finished IPictureRepoMock.GetListStaff invocations
func (mmGetListStaff *IPictureRepoMock) GetListStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListStaff.afterGetListStaffCounter)
}

// GetListStaffBeforeCounter returns a count of IPictureRepoMock.GetListStaff invocations
func (mmGetListStaff *IPictureRepoMock) GetListStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListStaff.beforeGetListStaffCounter)
}

// Calls returns a list of arguments used in each call to IPictureRepoMock.GetListStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListStaff *mIPictureRepoMockGetListStaff) Calls() []*IPictureRepoMockGetListStaffParams {
	mmGetListStaff.mutex.RLock()

	argCopy := make([]*IPictureRepoMockGetListStaffParams, len(mmGetListStaff.callArgs))
	copy(argCopy, mmGetListStaff.callArgs)

	mmGetListStaff.mutex.RUnlock()

	return argCopy
}

// MinimockGetListStaffDone returns true if the count of the GetListStaff invocations corresponds
// the number of defined expectations
func (m *IPictureRepoMock) MinimockGetListStaffDone() bool {
	for _, e := range m.GetListStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListStaff != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListStaffInspect logs each unmet expectation
func (m *IPictureRepoMock) MinimockGetListStaffInspect() {
	for _, e := range m.GetListStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		if m.GetListStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPictureRepoMock.GetListStaff")
		} else {
			m.t.Errorf("Expected call to IPictureRepoMock.GetListStaff with params: %#v", *m.GetListStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListStaff != nil && mm_atomic.LoadUint64(&m.afterGetListStaffCounter) < 1 {
		m.t.Error("Expected call to IPictureRepoMock.GetListStaff")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPictureRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddPictureToDoramaInspect()

		m.MinimockAddPictureToStaffInspect()

		m.MinimockCreatePictureInspect()

		m.MinimockDeletePictureInspect()

		m.MinimockGetListDoramaInspect()

		m.MinimockGetListStaffInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPictureRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPictureRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPictureToDoramaDone() &&
		m.MinimockAddPictureToStaffDone() &&
		m.MinimockCreatePictureDone() &&
		m.MinimockDeletePictureDone() &&
		m.MinimockGetListDoramaDone() &&
		m.MinimockGetListStaffDone()
}
