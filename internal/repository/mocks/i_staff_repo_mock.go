package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces.IStaffRepo -o ..\repository\mocks\i_staff_repo_mock_test.go -n IStaffRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IStaffRepoMock implements interfaces.IStaffRepo
type IStaffRepoMock struct {
	t minimock.Tester

	funcCreateStaff          func(record model.Staff) (err error)
	inspectFuncCreateStaff   func(record model.Staff)
	afterCreateStaffCounter  uint64
	beforeCreateStaffCounter uint64
	CreateStaffMock          mIStaffRepoMockCreateStaff

	funcGetList          func() (sa1 []model.Staff, err error)
	inspectFuncGetList   func()
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mIStaffRepoMockGetList

	funcGetListDorama          func(idDorama int) (sa1 []model.Staff, err error)
	inspectFuncGetListDorama   func(idDorama int)
	afterGetListDoramaCounter  uint64
	beforeGetListDoramaCounter uint64
	GetListDoramaMock          mIStaffRepoMockGetListDorama

	funcGetListName          func(name string) (sa1 []model.Staff, err error)
	inspectFuncGetListName   func(name string)
	afterGetListNameCounter  uint64
	beforeGetListNameCounter uint64
	GetListNameMock          mIStaffRepoMockGetListName

	funcUpdateStaff          func(record model.Staff) (err error)
	inspectFuncUpdateStaff   func(record model.Staff)
	afterUpdateStaffCounter  uint64
	beforeUpdateStaffCounter uint64
	UpdateStaffMock          mIStaffRepoMockUpdateStaff
}

// NewIStaffRepoMock returns a mock for interfaces.IStaffRepo
func NewIStaffRepoMock(t minimock.Tester) *IStaffRepoMock {
	m := &IStaffRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateStaffMock = mIStaffRepoMockCreateStaff{mock: m}
	m.CreateStaffMock.callArgs = []*IStaffRepoMockCreateStaffParams{}

	m.GetListMock = mIStaffRepoMockGetList{mock: m}

	m.GetListDoramaMock = mIStaffRepoMockGetListDorama{mock: m}
	m.GetListDoramaMock.callArgs = []*IStaffRepoMockGetListDoramaParams{}

	m.GetListNameMock = mIStaffRepoMockGetListName{mock: m}
	m.GetListNameMock.callArgs = []*IStaffRepoMockGetListNameParams{}

	m.UpdateStaffMock = mIStaffRepoMockUpdateStaff{mock: m}
	m.UpdateStaffMock.callArgs = []*IStaffRepoMockUpdateStaffParams{}

	return m
}

type mIStaffRepoMockCreateStaff struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockCreateStaffExpectation
	expectations       []*IStaffRepoMockCreateStaffExpectation

	callArgs []*IStaffRepoMockCreateStaffParams
	mutex    sync.RWMutex
}

// IStaffRepoMockCreateStaffExpectation specifies expectation struct of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockCreateStaffParams
	results *IStaffRepoMockCreateStaffResults
	Counter uint64
}

// IStaffRepoMockCreateStaffParams contains parameters of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffParams struct {
	record model.Staff
}

// IStaffRepoMockCreateStaffResults contains results of the IStaffRepo.CreateStaff
type IStaffRepoMockCreateStaffResults struct {
	err error
}

// Expect sets up expected params for IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Expect(record model.Staff) *mIStaffRepoMockCreateStaff {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	if mmCreateStaff.defaultExpectation == nil {
		mmCreateStaff.defaultExpectation = &IStaffRepoMockCreateStaffExpectation{}
	}

	mmCreateStaff.defaultExpectation.params = &IStaffRepoMockCreateStaffParams{record}
	for _, e := range mmCreateStaff.expectations {
		if minimock.Equal(e.params, mmCreateStaff.defaultExpectation.params) {
			mmCreateStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateStaff.defaultExpectation.params)
		}
	}

	return mmCreateStaff
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Inspect(f func(record model.Staff)) *mIStaffRepoMockCreateStaff {
	if mmCreateStaff.mock.inspectFuncCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.CreateStaff")
	}

	mmCreateStaff.mock.inspectFuncCreateStaff = f

	return mmCreateStaff
}

// Return sets up results that will be returned by IStaffRepo.CreateStaff
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Return(err error) *IStaffRepoMock {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	if mmCreateStaff.defaultExpectation == nil {
		mmCreateStaff.defaultExpectation = &IStaffRepoMockCreateStaffExpectation{mock: mmCreateStaff.mock}
	}
	mmCreateStaff.defaultExpectation.results = &IStaffRepoMockCreateStaffResults{err}
	return mmCreateStaff.mock
}

// Set uses given function f to mock the IStaffRepo.CreateStaff method
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Set(f func(record model.Staff) (err error)) *IStaffRepoMock {
	if mmCreateStaff.defaultExpectation != nil {
		mmCreateStaff.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.CreateStaff method")
	}

	if len(mmCreateStaff.expectations) > 0 {
		mmCreateStaff.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.CreateStaff method")
	}

	mmCreateStaff.mock.funcCreateStaff = f
	return mmCreateStaff.mock
}

// When sets expectation for the IStaffRepo.CreateStaff which will trigger the result defined by the following
// Then helper
func (mmCreateStaff *mIStaffRepoMockCreateStaff) When(record model.Staff) *IStaffRepoMockCreateStaffExpectation {
	if mmCreateStaff.mock.funcCreateStaff != nil {
		mmCreateStaff.mock.t.Fatalf("IStaffRepoMock.CreateStaff mock is already set by Set")
	}

	expectation := &IStaffRepoMockCreateStaffExpectation{
		mock:   mmCreateStaff.mock,
		params: &IStaffRepoMockCreateStaffParams{record},
	}
	mmCreateStaff.expectations = append(mmCreateStaff.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.CreateStaff return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockCreateStaffExpectation) Then(err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockCreateStaffResults{err}
	return e.mock
}

// CreateStaff implements interfaces.IStaffRepo
func (mmCreateStaff *IStaffRepoMock) CreateStaff(record model.Staff) (err error) {
	mm_atomic.AddUint64(&mmCreateStaff.beforeCreateStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateStaff.afterCreateStaffCounter, 1)

	if mmCreateStaff.inspectFuncCreateStaff != nil {
		mmCreateStaff.inspectFuncCreateStaff(record)
	}

	mm_params := &IStaffRepoMockCreateStaffParams{record}

	// Record call args
	mmCreateStaff.CreateStaffMock.mutex.Lock()
	mmCreateStaff.CreateStaffMock.callArgs = append(mmCreateStaff.CreateStaffMock.callArgs, mm_params)
	mmCreateStaff.CreateStaffMock.mutex.Unlock()

	for _, e := range mmCreateStaff.CreateStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateStaff.CreateStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateStaff.CreateStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateStaff.CreateStaffMock.defaultExpectation.params
		mm_got := IStaffRepoMockCreateStaffParams{record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateStaff.t.Errorf("IStaffRepoMock.CreateStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateStaff.CreateStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateStaff.t.Fatal("No results are set for the IStaffRepoMock.CreateStaff")
		}
		return (*mm_results).err
	}
	if mmCreateStaff.funcCreateStaff != nil {
		return mmCreateStaff.funcCreateStaff(record)
	}
	mmCreateStaff.t.Fatalf("Unexpected call to IStaffRepoMock.CreateStaff. %v", record)
	return
}

// CreateStaffAfterCounter returns a count of finished IStaffRepoMock.CreateStaff invocations
func (mmCreateStaff *IStaffRepoMock) CreateStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStaff.afterCreateStaffCounter)
}

// CreateStaffBeforeCounter returns a count of IStaffRepoMock.CreateStaff invocations
func (mmCreateStaff *IStaffRepoMock) CreateStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStaff.beforeCreateStaffCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.CreateStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateStaff *mIStaffRepoMockCreateStaff) Calls() []*IStaffRepoMockCreateStaffParams {
	mmCreateStaff.mutex.RLock()

	argCopy := make([]*IStaffRepoMockCreateStaffParams, len(mmCreateStaff.callArgs))
	copy(argCopy, mmCreateStaff.callArgs)

	mmCreateStaff.mutex.RUnlock()

	return argCopy
}

// MinimockCreateStaffDone returns true if the count of the CreateStaff invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockCreateStaffDone() bool {
	for _, e := range m.CreateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateStaff != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateStaffInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockCreateStaffInspect() {
	for _, e := range m.CreateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.CreateStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		if m.CreateStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.CreateStaff")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.CreateStaff with params: %#v", *m.CreateStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateStaff != nil && mm_atomic.LoadUint64(&m.afterCreateStaffCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.CreateStaff")
	}
}

type mIStaffRepoMockGetList struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListExpectation
	expectations       []*IStaffRepoMockGetListExpectation
}

// IStaffRepoMockGetListExpectation specifies expectation struct of the IStaffRepo.GetList
type IStaffRepoMockGetListExpectation struct {
	mock *IStaffRepoMock

	results *IStaffRepoMockGetListResults
	Counter uint64
}

// IStaffRepoMockGetListResults contains results of the IStaffRepo.GetList
type IStaffRepoMockGetListResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetList
func (mmGetList *mIStaffRepoMockGetList) Expect() *mIStaffRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IStaffRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IStaffRepoMockGetListExpectation{}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetList
func (mmGetList *mIStaffRepoMockGetList) Inspect(f func()) *mIStaffRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by IStaffRepo.GetList
func (mmGetList *mIStaffRepoMockGetList) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("IStaffRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &IStaffRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &IStaffRepoMockGetListResults{sa1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the IStaffRepo.GetList method
func (mmGetList *mIStaffRepoMockGetList) Set(f func() (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// GetList implements interfaces.IStaffRepo
func (mmGetList *IStaffRepoMock) GetList() (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList()
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the IStaffRepoMock.GetList")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList()
	}
	mmGetList.t.Fatalf("Unexpected call to IStaffRepoMock.GetList.")
	return
}

// GetListAfterCounter returns a count of finished IStaffRepoMock.GetList invocations
func (mmGetList *IStaffRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of IStaffRepoMock.GetList invocations
func (mmGetList *IStaffRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IStaffRepoMock.GetList")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetList")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetList")
	}
}

type mIStaffRepoMockGetListDorama struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListDoramaExpectation
	expectations       []*IStaffRepoMockGetListDoramaExpectation

	callArgs []*IStaffRepoMockGetListDoramaParams
	mutex    sync.RWMutex
}

// IStaffRepoMockGetListDoramaExpectation specifies expectation struct of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockGetListDoramaParams
	results *IStaffRepoMockGetListDoramaResults
	Counter uint64
}

// IStaffRepoMockGetListDoramaParams contains parameters of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaParams struct {
	idDorama int
}

// IStaffRepoMockGetListDoramaResults contains results of the IStaffRepo.GetListDorama
type IStaffRepoMockGetListDoramaResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Expect(idDorama int) *mIStaffRepoMockGetListDorama {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IStaffRepoMockGetListDoramaExpectation{}
	}

	mmGetListDorama.defaultExpectation.params = &IStaffRepoMockGetListDoramaParams{idDorama}
	for _, e := range mmGetListDorama.expectations {
		if minimock.Equal(e.params, mmGetListDorama.defaultExpectation.params) {
			mmGetListDorama.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListDorama.defaultExpectation.params)
		}
	}

	return mmGetListDorama
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Inspect(f func(idDorama int)) *mIStaffRepoMockGetListDorama {
	if mmGetListDorama.mock.inspectFuncGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetListDorama")
	}

	mmGetListDorama.mock.inspectFuncGetListDorama = f

	return mmGetListDorama
}

// Return sets up results that will be returned by IStaffRepo.GetListDorama
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	if mmGetListDorama.defaultExpectation == nil {
		mmGetListDorama.defaultExpectation = &IStaffRepoMockGetListDoramaExpectation{mock: mmGetListDorama.mock}
	}
	mmGetListDorama.defaultExpectation.results = &IStaffRepoMockGetListDoramaResults{sa1, err}
	return mmGetListDorama.mock
}

// Set uses given function f to mock the IStaffRepo.GetListDorama method
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Set(f func(idDorama int) (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetListDorama.defaultExpectation != nil {
		mmGetListDorama.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetListDorama method")
	}

	if len(mmGetListDorama.expectations) > 0 {
		mmGetListDorama.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetListDorama method")
	}

	mmGetListDorama.mock.funcGetListDorama = f
	return mmGetListDorama.mock
}

// When sets expectation for the IStaffRepo.GetListDorama which will trigger the result defined by the following
// Then helper
func (mmGetListDorama *mIStaffRepoMockGetListDorama) When(idDorama int) *IStaffRepoMockGetListDoramaExpectation {
	if mmGetListDorama.mock.funcGetListDorama != nil {
		mmGetListDorama.mock.t.Fatalf("IStaffRepoMock.GetListDorama mock is already set by Set")
	}

	expectation := &IStaffRepoMockGetListDoramaExpectation{
		mock:   mmGetListDorama.mock,
		params: &IStaffRepoMockGetListDoramaParams{idDorama},
	}
	mmGetListDorama.expectations = append(mmGetListDorama.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.GetListDorama return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockGetListDoramaExpectation) Then(sa1 []model.Staff, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockGetListDoramaResults{sa1, err}
	return e.mock
}

// GetListDorama implements interfaces.IStaffRepo
func (mmGetListDorama *IStaffRepoMock) GetListDorama(idDorama int) (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetListDorama.beforeGetListDoramaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListDorama.afterGetListDoramaCounter, 1)

	if mmGetListDorama.inspectFuncGetListDorama != nil {
		mmGetListDorama.inspectFuncGetListDorama(idDorama)
	}

	mm_params := &IStaffRepoMockGetListDoramaParams{idDorama}

	// Record call args
	mmGetListDorama.GetListDoramaMock.mutex.Lock()
	mmGetListDorama.GetListDoramaMock.callArgs = append(mmGetListDorama.GetListDoramaMock.callArgs, mm_params)
	mmGetListDorama.GetListDoramaMock.mutex.Unlock()

	for _, e := range mmGetListDorama.GetListDoramaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetListDorama.GetListDoramaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListDorama.GetListDoramaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListDorama.GetListDoramaMock.defaultExpectation.params
		mm_got := IStaffRepoMockGetListDoramaParams{idDorama}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListDorama.t.Errorf("IStaffRepoMock.GetListDorama got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListDorama.GetListDoramaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListDorama.t.Fatal("No results are set for the IStaffRepoMock.GetListDorama")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetListDorama.funcGetListDorama != nil {
		return mmGetListDorama.funcGetListDorama(idDorama)
	}
	mmGetListDorama.t.Fatalf("Unexpected call to IStaffRepoMock.GetListDorama. %v", idDorama)
	return
}

// GetListDoramaAfterCounter returns a count of finished IStaffRepoMock.GetListDorama invocations
func (mmGetListDorama *IStaffRepoMock) GetListDoramaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.afterGetListDoramaCounter)
}

// GetListDoramaBeforeCounter returns a count of IStaffRepoMock.GetListDorama invocations
func (mmGetListDorama *IStaffRepoMock) GetListDoramaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListDorama.beforeGetListDoramaCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.GetListDorama.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListDorama *mIStaffRepoMockGetListDorama) Calls() []*IStaffRepoMockGetListDoramaParams {
	mmGetListDorama.mutex.RLock()

	argCopy := make([]*IStaffRepoMockGetListDoramaParams, len(mmGetListDorama.callArgs))
	copy(argCopy, mmGetListDorama.callArgs)

	mmGetListDorama.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDoramaDone returns true if the count of the GetListDorama invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListDoramaDone() bool {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListDoramaInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListDoramaInspect() {
	for _, e := range m.GetListDoramaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListDorama with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListDoramaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		if m.GetListDoramaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.GetListDorama")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListDorama with params: %#v", *m.GetListDoramaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListDorama != nil && mm_atomic.LoadUint64(&m.afterGetListDoramaCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetListDorama")
	}
}

type mIStaffRepoMockGetListName struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockGetListNameExpectation
	expectations       []*IStaffRepoMockGetListNameExpectation

	callArgs []*IStaffRepoMockGetListNameParams
	mutex    sync.RWMutex
}

// IStaffRepoMockGetListNameExpectation specifies expectation struct of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockGetListNameParams
	results *IStaffRepoMockGetListNameResults
	Counter uint64
}

// IStaffRepoMockGetListNameParams contains parameters of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameParams struct {
	name string
}

// IStaffRepoMockGetListNameResults contains results of the IStaffRepo.GetListName
type IStaffRepoMockGetListNameResults struct {
	sa1 []model.Staff
	err error
}

// Expect sets up expected params for IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Expect(name string) *mIStaffRepoMockGetListName {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IStaffRepoMockGetListNameExpectation{}
	}

	mmGetListName.defaultExpectation.params = &IStaffRepoMockGetListNameParams{name}
	for _, e := range mmGetListName.expectations {
		if minimock.Equal(e.params, mmGetListName.defaultExpectation.params) {
			mmGetListName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListName.defaultExpectation.params)
		}
	}

	return mmGetListName
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Inspect(f func(name string)) *mIStaffRepoMockGetListName {
	if mmGetListName.mock.inspectFuncGetListName != nil {
		mmGetListName.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.GetListName")
	}

	mmGetListName.mock.inspectFuncGetListName = f

	return mmGetListName
}

// Return sets up results that will be returned by IStaffRepo.GetListName
func (mmGetListName *mIStaffRepoMockGetListName) Return(sa1 []model.Staff, err error) *IStaffRepoMock {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	if mmGetListName.defaultExpectation == nil {
		mmGetListName.defaultExpectation = &IStaffRepoMockGetListNameExpectation{mock: mmGetListName.mock}
	}
	mmGetListName.defaultExpectation.results = &IStaffRepoMockGetListNameResults{sa1, err}
	return mmGetListName.mock
}

// Set uses given function f to mock the IStaffRepo.GetListName method
func (mmGetListName *mIStaffRepoMockGetListName) Set(f func(name string) (sa1 []model.Staff, err error)) *IStaffRepoMock {
	if mmGetListName.defaultExpectation != nil {
		mmGetListName.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.GetListName method")
	}

	if len(mmGetListName.expectations) > 0 {
		mmGetListName.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.GetListName method")
	}

	mmGetListName.mock.funcGetListName = f
	return mmGetListName.mock
}

// When sets expectation for the IStaffRepo.GetListName which will trigger the result defined by the following
// Then helper
func (mmGetListName *mIStaffRepoMockGetListName) When(name string) *IStaffRepoMockGetListNameExpectation {
	if mmGetListName.mock.funcGetListName != nil {
		mmGetListName.mock.t.Fatalf("IStaffRepoMock.GetListName mock is already set by Set")
	}

	expectation := &IStaffRepoMockGetListNameExpectation{
		mock:   mmGetListName.mock,
		params: &IStaffRepoMockGetListNameParams{name},
	}
	mmGetListName.expectations = append(mmGetListName.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.GetListName return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockGetListNameExpectation) Then(sa1 []model.Staff, err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockGetListNameResults{sa1, err}
	return e.mock
}

// GetListName implements interfaces.IStaffRepo
func (mmGetListName *IStaffRepoMock) GetListName(name string) (sa1 []model.Staff, err error) {
	mm_atomic.AddUint64(&mmGetListName.beforeGetListNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListName.afterGetListNameCounter, 1)

	if mmGetListName.inspectFuncGetListName != nil {
		mmGetListName.inspectFuncGetListName(name)
	}

	mm_params := &IStaffRepoMockGetListNameParams{name}

	// Record call args
	mmGetListName.GetListNameMock.mutex.Lock()
	mmGetListName.GetListNameMock.callArgs = append(mmGetListName.GetListNameMock.callArgs, mm_params)
	mmGetListName.GetListNameMock.mutex.Unlock()

	for _, e := range mmGetListName.GetListNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetListName.GetListNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListName.GetListNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListName.GetListNameMock.defaultExpectation.params
		mm_got := IStaffRepoMockGetListNameParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListName.t.Errorf("IStaffRepoMock.GetListName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListName.GetListNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListName.t.Fatal("No results are set for the IStaffRepoMock.GetListName")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetListName.funcGetListName != nil {
		return mmGetListName.funcGetListName(name)
	}
	mmGetListName.t.Fatalf("Unexpected call to IStaffRepoMock.GetListName. %v", name)
	return
}

// GetListNameAfterCounter returns a count of finished IStaffRepoMock.GetListName invocations
func (mmGetListName *IStaffRepoMock) GetListNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.afterGetListNameCounter)
}

// GetListNameBeforeCounter returns a count of IStaffRepoMock.GetListName invocations
func (mmGetListName *IStaffRepoMock) GetListNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListName.beforeGetListNameCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.GetListName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListName *mIStaffRepoMockGetListName) Calls() []*IStaffRepoMockGetListNameParams {
	mmGetListName.mutex.RLock()

	argCopy := make([]*IStaffRepoMockGetListNameParams, len(mmGetListName.callArgs))
	copy(argCopy, mmGetListName.callArgs)

	mmGetListName.mutex.RUnlock()

	return argCopy
}

// MinimockGetListNameDone returns true if the count of the GetListName invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockGetListNameDone() bool {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListNameInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockGetListNameInspect() {
	for _, e := range m.GetListNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		if m.GetListNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.GetListName")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.GetListName with params: %#v", *m.GetListNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListName != nil && mm_atomic.LoadUint64(&m.afterGetListNameCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.GetListName")
	}
}

type mIStaffRepoMockUpdateStaff struct {
	mock               *IStaffRepoMock
	defaultExpectation *IStaffRepoMockUpdateStaffExpectation
	expectations       []*IStaffRepoMockUpdateStaffExpectation

	callArgs []*IStaffRepoMockUpdateStaffParams
	mutex    sync.RWMutex
}

// IStaffRepoMockUpdateStaffExpectation specifies expectation struct of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffExpectation struct {
	mock    *IStaffRepoMock
	params  *IStaffRepoMockUpdateStaffParams
	results *IStaffRepoMockUpdateStaffResults
	Counter uint64
}

// IStaffRepoMockUpdateStaffParams contains parameters of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffParams struct {
	record model.Staff
}

// IStaffRepoMockUpdateStaffResults contains results of the IStaffRepo.UpdateStaff
type IStaffRepoMockUpdateStaffResults struct {
	err error
}

// Expect sets up expected params for IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Expect(record model.Staff) *mIStaffRepoMockUpdateStaff {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	if mmUpdateStaff.defaultExpectation == nil {
		mmUpdateStaff.defaultExpectation = &IStaffRepoMockUpdateStaffExpectation{}
	}

	mmUpdateStaff.defaultExpectation.params = &IStaffRepoMockUpdateStaffParams{record}
	for _, e := range mmUpdateStaff.expectations {
		if minimock.Equal(e.params, mmUpdateStaff.defaultExpectation.params) {
			mmUpdateStaff.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStaff.defaultExpectation.params)
		}
	}

	return mmUpdateStaff
}

// Inspect accepts an inspector function that has same arguments as the IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Inspect(f func(record model.Staff)) *mIStaffRepoMockUpdateStaff {
	if mmUpdateStaff.mock.inspectFuncUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("Inspect function is already set for IStaffRepoMock.UpdateStaff")
	}

	mmUpdateStaff.mock.inspectFuncUpdateStaff = f

	return mmUpdateStaff
}

// Return sets up results that will be returned by IStaffRepo.UpdateStaff
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Return(err error) *IStaffRepoMock {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	if mmUpdateStaff.defaultExpectation == nil {
		mmUpdateStaff.defaultExpectation = &IStaffRepoMockUpdateStaffExpectation{mock: mmUpdateStaff.mock}
	}
	mmUpdateStaff.defaultExpectation.results = &IStaffRepoMockUpdateStaffResults{err}
	return mmUpdateStaff.mock
}

// Set uses given function f to mock the IStaffRepo.UpdateStaff method
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Set(f func(record model.Staff) (err error)) *IStaffRepoMock {
	if mmUpdateStaff.defaultExpectation != nil {
		mmUpdateStaff.mock.t.Fatalf("Default expectation is already set for the IStaffRepo.UpdateStaff method")
	}

	if len(mmUpdateStaff.expectations) > 0 {
		mmUpdateStaff.mock.t.Fatalf("Some expectations are already set for the IStaffRepo.UpdateStaff method")
	}

	mmUpdateStaff.mock.funcUpdateStaff = f
	return mmUpdateStaff.mock
}

// When sets expectation for the IStaffRepo.UpdateStaff which will trigger the result defined by the following
// Then helper
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) When(record model.Staff) *IStaffRepoMockUpdateStaffExpectation {
	if mmUpdateStaff.mock.funcUpdateStaff != nil {
		mmUpdateStaff.mock.t.Fatalf("IStaffRepoMock.UpdateStaff mock is already set by Set")
	}

	expectation := &IStaffRepoMockUpdateStaffExpectation{
		mock:   mmUpdateStaff.mock,
		params: &IStaffRepoMockUpdateStaffParams{record},
	}
	mmUpdateStaff.expectations = append(mmUpdateStaff.expectations, expectation)
	return expectation
}

// Then sets up IStaffRepo.UpdateStaff return parameters for the expectation previously defined by the When method
func (e *IStaffRepoMockUpdateStaffExpectation) Then(err error) *IStaffRepoMock {
	e.results = &IStaffRepoMockUpdateStaffResults{err}
	return e.mock
}

// UpdateStaff implements interfaces.IStaffRepo
func (mmUpdateStaff *IStaffRepoMock) UpdateStaff(record model.Staff) (err error) {
	mm_atomic.AddUint64(&mmUpdateStaff.beforeUpdateStaffCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStaff.afterUpdateStaffCounter, 1)

	if mmUpdateStaff.inspectFuncUpdateStaff != nil {
		mmUpdateStaff.inspectFuncUpdateStaff(record)
	}

	mm_params := &IStaffRepoMockUpdateStaffParams{record}

	// Record call args
	mmUpdateStaff.UpdateStaffMock.mutex.Lock()
	mmUpdateStaff.UpdateStaffMock.callArgs = append(mmUpdateStaff.UpdateStaffMock.callArgs, mm_params)
	mmUpdateStaff.UpdateStaffMock.mutex.Unlock()

	for _, e := range mmUpdateStaff.UpdateStaffMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStaff.UpdateStaffMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStaff.UpdateStaffMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStaff.UpdateStaffMock.defaultExpectation.params
		mm_got := IStaffRepoMockUpdateStaffParams{record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStaff.t.Errorf("IStaffRepoMock.UpdateStaff got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStaff.UpdateStaffMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStaff.t.Fatal("No results are set for the IStaffRepoMock.UpdateStaff")
		}
		return (*mm_results).err
	}
	if mmUpdateStaff.funcUpdateStaff != nil {
		return mmUpdateStaff.funcUpdateStaff(record)
	}
	mmUpdateStaff.t.Fatalf("Unexpected call to IStaffRepoMock.UpdateStaff. %v", record)
	return
}

// UpdateStaffAfterCounter returns a count of finished IStaffRepoMock.UpdateStaff invocations
func (mmUpdateStaff *IStaffRepoMock) UpdateStaffAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStaff.afterUpdateStaffCounter)
}

// UpdateStaffBeforeCounter returns a count of IStaffRepoMock.UpdateStaff invocations
func (mmUpdateStaff *IStaffRepoMock) UpdateStaffBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStaff.beforeUpdateStaffCounter)
}

// Calls returns a list of arguments used in each call to IStaffRepoMock.UpdateStaff.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStaff *mIStaffRepoMockUpdateStaff) Calls() []*IStaffRepoMockUpdateStaffParams {
	mmUpdateStaff.mutex.RLock()

	argCopy := make([]*IStaffRepoMockUpdateStaffParams, len(mmUpdateStaff.callArgs))
	copy(argCopy, mmUpdateStaff.callArgs)

	mmUpdateStaff.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStaffDone returns true if the count of the UpdateStaff invocations corresponds
// the number of defined expectations
func (m *IStaffRepoMock) MinimockUpdateStaffDone() bool {
	for _, e := range m.UpdateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStaff != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStaffInspect logs each unmet expectation
func (m *IStaffRepoMock) MinimockUpdateStaffInspect() {
	for _, e := range m.UpdateStaffMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStaffRepoMock.UpdateStaff with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStaffMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		if m.UpdateStaffMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IStaffRepoMock.UpdateStaff")
		} else {
			m.t.Errorf("Expected call to IStaffRepoMock.UpdateStaff with params: %#v", *m.UpdateStaffMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStaff != nil && mm_atomic.LoadUint64(&m.afterUpdateStaffCounter) < 1 {
		m.t.Error("Expected call to IStaffRepoMock.UpdateStaff")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStaffRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateStaffInspect()

		m.MinimockGetListInspect()

		m.MinimockGetListDoramaInspect()

		m.MinimockGetListNameInspect()

		m.MinimockUpdateStaffInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStaffRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStaffRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateStaffDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetListDoramaDone() &&
		m.MinimockGetListNameDone() &&
		m.MinimockUpdateStaffDone()
}
