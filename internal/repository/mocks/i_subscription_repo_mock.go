package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i DoramaSet/internal/interfaces.ISubscriptionRepo -o ..\repository\mocks\i_subscription_repo_mock_test.go -n ISubscriptionRepoMock

import (
	"DoramaSet/internal/logic/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ISubscriptionRepoMock implements interfaces.ISubscriptionRepo
type ISubscriptionRepoMock struct {
	t minimock.Tester

	funcGetList          func() (sa1 []model.Subscription, err error)
	inspectFuncGetList   func()
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mISubscriptionRepoMockGetList

	funcGetSubscription          func(id int) (sp1 *model.Subscription, err error)
	inspectFuncGetSubscription   func(id int)
	afterGetSubscriptionCounter  uint64
	beforeGetSubscriptionCounter uint64
	GetSubscriptionMock          mISubscriptionRepoMockGetSubscription

	funcGetSubscriptionByPrice          func(price int) (sp1 *model.Subscription, err error)
	inspectFuncGetSubscriptionByPrice   func(price int)
	afterGetSubscriptionByPriceCounter  uint64
	beforeGetSubscriptionByPriceCounter uint64
	GetSubscriptionByPriceMock          mISubscriptionRepoMockGetSubscriptionByPrice
}

// NewISubscriptionRepoMock returns a mock for interfaces.ISubscriptionRepo
func NewISubscriptionRepoMock(t minimock.Tester) *ISubscriptionRepoMock {
	m := &ISubscriptionRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetListMock = mISubscriptionRepoMockGetList{mock: m}

	m.GetSubscriptionMock = mISubscriptionRepoMockGetSubscription{mock: m}
	m.GetSubscriptionMock.callArgs = []*ISubscriptionRepoMockGetSubscriptionParams{}

	m.GetSubscriptionByPriceMock = mISubscriptionRepoMockGetSubscriptionByPrice{mock: m}
	m.GetSubscriptionByPriceMock.callArgs = []*ISubscriptionRepoMockGetSubscriptionByPriceParams{}

	return m
}

type mISubscriptionRepoMockGetList struct {
	mock               *ISubscriptionRepoMock
	defaultExpectation *ISubscriptionRepoMockGetListExpectation
	expectations       []*ISubscriptionRepoMockGetListExpectation
}

// ISubscriptionRepoMockGetListExpectation specifies expectation struct of the ISubscriptionRepo.GetList
type ISubscriptionRepoMockGetListExpectation struct {
	mock *ISubscriptionRepoMock

	results *ISubscriptionRepoMockGetListResults
	Counter uint64
}

// ISubscriptionRepoMockGetListResults contains results of the ISubscriptionRepo.GetList
type ISubscriptionRepoMockGetListResults struct {
	sa1 []model.Subscription
	err error
}

// Expect sets up expected params for ISubscriptionRepo.GetList
func (mmGetList *mISubscriptionRepoMockGetList) Expect() *mISubscriptionRepoMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("ISubscriptionRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &ISubscriptionRepoMockGetListExpectation{}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionRepo.GetList
func (mmGetList *mISubscriptionRepoMockGetList) Inspect(f func()) *mISubscriptionRepoMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for ISubscriptionRepoMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by ISubscriptionRepo.GetList
func (mmGetList *mISubscriptionRepoMockGetList) Return(sa1 []model.Subscription, err error) *ISubscriptionRepoMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("ISubscriptionRepoMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &ISubscriptionRepoMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &ISubscriptionRepoMockGetListResults{sa1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the ISubscriptionRepo.GetList method
func (mmGetList *mISubscriptionRepoMockGetList) Set(f func() (sa1 []model.Subscription, err error)) *ISubscriptionRepoMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the ISubscriptionRepo.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the ISubscriptionRepo.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// GetList implements interfaces.ISubscriptionRepo
func (mmGetList *ISubscriptionRepoMock) GetList() (sa1 []model.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList()
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the ISubscriptionRepoMock.GetList")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList()
	}
	mmGetList.t.Fatalf("Unexpected call to ISubscriptionRepoMock.GetList.")
	return
}

// GetListAfterCounter returns a count of finished ISubscriptionRepoMock.GetList invocations
func (mmGetList *ISubscriptionRepoMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of ISubscriptionRepoMock.GetList invocations
func (mmGetList *ISubscriptionRepoMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *ISubscriptionRepoMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *ISubscriptionRepoMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ISubscriptionRepoMock.GetList")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionRepoMock.GetList")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionRepoMock.GetList")
	}
}

type mISubscriptionRepoMockGetSubscription struct {
	mock               *ISubscriptionRepoMock
	defaultExpectation *ISubscriptionRepoMockGetSubscriptionExpectation
	expectations       []*ISubscriptionRepoMockGetSubscriptionExpectation

	callArgs []*ISubscriptionRepoMockGetSubscriptionParams
	mutex    sync.RWMutex
}

// ISubscriptionRepoMockGetSubscriptionExpectation specifies expectation struct of the ISubscriptionRepo.GetSubscription
type ISubscriptionRepoMockGetSubscriptionExpectation struct {
	mock    *ISubscriptionRepoMock
	params  *ISubscriptionRepoMockGetSubscriptionParams
	results *ISubscriptionRepoMockGetSubscriptionResults
	Counter uint64
}

// ISubscriptionRepoMockGetSubscriptionParams contains parameters of the ISubscriptionRepo.GetSubscription
type ISubscriptionRepoMockGetSubscriptionParams struct {
	id int
}

// ISubscriptionRepoMockGetSubscriptionResults contains results of the ISubscriptionRepo.GetSubscription
type ISubscriptionRepoMockGetSubscriptionResults struct {
	sp1 *model.Subscription
	err error
}

// Expect sets up expected params for ISubscriptionRepo.GetSubscription
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) Expect(id int) *mISubscriptionRepoMockGetSubscription {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &ISubscriptionRepoMockGetSubscriptionExpectation{}
	}

	mmGetSubscription.defaultExpectation.params = &ISubscriptionRepoMockGetSubscriptionParams{id}
	for _, e := range mmGetSubscription.expectations {
		if minimock.Equal(e.params, mmGetSubscription.defaultExpectation.params) {
			mmGetSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscription.defaultExpectation.params)
		}
	}

	return mmGetSubscription
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionRepo.GetSubscription
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) Inspect(f func(id int)) *mISubscriptionRepoMockGetSubscription {
	if mmGetSubscription.mock.inspectFuncGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("Inspect function is already set for ISubscriptionRepoMock.GetSubscription")
	}

	mmGetSubscription.mock.inspectFuncGetSubscription = f

	return mmGetSubscription
}

// Return sets up results that will be returned by ISubscriptionRepo.GetSubscription
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) Return(sp1 *model.Subscription, err error) *ISubscriptionRepoMock {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &ISubscriptionRepoMockGetSubscriptionExpectation{mock: mmGetSubscription.mock}
	}
	mmGetSubscription.defaultExpectation.results = &ISubscriptionRepoMockGetSubscriptionResults{sp1, err}
	return mmGetSubscription.mock
}

// Set uses given function f to mock the ISubscriptionRepo.GetSubscription method
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) Set(f func(id int) (sp1 *model.Subscription, err error)) *ISubscriptionRepoMock {
	if mmGetSubscription.defaultExpectation != nil {
		mmGetSubscription.mock.t.Fatalf("Default expectation is already set for the ISubscriptionRepo.GetSubscription method")
	}

	if len(mmGetSubscription.expectations) > 0 {
		mmGetSubscription.mock.t.Fatalf("Some expectations are already set for the ISubscriptionRepo.GetSubscription method")
	}

	mmGetSubscription.mock.funcGetSubscription = f
	return mmGetSubscription.mock
}

// When sets expectation for the ISubscriptionRepo.GetSubscription which will trigger the result defined by the following
// Then helper
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) When(id int) *ISubscriptionRepoMockGetSubscriptionExpectation {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscription mock is already set by Set")
	}

	expectation := &ISubscriptionRepoMockGetSubscriptionExpectation{
		mock:   mmGetSubscription.mock,
		params: &ISubscriptionRepoMockGetSubscriptionParams{id},
	}
	mmGetSubscription.expectations = append(mmGetSubscription.expectations, expectation)
	return expectation
}

// Then sets up ISubscriptionRepo.GetSubscription return parameters for the expectation previously defined by the When method
func (e *ISubscriptionRepoMockGetSubscriptionExpectation) Then(sp1 *model.Subscription, err error) *ISubscriptionRepoMock {
	e.results = &ISubscriptionRepoMockGetSubscriptionResults{sp1, err}
	return e.mock
}

// GetSubscription implements interfaces.ISubscriptionRepo
func (mmGetSubscription *ISubscriptionRepoMock) GetSubscription(id int) (sp1 *model.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetSubscription.beforeGetSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscription.afterGetSubscriptionCounter, 1)

	if mmGetSubscription.inspectFuncGetSubscription != nil {
		mmGetSubscription.inspectFuncGetSubscription(id)
	}

	mm_params := &ISubscriptionRepoMockGetSubscriptionParams{id}

	// Record call args
	mmGetSubscription.GetSubscriptionMock.mutex.Lock()
	mmGetSubscription.GetSubscriptionMock.callArgs = append(mmGetSubscription.GetSubscriptionMock.callArgs, mm_params)
	mmGetSubscription.GetSubscriptionMock.mutex.Unlock()

	for _, e := range mmGetSubscription.GetSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSubscription.GetSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscription.GetSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscription.GetSubscriptionMock.defaultExpectation.params
		mm_got := ISubscriptionRepoMockGetSubscriptionParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscription.t.Errorf("ISubscriptionRepoMock.GetSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscription.GetSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscription.t.Fatal("No results are set for the ISubscriptionRepoMock.GetSubscription")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSubscription.funcGetSubscription != nil {
		return mmGetSubscription.funcGetSubscription(id)
	}
	mmGetSubscription.t.Fatalf("Unexpected call to ISubscriptionRepoMock.GetSubscription. %v", id)
	return
}

// GetSubscriptionAfterCounter returns a count of finished ISubscriptionRepoMock.GetSubscription invocations
func (mmGetSubscription *ISubscriptionRepoMock) GetSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscription.afterGetSubscriptionCounter)
}

// GetSubscriptionBeforeCounter returns a count of ISubscriptionRepoMock.GetSubscription invocations
func (mmGetSubscription *ISubscriptionRepoMock) GetSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscription.beforeGetSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to ISubscriptionRepoMock.GetSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscription *mISubscriptionRepoMockGetSubscription) Calls() []*ISubscriptionRepoMockGetSubscriptionParams {
	mmGetSubscription.mutex.RLock()

	argCopy := make([]*ISubscriptionRepoMockGetSubscriptionParams, len(mmGetSubscription.callArgs))
	copy(argCopy, mmGetSubscription.callArgs)

	mmGetSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionDone returns true if the count of the GetSubscription invocations corresponds
// the number of defined expectations
func (m *ISubscriptionRepoMock) MinimockGetSubscriptionDone() bool {
	for _, e := range m.GetSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionInspect logs each unmet expectation
func (m *ISubscriptionRepoMock) MinimockGetSubscriptionInspect() {
	for _, e := range m.GetSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ISubscriptionRepoMock.GetSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionCounter) < 1 {
		if m.GetSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ISubscriptionRepoMock.GetSubscription")
		} else {
			m.t.Errorf("Expected call to ISubscriptionRepoMock.GetSubscription with params: %#v", *m.GetSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionRepoMock.GetSubscription")
	}
}

type mISubscriptionRepoMockGetSubscriptionByPrice struct {
	mock               *ISubscriptionRepoMock
	defaultExpectation *ISubscriptionRepoMockGetSubscriptionByPriceExpectation
	expectations       []*ISubscriptionRepoMockGetSubscriptionByPriceExpectation

	callArgs []*ISubscriptionRepoMockGetSubscriptionByPriceParams
	mutex    sync.RWMutex
}

// ISubscriptionRepoMockGetSubscriptionByPriceExpectation specifies expectation struct of the ISubscriptionRepo.GetSubscriptionByPrice
type ISubscriptionRepoMockGetSubscriptionByPriceExpectation struct {
	mock    *ISubscriptionRepoMock
	params  *ISubscriptionRepoMockGetSubscriptionByPriceParams
	results *ISubscriptionRepoMockGetSubscriptionByPriceResults
	Counter uint64
}

// ISubscriptionRepoMockGetSubscriptionByPriceParams contains parameters of the ISubscriptionRepo.GetSubscriptionByPrice
type ISubscriptionRepoMockGetSubscriptionByPriceParams struct {
	price int
}

// ISubscriptionRepoMockGetSubscriptionByPriceResults contains results of the ISubscriptionRepo.GetSubscriptionByPrice
type ISubscriptionRepoMockGetSubscriptionByPriceResults struct {
	sp1 *model.Subscription
	err error
}

// Expect sets up expected params for ISubscriptionRepo.GetSubscriptionByPrice
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) Expect(price int) *mISubscriptionRepoMockGetSubscriptionByPrice {
	if mmGetSubscriptionByPrice.mock.funcGetSubscriptionByPrice != nil {
		mmGetSubscriptionByPrice.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscriptionByPrice mock is already set by Set")
	}

	if mmGetSubscriptionByPrice.defaultExpectation == nil {
		mmGetSubscriptionByPrice.defaultExpectation = &ISubscriptionRepoMockGetSubscriptionByPriceExpectation{}
	}

	mmGetSubscriptionByPrice.defaultExpectation.params = &ISubscriptionRepoMockGetSubscriptionByPriceParams{price}
	for _, e := range mmGetSubscriptionByPrice.expectations {
		if minimock.Equal(e.params, mmGetSubscriptionByPrice.defaultExpectation.params) {
			mmGetSubscriptionByPrice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscriptionByPrice.defaultExpectation.params)
		}
	}

	return mmGetSubscriptionByPrice
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionRepo.GetSubscriptionByPrice
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) Inspect(f func(price int)) *mISubscriptionRepoMockGetSubscriptionByPrice {
	if mmGetSubscriptionByPrice.mock.inspectFuncGetSubscriptionByPrice != nil {
		mmGetSubscriptionByPrice.mock.t.Fatalf("Inspect function is already set for ISubscriptionRepoMock.GetSubscriptionByPrice")
	}

	mmGetSubscriptionByPrice.mock.inspectFuncGetSubscriptionByPrice = f

	return mmGetSubscriptionByPrice
}

// Return sets up results that will be returned by ISubscriptionRepo.GetSubscriptionByPrice
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) Return(sp1 *model.Subscription, err error) *ISubscriptionRepoMock {
	if mmGetSubscriptionByPrice.mock.funcGetSubscriptionByPrice != nil {
		mmGetSubscriptionByPrice.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscriptionByPrice mock is already set by Set")
	}

	if mmGetSubscriptionByPrice.defaultExpectation == nil {
		mmGetSubscriptionByPrice.defaultExpectation = &ISubscriptionRepoMockGetSubscriptionByPriceExpectation{mock: mmGetSubscriptionByPrice.mock}
	}
	mmGetSubscriptionByPrice.defaultExpectation.results = &ISubscriptionRepoMockGetSubscriptionByPriceResults{sp1, err}
	return mmGetSubscriptionByPrice.mock
}

// Set uses given function f to mock the ISubscriptionRepo.GetSubscriptionByPrice method
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) Set(f func(price int) (sp1 *model.Subscription, err error)) *ISubscriptionRepoMock {
	if mmGetSubscriptionByPrice.defaultExpectation != nil {
		mmGetSubscriptionByPrice.mock.t.Fatalf("Default expectation is already set for the ISubscriptionRepo.GetSubscriptionByPrice method")
	}

	if len(mmGetSubscriptionByPrice.expectations) > 0 {
		mmGetSubscriptionByPrice.mock.t.Fatalf("Some expectations are already set for the ISubscriptionRepo.GetSubscriptionByPrice method")
	}

	mmGetSubscriptionByPrice.mock.funcGetSubscriptionByPrice = f
	return mmGetSubscriptionByPrice.mock
}

// When sets expectation for the ISubscriptionRepo.GetSubscriptionByPrice which will trigger the result defined by the following
// Then helper
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) When(price int) *ISubscriptionRepoMockGetSubscriptionByPriceExpectation {
	if mmGetSubscriptionByPrice.mock.funcGetSubscriptionByPrice != nil {
		mmGetSubscriptionByPrice.mock.t.Fatalf("ISubscriptionRepoMock.GetSubscriptionByPrice mock is already set by Set")
	}

	expectation := &ISubscriptionRepoMockGetSubscriptionByPriceExpectation{
		mock:   mmGetSubscriptionByPrice.mock,
		params: &ISubscriptionRepoMockGetSubscriptionByPriceParams{price},
	}
	mmGetSubscriptionByPrice.expectations = append(mmGetSubscriptionByPrice.expectations, expectation)
	return expectation
}

// Then sets up ISubscriptionRepo.GetSubscriptionByPrice return parameters for the expectation previously defined by the When method
func (e *ISubscriptionRepoMockGetSubscriptionByPriceExpectation) Then(sp1 *model.Subscription, err error) *ISubscriptionRepoMock {
	e.results = &ISubscriptionRepoMockGetSubscriptionByPriceResults{sp1, err}
	return e.mock
}

// GetSubscriptionByPrice implements interfaces.ISubscriptionRepo
func (mmGetSubscriptionByPrice *ISubscriptionRepoMock) GetSubscriptionByPrice(price int) (sp1 *model.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetSubscriptionByPrice.beforeGetSubscriptionByPriceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscriptionByPrice.afterGetSubscriptionByPriceCounter, 1)

	if mmGetSubscriptionByPrice.inspectFuncGetSubscriptionByPrice != nil {
		mmGetSubscriptionByPrice.inspectFuncGetSubscriptionByPrice(price)
	}

	mm_params := &ISubscriptionRepoMockGetSubscriptionByPriceParams{price}

	// Record call args
	mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.mutex.Lock()
	mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.callArgs = append(mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.callArgs, mm_params)
	mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.mutex.Unlock()

	for _, e := range mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.defaultExpectation.params
		mm_got := ISubscriptionRepoMockGetSubscriptionByPriceParams{price}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscriptionByPrice.t.Errorf("ISubscriptionRepoMock.GetSubscriptionByPrice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscriptionByPrice.GetSubscriptionByPriceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscriptionByPrice.t.Fatal("No results are set for the ISubscriptionRepoMock.GetSubscriptionByPrice")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSubscriptionByPrice.funcGetSubscriptionByPrice != nil {
		return mmGetSubscriptionByPrice.funcGetSubscriptionByPrice(price)
	}
	mmGetSubscriptionByPrice.t.Fatalf("Unexpected call to ISubscriptionRepoMock.GetSubscriptionByPrice. %v", price)
	return
}

// GetSubscriptionByPriceAfterCounter returns a count of finished ISubscriptionRepoMock.GetSubscriptionByPrice invocations
func (mmGetSubscriptionByPrice *ISubscriptionRepoMock) GetSubscriptionByPriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionByPrice.afterGetSubscriptionByPriceCounter)
}

// GetSubscriptionByPriceBeforeCounter returns a count of ISubscriptionRepoMock.GetSubscriptionByPrice invocations
func (mmGetSubscriptionByPrice *ISubscriptionRepoMock) GetSubscriptionByPriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionByPrice.beforeGetSubscriptionByPriceCounter)
}

// Calls returns a list of arguments used in each call to ISubscriptionRepoMock.GetSubscriptionByPrice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscriptionByPrice *mISubscriptionRepoMockGetSubscriptionByPrice) Calls() []*ISubscriptionRepoMockGetSubscriptionByPriceParams {
	mmGetSubscriptionByPrice.mutex.RLock()

	argCopy := make([]*ISubscriptionRepoMockGetSubscriptionByPriceParams, len(mmGetSubscriptionByPrice.callArgs))
	copy(argCopy, mmGetSubscriptionByPrice.callArgs)

	mmGetSubscriptionByPrice.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionByPriceDone returns true if the count of the GetSubscriptionByPrice invocations corresponds
// the number of defined expectations
func (m *ISubscriptionRepoMock) MinimockGetSubscriptionByPriceDone() bool {
	for _, e := range m.GetSubscriptionByPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionByPriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionByPriceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionByPrice != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionByPriceCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionByPriceInspect logs each unmet expectation
func (m *ISubscriptionRepoMock) MinimockGetSubscriptionByPriceInspect() {
	for _, e := range m.GetSubscriptionByPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ISubscriptionRepoMock.GetSubscriptionByPrice with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionByPriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionByPriceCounter) < 1 {
		if m.GetSubscriptionByPriceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ISubscriptionRepoMock.GetSubscriptionByPrice")
		} else {
			m.t.Errorf("Expected call to ISubscriptionRepoMock.GetSubscriptionByPrice with params: %#v", *m.GetSubscriptionByPriceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionByPrice != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionByPriceCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionRepoMock.GetSubscriptionByPrice")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ISubscriptionRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetListInspect()

		m.MinimockGetSubscriptionInspect()

		m.MinimockGetSubscriptionByPriceInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ISubscriptionRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ISubscriptionRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetListDone() &&
		m.MinimockGetSubscriptionDone() &&
		m.MinimockGetSubscriptionByPriceDone()
}
